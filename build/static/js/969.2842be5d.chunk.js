"use strict";(self.webpackChunkdBank=self.webpackChunkdBank||[]).push([[969],{5969(e,t,r){r.d(t,{wrapFetchWithPayment:()=>l,x402Client:()=>f});var n=r(2555),o=(Error,Error,(e,t)=>{let r=e.get(t);if(!r)for(const[n,o]of e.entries()){const e=n.replace(/[.*+?^${}()|[\]\\]/g,"\\$&").replace(/\\\*/g,".*");if(new RegExp("^".concat(e,"$")).test(t)){r=o;break}}return r}),s=/^[A-Za-z0-9+/]*={0,2}$/;function a(e){if("undefined"!==typeof globalThis&&"function"===typeof globalThis.atob){const t=globalThis.atob(e),r=new Uint8Array(t.length);for(let e=0;e<t.length;e++)r[e]=t.charCodeAt(e);return new TextDecoder("utf-8").decode(r)}return Buffer.from(e,"base64").toString("utf-8")}Error;var i=class{constructor(e){this.client=e}encodePaymentSignatureHeader(e){switch(e.x402Version){case 2:return{"PAYMENT-SIGNATURE":c(e)};case 1:return{"X-PAYMENT":c(e)};default:throw new Error("Unsupported x402 version: ".concat(e.x402Version))}}getPaymentRequiredResponse(e,t){const r=e("PAYMENT-REQUIRED");if(r)return function(e){if(!s.test(e))throw new Error("Invalid payment required header");return JSON.parse(a(e))}(r);if(t&&t instanceof Object&&"x402Version"in t&&1===t.x402Version)return t;throw new Error("Invalid payment required response")}getPaymentSettleResponse(e){const t=e("PAYMENT-RESPONSE");if(t)return h(t);const r=e("X-PAYMENT-RESPONSE");if(r)return h(r);throw new Error("Payment response header not found")}async createPaymentPayload(e){return this.client.createPaymentPayload(e)}};function c(e){return function(e){if("undefined"!==typeof globalThis&&"function"===typeof globalThis.btoa){const t=(new TextEncoder).encode(e),r=Array.from(t,e=>String.fromCharCode(e)).join("");return globalThis.btoa(r)}return Buffer.from(e,"utf8").toString("base64")}(JSON.stringify(e))}function h(e){if(!s.test(e))throw new Error("Invalid payment response header");return JSON.parse(a(e))}var f=class e{constructor(e){this.registeredClientSchemes=new Map,this.policies=[],this.beforePaymentCreationHooks=[],this.afterPaymentCreationHooks=[],this.onPaymentCreationFailureHooks=[],this.paymentRequirementsSelector=e||((e,t)=>t[0])}static fromConfig(t){var r;const n=new e(t.paymentRequirementsSelector);return t.schemes.forEach(e=>{1===e.x402Version?n.registerV1(e.network,e.client):n.register(e.network,e.client)}),null===(r=t.policies)||void 0===r||r.forEach(e=>{n.registerPolicy(e)}),n}register(e,t){return this._registerScheme(2,e,t)}registerV1(e,t){return this._registerScheme(1,e,t)}registerPolicy(e){return this.policies.push(e),this}onBeforePaymentCreation(e){return this.beforePaymentCreationHooks.push(e),this}onAfterPaymentCreation(e){return this.afterPaymentCreationHooks.push(e),this}onPaymentCreationFailure(e){return this.onPaymentCreationFailureHooks.push(e),this}async createPaymentPayload(e){const t=this.registeredClientSchemes.get(e.x402Version);if(!t)throw new Error("No client registered for x402 version: ".concat(e.x402Version));const r=this.selectPaymentRequirements(e.x402Version,e.accepts),s={paymentRequired:e,selectedRequirements:r};for(const n of this.beforePaymentCreationHooks){const e=await n(s);if(e&&"abort"in e&&e.abort)throw new Error("Payment creation aborted: ".concat(e.reason))}try{const a=((e,t,r)=>{var n;return null===(n=o(e,r))||void 0===n?void 0:n.get(t)})(t,r.scheme,r.network);if(!a)throw new Error("No client registered for scheme: ".concat(r.scheme," and network: ").concat(r.network));const i=await a.createPaymentPayload(e.x402Version,r);let c;c=1==i.x402Version?i:(0,n.A)((0,n.A)({},i),{},{extensions:e.extensions,resource:e.resource,accepted:r});const h=(0,n.A)((0,n.A)({},s),{},{paymentPayload:c});for(const e of this.afterPaymentCreationHooks)await e(h);return c}catch(a){const e=(0,n.A)((0,n.A)({},s),{},{error:a});for(const t of this.onPaymentCreationFailureHooks){const r=await t(e);if(r&&"recovered"in r&&r.recovered)return r.payload}throw a}}selectPaymentRequirements(e,t){const r=this.registeredClientSchemes.get(e);if(!r)throw new Error("No client registered for x402 version: ".concat(e));const n=t.filter(e=>{let t=o(r,e.network);return!!t&&t.has(e.scheme)});if(0===n.length)throw new Error("No network/scheme registered for x402 version: ".concat(e," which comply with the payment requirements. ").concat(JSON.stringify({x402Version:e,paymentRequirements:t,x402Versions:Array.from(this.registeredClientSchemes.keys()),networks:Array.from(r.keys()),schemes:Array.from(r.values()).map(e=>Array.from(e.keys())).flat()})));let s=n;for(const o of this.policies)if(s=o(e,s),0===s.length)throw new Error("All payment requirements were filtered out by policies for x402 version: ".concat(e));return this.paymentRequirementsSelector(e,s)}_registerScheme(e,t,r){this.registeredClientSchemes.has(e)||this.registeredClientSchemes.set(e,new Map);const n=this.registeredClientSchemes.get(e);n.has(t)||n.set(t,new Map);const o=n.get(t);return o.has(r.scheme)||o.set(r.scheme,r),this}};function l(e,t){const r=t instanceof i?t:new i(t);return async(n,o)=>{const s=new Request(n,o),a=s.clone(),i=await e(s);if(402!==i.status)return i;let c,h;try{const e=e=>i.headers.get(e);let t;try{const e=await i.text();e&&(t=JSON.parse(e))}catch(l){}c=r.getPaymentRequiredResponse(e,t)}catch(u){throw new Error("Failed to parse payment requirements: ".concat(u instanceof Error?u.message:"Unknown error"))}try{h=await t.createPaymentPayload(c)}catch(u){throw new Error("Failed to create payment payload: ".concat(u instanceof Error?u.message:"Unknown error"))}const f=r.encodePaymentSignatureHeader(h);if(a.headers.has("PAYMENT-SIGNATURE")||a.headers.has("X-PAYMENT"))throw new Error("Payment already attempted");for(const[e,t]of Object.entries(f))a.headers.set(e,t);a.headers.set("Access-Control-Expose-Headers","PAYMENT-RESPONSE,X-PAYMENT-RESPONSE");return await e(a)}}}}]);
//# sourceMappingURL=969.2842be5d.chunk.js.map