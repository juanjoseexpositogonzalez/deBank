{"version":3,"file":"static/js/969.2842be5d.chunk.js","mappings":"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","sources":["../node_modules/@x402/core/src/utils/index.ts","../node_modules/@x402/core/src/types/facilitator.ts","../node_modules/@x402/core/src/http/x402HTTPResourceServer.ts","../node_modules/@x402/core/src/http/x402HTTPClient.ts","../node_modules/@x402/core/src/http/index.ts","../node_modules/@x402/core/src/index.ts","../node_modules/@x402/core/src/client/x402Client.ts","../node_modules/@x402/fetch/src/index.ts"],"sourcesContent":["import { Network } from \"../types\";\n\n/**\n * Scheme data structure for facilitator storage\n */\nexport interface SchemeData<T> {\n  facilitator: T;\n  networks: Set<Network>;\n  pattern: Network;\n}\n\nexport const findSchemesByNetwork = <T>(\n  map: Map<string, Map<string, T>>,\n  network: Network,\n): Map<string, T> | undefined => {\n  // Direct match first\n  let implementationsByScheme = map.get(network);\n\n  if (!implementationsByScheme) {\n    // Try pattern matching for registered network patterns\n    for (const [registeredNetworkPattern, implementations] of map.entries()) {\n      // Convert the registered network pattern to a regex\n      // e.g., \"eip155:*\" becomes /^eip155:.*$/\n      const pattern = registeredNetworkPattern\n        .replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\") // Escape special regex chars except *\n        .replace(/\\\\\\*/g, \".*\"); // Replace escaped * with .*\n\n      const regex = new RegExp(`^${pattern}$`);\n\n      if (regex.test(network)) {\n        implementationsByScheme = implementations;\n        break;\n      }\n    }\n  }\n\n  return implementationsByScheme;\n};\n\nexport const findByNetworkAndScheme = <T>(\n  map: Map<string, Map<string, T>>,\n  scheme: string,\n  network: Network,\n): T | undefined => {\n  return findSchemesByNetwork(map, network)?.get(scheme);\n};\n\n/**\n * Finds a facilitator by scheme and network using pattern matching.\n * Works with new SchemeData storage structure.\n *\n * @param schemeMap - Map of scheme names to SchemeData\n * @param scheme - The scheme to find\n * @param network - The network to match against\n * @returns The facilitator if found, undefined otherwise\n */\nexport const findFacilitatorBySchemeAndNetwork = <T>(\n  schemeMap: Map<string, SchemeData<T>>,\n  scheme: string,\n  network: Network,\n): T | undefined => {\n  const schemeData = schemeMap.get(scheme);\n  if (!schemeData) return undefined;\n\n  // Check if network is in the stored networks set\n  if (schemeData.networks.has(network)) {\n    return schemeData.facilitator;\n  }\n\n  // Try pattern matching\n  const patternRegex = new RegExp(\"^\" + schemeData.pattern.replace(\"*\", \".*\") + \"$\");\n  if (patternRegex.test(network)) {\n    return schemeData.facilitator;\n  }\n\n  return undefined;\n};\n\nexport const Base64EncodedRegex = /^[A-Za-z0-9+/]*={0,2}$/;\n\n/**\n * Encodes a string to base64 format\n *\n * @param data - The string to be encoded to base64\n * @returns The base64 encoded string\n */\nexport function safeBase64Encode(data: string): string {\n  if (typeof globalThis !== \"undefined\" && typeof globalThis.btoa === \"function\") {\n    const bytes = new TextEncoder().encode(data);\n    const binaryString = Array.from(bytes, byte => String.fromCharCode(byte)).join(\"\");\n    return globalThis.btoa(binaryString);\n  }\n  return Buffer.from(data, \"utf8\").toString(\"base64\");\n}\n\n/**\n * Decodes a base64 string back to its original format\n *\n * @param data - The base64 encoded string to be decoded\n * @returns The decoded string in UTF-8 format\n */\nexport function safeBase64Decode(data: string): string {\n  if (typeof globalThis !== \"undefined\" && typeof globalThis.atob === \"function\") {\n    const binaryString = globalThis.atob(data);\n    const bytes = new Uint8Array(binaryString.length);\n    for (let i = 0; i < binaryString.length; i++) {\n      bytes[i] = binaryString.charCodeAt(i);\n    }\n    const decoder = new TextDecoder(\"utf-8\");\n    return decoder.decode(bytes);\n  }\n  return Buffer.from(data, \"base64\").toString(\"utf-8\");\n}\n\n/**\n * Deep equality comparison for payment requirements\n * Uses a normalized JSON.stringify for consistent comparison\n *\n * @param obj1 - First object to compare\n * @param obj2 - Second object to compare\n * @returns True if objects are deeply equal\n */\nexport function deepEqual(obj1: unknown, obj2: unknown): boolean {\n  // Normalize and stringify both objects for comparison\n  // This handles nested objects, arrays, and different property orders\n  const normalize = (obj: unknown): string => {\n    // Handle primitives and null/undefined\n    if (obj === null || obj === undefined) return JSON.stringify(obj);\n    if (typeof obj !== \"object\") return JSON.stringify(obj);\n\n    // Handle arrays\n    if (Array.isArray(obj)) {\n      return JSON.stringify(\n        obj.map(item =>\n          typeof item === \"object\" && item !== null ? JSON.parse(normalize(item)) : item,\n        ),\n      );\n    }\n\n    // Handle objects - sort keys and recursively normalize values\n    const sorted: Record<string, unknown> = {};\n    Object.keys(obj as Record<string, unknown>)\n      .sort()\n      .forEach(key => {\n        const value = (obj as Record<string, unknown>)[key];\n        sorted[key] =\n          typeof value === \"object\" && value !== null ? JSON.parse(normalize(value)) : value;\n      });\n    return JSON.stringify(sorted);\n  };\n\n  try {\n    return normalize(obj1) === normalize(obj2);\n  } catch {\n    // Fallback to simple comparison if normalization fails\n    return JSON.stringify(obj1) === JSON.stringify(obj2);\n  }\n}\n","import { PaymentPayload, PaymentRequirements } from \"./payments\";\nimport { Network } from \"./\";\n\nexport type VerifyRequest = {\n  paymentPayload: PaymentPayload;\n  paymentRequirements: PaymentRequirements;\n};\n\nexport type VerifyResponse = {\n  isValid: boolean;\n  invalidReason?: string;\n  payer?: string;\n};\n\nexport type SettleRequest = {\n  paymentPayload: PaymentPayload;\n  paymentRequirements: PaymentRequirements;\n};\n\nexport type SettleResponse = {\n  success: boolean;\n  errorReason?: string;\n  payer?: string;\n  transaction: string;\n  network: Network;\n};\n\nexport type SupportedKind = {\n  x402Version: number;\n  scheme: string;\n  network: Network;\n  extra?: Record<string, unknown>;\n};\n\nexport type SupportedResponse = {\n  kinds: SupportedKind[];\n  extensions: string[];\n  signers: Record<string, string[]>; // CAIP family pattern â†’ Signer addresses\n};\n\n/**\n * Error thrown when payment verification fails.\n */\nexport class VerifyError extends Error {\n  readonly invalidReason?: string;\n  readonly payer?: string;\n  readonly statusCode: number;\n\n  /**\n   * Creates a VerifyError from a failed verification response.\n   *\n   * @param statusCode - HTTP status code from the facilitator\n   * @param response - The verify response containing error details\n   */\n  constructor(statusCode: number, response: VerifyResponse) {\n    super(`verification failed: ${response.invalidReason || \"unknown reason\"}`);\n    this.name = \"VerifyError\";\n    this.statusCode = statusCode;\n    this.invalidReason = response.invalidReason;\n    this.payer = response.payer;\n  }\n}\n\n/**\n * Error thrown when payment settlement fails.\n */\nexport class SettleError extends Error {\n  readonly errorReason?: string;\n  readonly payer?: string;\n  readonly transaction: string;\n  readonly network: Network;\n  readonly statusCode: number;\n\n  /**\n   * Creates a SettleError from a failed settlement response.\n   *\n   * @param statusCode - HTTP status code from the facilitator\n   * @param response - The settle response containing error details\n   */\n  constructor(statusCode: number, response: SettleResponse) {\n    super(`settlement failed: ${response.errorReason || \"unknown reason\"}`);\n    this.name = \"SettleError\";\n    this.statusCode = statusCode;\n    this.errorReason = response.errorReason;\n    this.payer = response.payer;\n    this.transaction = response.transaction;\n    this.network = response.network;\n  }\n}\n","import { x402ResourceServer } from \"../server\";\nimport {\n  decodePaymentSignatureHeader,\n  encodePaymentRequiredHeader,\n  encodePaymentResponseHeader,\n} from \".\";\nimport {\n  PaymentPayload,\n  PaymentRequired,\n  SettleResponse,\n  SettleError,\n  Price,\n  Network,\n  PaymentRequirements,\n} from \"../types\";\nimport { x402Version } from \"..\";\n\n/**\n * Framework-agnostic HTTP adapter interface\n * Implementations provide framework-specific HTTP operations\n */\nexport interface HTTPAdapter {\n  getHeader(name: string): string | undefined;\n  getMethod(): string;\n  getPath(): string;\n  getUrl(): string;\n  getAcceptHeader(): string;\n  getUserAgent(): string;\n\n  /**\n   * Get query parameters from the request URL\n   *\n   * @returns Record of query parameter key-value pairs\n   */\n  getQueryParams?(): Record<string, string | string[]>;\n\n  /**\n   * Get a specific query parameter by name\n   *\n   * @param name - The query parameter name\n   * @returns The query parameter value(s) or undefined\n   */\n  getQueryParam?(name: string): string | string[] | undefined;\n\n  /**\n   * Get the parsed request body\n   * Framework adapters should parse JSON/form data appropriately\n   *\n   * @returns The parsed request body\n   */\n  getBody?(): unknown;\n}\n\n/**\n * Paywall configuration for HTML responses\n */\nexport interface PaywallConfig {\n  appName?: string;\n  appLogo?: string;\n  sessionTokenEndpoint?: string;\n  currentUrl?: string;\n  testnet?: boolean;\n}\n\n/**\n * Paywall provider interface for generating HTML\n */\nexport interface PaywallProvider {\n  generateHtml(paymentRequired: PaymentRequired, config?: PaywallConfig): string;\n}\n\n/**\n * Dynamic payTo function that receives HTTP request context\n */\nexport type DynamicPayTo = (context: HTTPRequestContext) => string | Promise<string>;\n\n/**\n * Dynamic price function that receives HTTP request context\n */\nexport type DynamicPrice = (context: HTTPRequestContext) => Price | Promise<Price>;\n\n/**\n * Result of the unpaid response callback containing content type and body.\n */\nexport interface UnpaidResponseResult {\n  /**\n   * The content type for the response (e.g., 'application/json', 'text/plain').\n   */\n  contentType: string;\n\n  /**\n   * The response body to include in the 402 response.\n   */\n  body: unknown;\n}\n\n/**\n * Dynamic function to generate a custom response for unpaid requests.\n * Receives the HTTP request context and returns the content type and body to include in the 402 response.\n */\nexport type UnpaidResponseBody = (\n  context: HTTPRequestContext,\n) => UnpaidResponseResult | Promise<UnpaidResponseResult>;\n\n/**\n * A single payment option for a route\n * Represents one way a client can pay for access to the resource\n */\nexport interface PaymentOption {\n  scheme: string;\n  payTo: string | DynamicPayTo;\n  price: Price | DynamicPrice;\n  network: Network;\n  maxTimeoutSeconds?: number;\n  extra?: Record<string, unknown>;\n}\n\n/**\n * Route configuration for HTTP endpoints\n *\n * The 'accepts' field defines payment options for the route.\n * Can be a single PaymentOption or an array of PaymentOptions for multiple payment methods.\n */\nexport interface RouteConfig {\n  // Payment option(s): single or array\n  accepts: PaymentOption | PaymentOption[];\n\n  // HTTP-specific metadata\n  resource?: string;\n  description?: string;\n  mimeType?: string;\n  customPaywallHtml?: string;\n\n  /**\n   * Optional callback to generate a custom response for unpaid API requests.\n   * This allows servers to return preview data, error messages, or other content\n   * when a request lacks payment.\n   *\n   * For browser requests (Accept: text/html), the paywall HTML takes precedence.\n   * This callback is only used for API clients.\n   *\n   * If not provided, defaults to { contentType: 'application/json', body: {} }.\n   *\n   * @param context - The HTTP request context\n   * @returns An object containing both contentType and body for the 402 response\n   */\n  unpaidResponseBody?: UnpaidResponseBody;\n\n  // Extensions\n  extensions?: Record<string, unknown>;\n}\n\n/**\n * Routes configuration - maps path patterns to route configs\n */\nexport type RoutesConfig = Record<string, RouteConfig> | RouteConfig;\n\n/**\n * Compiled route for efficient matching\n */\nexport interface CompiledRoute {\n  verb: string;\n  regex: RegExp;\n  config: RouteConfig;\n}\n\n/**\n * HTTP request context that encapsulates all request data\n */\nexport interface HTTPRequestContext {\n  adapter: HTTPAdapter;\n  path: string;\n  method: string;\n  paymentHeader?: string;\n}\n\n/**\n * HTTP response instructions for the framework middleware\n */\nexport interface HTTPResponseInstructions {\n  status: number;\n  headers: Record<string, string>;\n  body?: unknown; // e.g. Paywall for web browser requests, but could be any other type\n  isHtml?: boolean; // e.g. if body is a paywall, then isHtml is true\n}\n\n/**\n * Result of processing an HTTP request for payment\n */\nexport type HTTPProcessResult =\n  | { type: \"no-payment-required\" }\n  | {\n      type: \"payment-verified\";\n      paymentPayload: PaymentPayload;\n      paymentRequirements: PaymentRequirements;\n    }\n  | { type: \"payment-error\"; response: HTTPResponseInstructions };\n\n/**\n * Result of processSettlement\n */\nexport type ProcessSettleSuccessResponse = SettleResponse & {\n  success: true;\n  headers: Record<string, string>;\n  requirements: PaymentRequirements;\n};\n\nexport type ProcessSettleFailureResponse = SettleResponse & {\n  success: false;\n  errorReason: string;\n};\n\nexport type ProcessSettleResultResponse =\n  | ProcessSettleSuccessResponse\n  | ProcessSettleFailureResponse;\n\n/**\n * Represents a validation error for a specific route's payment configuration.\n */\nexport interface RouteValidationError {\n  /** The route pattern (e.g., \"GET /api/weather\") */\n  routePattern: string;\n  /** The payment scheme that failed validation */\n  scheme: string;\n  /** The network that failed validation */\n  network: Network;\n  /** The type of validation failure */\n  reason: \"missing_scheme\" | \"missing_facilitator\";\n  /** Human-readable error message */\n  message: string;\n}\n\n/**\n * Error thrown when route configuration validation fails.\n */\nexport class RouteConfigurationError extends Error {\n  /** The validation errors that caused this exception */\n  public readonly errors: RouteValidationError[];\n\n  /**\n   * Creates a new RouteConfigurationError with the given validation errors.\n   *\n   * @param errors - The validation errors that caused this exception.\n   */\n  constructor(errors: RouteValidationError[]) {\n    const message = `x402 Route Configuration Errors:\\n${errors.map(e => `  - ${e.message}`).join(\"\\n\")}`;\n    super(message);\n    this.name = \"RouteConfigurationError\";\n    this.errors = errors;\n  }\n}\n\n/**\n * HTTP-enhanced x402 resource server\n * Provides framework-agnostic HTTP protocol handling\n */\nexport class x402HTTPResourceServer {\n  private ResourceServer: x402ResourceServer;\n  private compiledRoutes: CompiledRoute[] = [];\n  private routesConfig: RoutesConfig;\n  private paywallProvider?: PaywallProvider;\n\n  /**\n   * Creates a new x402HTTPResourceServer instance.\n   *\n   * @param ResourceServer - The core x402ResourceServer instance to use\n   * @param routes - Route configuration for payment-protected endpoints\n   */\n  constructor(ResourceServer: x402ResourceServer, routes: RoutesConfig) {\n    this.ResourceServer = ResourceServer;\n    this.routesConfig = routes;\n\n    // Handle both single route and multiple routes\n    const normalizedRoutes =\n      typeof routes === \"object\" && !(\"accepts\" in routes)\n        ? (routes as Record<string, RouteConfig>)\n        : { \"*\": routes as RouteConfig };\n\n    for (const [pattern, config] of Object.entries(normalizedRoutes)) {\n      const parsed = this.parseRoutePattern(pattern);\n      this.compiledRoutes.push({\n        verb: parsed.verb,\n        regex: parsed.regex,\n        config,\n      });\n    }\n  }\n\n  /**\n   * Initialize the HTTP resource server.\n   *\n   * This method initializes the underlying resource server (fetching facilitator support)\n   * and then validates that all route payment configurations have corresponding\n   * registered schemes and facilitator support.\n   *\n   * @throws RouteConfigurationError if any route's payment options don't have\n   *         corresponding registered schemes or facilitator support\n   *\n   * @example\n   * ```typescript\n   * const httpServer = new x402HTTPResourceServer(server, routes);\n   * await httpServer.initialize();\n   * ```\n   */\n  async initialize(): Promise<void> {\n    // First, initialize the underlying resource server (fetches facilitator support)\n    await this.ResourceServer.initialize();\n\n    // Then validate route configuration\n    const errors = this.validateRouteConfiguration();\n    if (errors.length > 0) {\n      throw new RouteConfigurationError(errors);\n    }\n  }\n\n  /**\n   * Register a custom paywall provider for generating HTML\n   *\n   * @param provider - PaywallProvider instance\n   * @returns This service instance for chaining\n   */\n  registerPaywallProvider(provider: PaywallProvider): this {\n    this.paywallProvider = provider;\n    return this;\n  }\n\n  /**\n   * Process HTTP request and return response instructions\n   * This is the main entry point for framework middleware\n   *\n   * @param context - HTTP request context\n   * @param paywallConfig - Optional paywall configuration\n   * @returns Process result indicating next action for middleware\n   */\n  async processHTTPRequest(\n    context: HTTPRequestContext,\n    paywallConfig?: PaywallConfig,\n  ): Promise<HTTPProcessResult> {\n    const { adapter, path, method } = context;\n\n    // Find matching route\n    const routeConfig = this.getRouteConfig(path, method);\n    if (!routeConfig) {\n      return { type: \"no-payment-required\" }; // No payment required for this route\n    }\n\n    // Normalize accepts field to array of payment options\n    const paymentOptions = this.normalizePaymentOptions(routeConfig);\n\n    // Check for payment header (v1 or v2)\n    const paymentPayload = this.extractPayment(adapter);\n\n    // Create resource info, using config override if provided\n    const resourceInfo = {\n      url: routeConfig.resource || context.adapter.getUrl(),\n      description: routeConfig.description || \"\",\n      mimeType: routeConfig.mimeType || \"\",\n    };\n\n    // Build requirements from all payment options\n    // (this method handles resolving dynamic functions internally)\n    const requirements = await this.ResourceServer.buildPaymentRequirementsFromOptions(\n      paymentOptions,\n      context,\n    );\n\n    let extensions = routeConfig.extensions;\n    if (extensions) {\n      extensions = this.ResourceServer.enrichExtensions(extensions, context);\n    }\n\n    const paymentRequired = this.ResourceServer.createPaymentRequiredResponse(\n      requirements,\n      resourceInfo,\n      !paymentPayload ? \"Payment required\" : undefined,\n      extensions,\n    );\n\n    // If no payment provided\n    if (!paymentPayload) {\n      // Resolve custom unpaid response body if provided\n      const unpaidBody = routeConfig.unpaidResponseBody\n        ? await routeConfig.unpaidResponseBody(context)\n        : undefined;\n\n      return {\n        type: \"payment-error\",\n        response: this.createHTTPResponse(\n          paymentRequired,\n          this.isWebBrowser(adapter),\n          paywallConfig,\n          routeConfig.customPaywallHtml,\n          unpaidBody,\n        ),\n      };\n    }\n\n    // Verify payment\n    try {\n      const matchingRequirements = this.ResourceServer.findMatchingRequirements(\n        paymentRequired.accepts,\n        paymentPayload,\n      );\n\n      if (!matchingRequirements) {\n        const errorResponse = this.ResourceServer.createPaymentRequiredResponse(\n          requirements,\n          resourceInfo,\n          \"No matching payment requirements\",\n          routeConfig.extensions,\n        );\n        return {\n          type: \"payment-error\",\n          response: this.createHTTPResponse(errorResponse, false, paywallConfig),\n        };\n      }\n\n      const verifyResult = await this.ResourceServer.verifyPayment(\n        paymentPayload,\n        matchingRequirements,\n      );\n\n      if (!verifyResult.isValid) {\n        const errorResponse = this.ResourceServer.createPaymentRequiredResponse(\n          requirements,\n          resourceInfo,\n          verifyResult.invalidReason,\n          routeConfig.extensions,\n        );\n        return {\n          type: \"payment-error\",\n          response: this.createHTTPResponse(errorResponse, false, paywallConfig),\n        };\n      }\n\n      // Payment is valid, return data needed for settlement\n      return {\n        type: \"payment-verified\",\n        paymentPayload,\n        paymentRequirements: matchingRequirements,\n      };\n    } catch (error) {\n      const errorResponse = this.ResourceServer.createPaymentRequiredResponse(\n        requirements,\n        resourceInfo,\n        error instanceof Error ? error.message : \"Payment verification failed\",\n        routeConfig.extensions,\n      );\n      return {\n        type: \"payment-error\",\n        response: this.createHTTPResponse(errorResponse, false, paywallConfig),\n      };\n    }\n  }\n\n  /**\n   * Process settlement after successful response\n   *\n   * @param paymentPayload - The verified payment payload\n   * @param requirements - The matching payment requirements\n   * @returns ProcessSettleResultResponse - SettleResponse with headers if success or errorReason if failure\n   */\n  async processSettlement(\n    paymentPayload: PaymentPayload,\n    requirements: PaymentRequirements,\n  ): Promise<ProcessSettleResultResponse> {\n    try {\n      const settleResponse = await this.ResourceServer.settlePayment(paymentPayload, requirements);\n\n      if (!settleResponse.success) {\n        return {\n          ...settleResponse,\n          success: false,\n          errorReason: settleResponse.errorReason || \"Settlement failed\",\n        };\n      }\n\n      return {\n        ...settleResponse,\n        success: true,\n        headers: this.createSettlementHeaders(settleResponse),\n        requirements,\n      };\n    } catch (error) {\n      if (error instanceof SettleError) {\n        return {\n          success: false,\n          errorReason: error.errorReason || error.message,\n          payer: error.payer,\n          network: error.network,\n          transaction: error.transaction,\n        };\n      }\n      return {\n        success: false,\n        errorReason: error instanceof Error ? error.message : \"Settlement failed\",\n        network: requirements.network as Network,\n        transaction: \"\",\n      };\n    }\n  }\n\n  /**\n   * Check if a request requires payment based on route configuration\n   *\n   * @param context - HTTP request context\n   * @returns True if the route requires payment, false otherwise\n   */\n  requiresPayment(context: HTTPRequestContext): boolean {\n    const routeConfig = this.getRouteConfig(context.path, context.method);\n    return routeConfig !== undefined;\n  }\n\n  /**\n   * Normalizes a RouteConfig's accepts field into an array of PaymentOptions\n   * Handles both single PaymentOption and array formats\n   *\n   * @param routeConfig - Route configuration\n   * @returns Array of payment options\n   */\n  private normalizePaymentOptions(routeConfig: RouteConfig): PaymentOption[] {\n    return Array.isArray(routeConfig.accepts) ? routeConfig.accepts : [routeConfig.accepts];\n  }\n\n  /**\n   * Validates that all payment options in routes have corresponding registered schemes\n   * and facilitator support.\n   *\n   * @returns Array of validation errors (empty if all routes are valid)\n   */\n  private validateRouteConfiguration(): RouteValidationError[] {\n    const errors: RouteValidationError[] = [];\n\n    // Normalize routes to array of [pattern, config] pairs\n    const normalizedRoutes =\n      typeof this.routesConfig === \"object\" && !(\"accepts\" in this.routesConfig)\n        ? Object.entries(this.routesConfig as Record<string, RouteConfig>)\n        : [[\"*\", this.routesConfig as RouteConfig] as [string, RouteConfig]];\n\n    for (const [pattern, config] of normalizedRoutes) {\n      const paymentOptions = this.normalizePaymentOptions(config);\n\n      for (const option of paymentOptions) {\n        // Check 1: Is scheme registered?\n        if (!this.ResourceServer.hasRegisteredScheme(option.network, option.scheme)) {\n          errors.push({\n            routePattern: pattern,\n            scheme: option.scheme,\n            network: option.network,\n            reason: \"missing_scheme\",\n            message: `Route \"${pattern}\": No scheme implementation registered for \"${option.scheme}\" on network \"${option.network}\"`,\n          });\n          // Skip facilitator check if scheme isn't registered\n          continue;\n        }\n\n        // Check 2: Does facilitator support this scheme/network combination?\n        const supportedKind = this.ResourceServer.getSupportedKind(\n          x402Version,\n          option.network,\n          option.scheme,\n        );\n\n        if (!supportedKind) {\n          errors.push({\n            routePattern: pattern,\n            scheme: option.scheme,\n            network: option.network,\n            reason: \"missing_facilitator\",\n            message: `Route \"${pattern}\": Facilitator does not support scheme \"${option.scheme}\" on network \"${option.network}\"`,\n          });\n        }\n      }\n    }\n\n    return errors;\n  }\n\n  /**\n   * Get route configuration for a request\n   *\n   * @param path - Request path\n   * @param method - HTTP method\n   * @returns Route configuration or undefined if no match\n   */\n  private getRouteConfig(path: string, method: string): RouteConfig | undefined {\n    const normalizedPath = this.normalizePath(path);\n    const upperMethod = method.toUpperCase();\n\n    const matchingRoute = this.compiledRoutes.find(\n      route =>\n        route.regex.test(normalizedPath) && (route.verb === \"*\" || route.verb === upperMethod),\n    );\n\n    return matchingRoute?.config;\n  }\n\n  /**\n   * Extract payment from HTTP headers (handles v1 and v2)\n   *\n   * @param adapter - HTTP adapter\n   * @returns Decoded payment payload or null\n   */\n  private extractPayment(adapter: HTTPAdapter): PaymentPayload | null {\n    // Check v2 header first (PAYMENT-SIGNATURE)\n    const header = adapter.getHeader(\"payment-signature\") || adapter.getHeader(\"PAYMENT-SIGNATURE\");\n\n    if (header) {\n      try {\n        return decodePaymentSignatureHeader(header);\n      } catch (error) {\n        console.warn(\"Failed to decode PAYMENT-SIGNATURE header:\", error);\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Check if request is from a web browser\n   *\n   * @param adapter - HTTP adapter\n   * @returns True if request appears to be from a browser\n   */\n  private isWebBrowser(adapter: HTTPAdapter): boolean {\n    const accept = adapter.getAcceptHeader();\n    const userAgent = adapter.getUserAgent();\n    return accept.includes(\"text/html\") && userAgent.includes(\"Mozilla\");\n  }\n\n  /**\n   * Create HTTP response instructions from payment required\n   *\n   * @param paymentRequired - Payment requirements\n   * @param isWebBrowser - Whether request is from browser\n   * @param paywallConfig - Paywall configuration\n   * @param customHtml - Custom HTML template\n   * @param unpaidResponse - Optional custom response (content type and body) for unpaid API requests\n   * @returns Response instructions\n   */\n  private createHTTPResponse(\n    paymentRequired: PaymentRequired,\n    isWebBrowser: boolean,\n    paywallConfig?: PaywallConfig,\n    customHtml?: string,\n    unpaidResponse?: UnpaidResponseResult,\n  ): HTTPResponseInstructions {\n    if (isWebBrowser) {\n      const html = this.generatePaywallHTML(paymentRequired, paywallConfig, customHtml);\n      return {\n        status: 402,\n        headers: { \"Content-Type\": \"text/html\" },\n        body: html,\n        isHtml: true,\n      };\n    }\n\n    const response = this.createHTTPPaymentRequiredResponse(paymentRequired);\n\n    // Use callback result if provided, otherwise default to JSON with empty object\n    const contentType = unpaidResponse ? unpaidResponse.contentType : \"application/json\";\n    const body = unpaidResponse ? unpaidResponse.body : {};\n\n    return {\n      status: 402,\n      headers: {\n        \"Content-Type\": contentType,\n        ...response.headers,\n      },\n      body,\n    };\n  }\n\n  /**\n   * Create HTTP payment required response (v1 puts in body, v2 puts in header)\n   *\n   * @param paymentRequired - Payment required object\n   * @returns Headers and body for the HTTP response\n   */\n  private createHTTPPaymentRequiredResponse(paymentRequired: PaymentRequired): {\n    headers: Record<string, string>;\n  } {\n    return {\n      headers: {\n        \"PAYMENT-REQUIRED\": encodePaymentRequiredHeader(paymentRequired),\n      },\n    };\n  }\n\n  /**\n   * Create settlement response headers\n   *\n   * @param settleResponse - Settlement response\n   * @returns Headers to add to response\n   */\n  private createSettlementHeaders(settleResponse: SettleResponse): Record<string, string> {\n    const encoded = encodePaymentResponseHeader(settleResponse);\n    return { \"PAYMENT-RESPONSE\": encoded };\n  }\n\n  /**\n   * Parse route pattern into verb and regex\n   *\n   * @param pattern - Route pattern like \"GET /api/*\" or \"/api/[id]\"\n   * @returns Parsed pattern with verb and regex\n   */\n  private parseRoutePattern(pattern: string): { verb: string; regex: RegExp } {\n    const [verb, path] = pattern.includes(\" \") ? pattern.split(/\\s+/) : [\"*\", pattern];\n\n    const regex = new RegExp(\n      `^${\n        path\n          .replace(/[$()+.?^{|}]/g, \"\\\\$&\") // Escape regex special chars\n          .replace(/\\*/g, \".*?\") // Wildcards\n          .replace(/\\[([^\\]]+)\\]/g, \"[^/]+\") // Parameters\n          .replace(/\\//g, \"\\\\/\") // Escape slashes\n      }$`,\n      \"i\",\n    );\n\n    return { verb: verb.toUpperCase(), regex };\n  }\n\n  /**\n   * Normalize path for matching\n   *\n   * @param path - Raw path from request\n   * @returns Normalized path\n   */\n  private normalizePath(path: string): string {\n    try {\n      const pathWithoutQuery = path.split(/[?#]/)[0];\n      const decodedPath = decodeURIComponent(pathWithoutQuery);\n      return decodedPath\n        .replace(/\\\\/g, \"/\")\n        .replace(/\\/+/g, \"/\")\n        .replace(/(.+?)\\/+$/, \"$1\");\n    } catch {\n      return path;\n    }\n  }\n\n  /**\n   * Generate paywall HTML for browser requests\n   *\n   * @param paymentRequired - Payment required response\n   * @param paywallConfig - Optional paywall configuration\n   * @param customHtml - Optional custom HTML template\n   * @returns HTML string\n   */\n  private generatePaywallHTML(\n    paymentRequired: PaymentRequired,\n    paywallConfig?: PaywallConfig,\n    customHtml?: string,\n  ): string {\n    if (customHtml) {\n      return customHtml;\n    }\n\n    // Use custom paywall provider if set\n    if (this.paywallProvider) {\n      return this.paywallProvider.generateHtml(paymentRequired, paywallConfig);\n    }\n\n    // Try to use @x402/paywall if available (optional dependency)\n    try {\n      // eslint-disable-next-line @typescript-eslint/no-require-imports\n      const paywall = require(\"@x402/paywall\");\n      const displayAmount = this.getDisplayAmount(paymentRequired);\n      const resource = paymentRequired.resource;\n\n      return paywall.getPaywallHtml({\n        amount: displayAmount,\n        paymentRequired,\n        currentUrl: resource?.url || paywallConfig?.currentUrl || \"\",\n        testnet: paywallConfig?.testnet ?? true,\n        appName: paywallConfig?.appName,\n        appLogo: paywallConfig?.appLogo,\n        sessionTokenEndpoint: paywallConfig?.sessionTokenEndpoint,\n      });\n    } catch {\n      // @x402/paywall not installed, fall back to basic HTML\n    }\n\n    // Fallback: Basic HTML paywall\n    const resource = paymentRequired.resource;\n    const displayAmount = this.getDisplayAmount(paymentRequired);\n\n    return `\n      <!DOCTYPE html>\n      <html>\n        <head>\n          <title>Payment Required</title>\n          <meta charset=\"UTF-8\">\n          <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n        </head>\n        <body>\n          <div style=\"max-width: 600px; margin: 50px auto; padding: 20px; font-family: system-ui, -apple-system, sans-serif;\">\n            ${paywallConfig?.appLogo ? `<img src=\"${paywallConfig.appLogo}\" alt=\"${paywallConfig.appName || \"App\"}\" style=\"max-width: 200px; margin-bottom: 20px;\">` : \"\"}\n            <h1>Payment Required</h1>\n            ${resource ? `<p><strong>Resource:</strong> ${resource.description || resource.url}</p>` : \"\"}\n            <p><strong>Amount:</strong> $${displayAmount.toFixed(2)} USDC</p>\n            <div id=\"payment-widget\" \n                 data-requirements='${JSON.stringify(paymentRequired)}'\n                 data-app-name=\"${paywallConfig?.appName || \"\"}\"\n                 data-testnet=\"${paywallConfig?.testnet || false}\">\n              <!-- Install @x402/paywall for full wallet integration -->\n              <p style=\"margin-top: 2rem; padding: 1rem; background: #fef3c7; border-radius: 0.5rem;\">\n                <strong>Note:</strong> Install <code>@x402/paywall</code> for full wallet connection and payment UI.\n              </p>\n            </div>\n          </div>\n        </body>\n      </html>\n    `;\n  }\n\n  /**\n   * Extract display amount from payment requirements.\n   *\n   * @param paymentRequired - The payment required object\n   * @returns The display amount in decimal format\n   */\n  private getDisplayAmount(paymentRequired: PaymentRequired): number {\n    const accepts = paymentRequired.accepts;\n    if (accepts && accepts.length > 0) {\n      const firstReq = accepts[0];\n      if (\"amount\" in firstReq) {\n        // V2 format\n        return parseFloat(firstReq.amount) / 1000000; // Assuming USDC with 6 decimals\n      }\n    }\n    return 0;\n  }\n}\n","import {\n  decodePaymentRequiredHeader,\n  decodePaymentResponseHeader,\n  encodePaymentSignatureHeader,\n} from \".\";\nimport { SettleResponse } from \"../types\";\nimport { PaymentPayload, PaymentRequired } from \"../types/payments\";\nimport { x402Client } from \"../client/x402Client\";\n\n/**\n * HTTP-specific client for handling x402 payment protocol over HTTP.\n *\n * Wraps a x402Client to provide HTTP-specific encoding/decoding functionality\n * for payment headers and responses while maintaining the builder pattern.\n */\nexport class x402HTTPClient {\n  /**\n   * Creates a new x402HTTPClient instance.\n   *\n   * @param client - The underlying x402Client for payment logic\n   */\n  constructor(private readonly client: x402Client) {}\n\n  /**\n   * Encodes a payment payload into appropriate HTTP headers based on version.\n   *\n   * @param paymentPayload - The payment payload to encode\n   * @returns HTTP headers containing the encoded payment signature\n   */\n  encodePaymentSignatureHeader(paymentPayload: PaymentPayload): Record<string, string> {\n    switch (paymentPayload.x402Version) {\n      case 2:\n        return {\n          \"PAYMENT-SIGNATURE\": encodePaymentSignatureHeader(paymentPayload),\n        };\n      case 1:\n        return {\n          \"X-PAYMENT\": encodePaymentSignatureHeader(paymentPayload),\n        };\n      default:\n        throw new Error(\n          `Unsupported x402 version: ${(paymentPayload as PaymentPayload).x402Version}`,\n        );\n    }\n  }\n\n  /**\n   * Extracts payment required information from HTTP response.\n   *\n   * @param getHeader - Function to retrieve header value by name (case-insensitive)\n   * @param body - Optional response body for v1 compatibility\n   * @returns The payment required object\n   */\n  getPaymentRequiredResponse(\n    getHeader: (name: string) => string | null | undefined,\n    body?: unknown,\n  ): PaymentRequired {\n    // v2\n    const paymentRequired = getHeader(\"PAYMENT-REQUIRED\");\n    if (paymentRequired) {\n      return decodePaymentRequiredHeader(paymentRequired);\n    }\n\n    // v1\n    if (\n      body &&\n      body instanceof Object &&\n      \"x402Version\" in body &&\n      (body as PaymentRequired).x402Version === 1\n    ) {\n      return body as PaymentRequired;\n    }\n\n    throw new Error(\"Invalid payment required response\");\n  }\n\n  /**\n   * Extracts payment settlement response from HTTP headers.\n   *\n   * @param getHeader - Function to retrieve header value by name (case-insensitive)\n   * @returns The settlement response object\n   */\n  getPaymentSettleResponse(getHeader: (name: string) => string | null | undefined): SettleResponse {\n    // v2\n    const paymentResponse = getHeader(\"PAYMENT-RESPONSE\");\n    if (paymentResponse) {\n      return decodePaymentResponseHeader(paymentResponse);\n    }\n\n    // v1\n    const xPaymentResponse = getHeader(\"X-PAYMENT-RESPONSE\");\n    if (xPaymentResponse) {\n      return decodePaymentResponseHeader(xPaymentResponse);\n    }\n\n    throw new Error(\"Payment response header not found\");\n  }\n\n  /**\n   * Creates a payment payload for the given payment requirements.\n   * Delegates to the underlying x402Client.\n   *\n   * @param paymentRequired - The payment required response from the server\n   * @returns Promise resolving to the payment payload\n   */\n  async createPaymentPayload(paymentRequired: PaymentRequired): Promise<PaymentPayload> {\n    return this.client.createPaymentPayload(paymentRequired);\n  }\n}\n","import { SettleResponse } from \"../types\";\nimport { PaymentPayload, PaymentRequired } from \"../types/payments\";\nimport { Base64EncodedRegex, safeBase64Decode, safeBase64Encode } from \"../utils\";\n\n// HTTP Methods that typically use query parameters\nexport type QueryParamMethods = \"GET\" | \"HEAD\" | \"DELETE\";\n\n// HTTP Methods that typically use request body\nexport type BodyMethods = \"POST\" | \"PUT\" | \"PATCH\";\n\n/**\n * Encodes a payment payload as a base64 header value.\n *\n * @param paymentPayload - The payment payload to encode\n * @returns Base64 encoded string representation of the payment payload\n */\nexport function encodePaymentSignatureHeader(paymentPayload: PaymentPayload): string {\n  return safeBase64Encode(JSON.stringify(paymentPayload));\n}\n\n/**\n * Decodes a base64 payment signature header into a payment payload.\n *\n * @param paymentSignatureHeader - The base64 encoded payment signature header\n * @returns The decoded payment payload\n */\nexport function decodePaymentSignatureHeader(paymentSignatureHeader: string): PaymentPayload {\n  if (!Base64EncodedRegex.test(paymentSignatureHeader)) {\n    throw new Error(\"Invalid payment signature header\");\n  }\n  return JSON.parse(safeBase64Decode(paymentSignatureHeader)) as PaymentPayload;\n}\n\n/**\n * Encodes a payment required object as a base64 header value.\n *\n * @param paymentRequired - The payment required object to encode\n * @returns Base64 encoded string representation of the payment required object\n */\nexport function encodePaymentRequiredHeader(paymentRequired: PaymentRequired): string {\n  return safeBase64Encode(JSON.stringify(paymentRequired));\n}\n\n/**\n * Decodes a base64 payment required header into a payment required object.\n *\n * @param paymentRequiredHeader - The base64 encoded payment required header\n * @returns The decoded payment required object\n */\nexport function decodePaymentRequiredHeader(paymentRequiredHeader: string): PaymentRequired {\n  if (!Base64EncodedRegex.test(paymentRequiredHeader)) {\n    throw new Error(\"Invalid payment required header\");\n  }\n  return JSON.parse(safeBase64Decode(paymentRequiredHeader)) as PaymentRequired;\n}\n\n/**\n * Encodes a payment response as a base64 header value.\n *\n * @param paymentResponse - The payment response to encode\n * @returns Base64 encoded string representation of the payment response\n */\nexport function encodePaymentResponseHeader(paymentResponse: SettleResponse): string {\n  return safeBase64Encode(JSON.stringify(paymentResponse));\n}\n\n/**\n * Decodes a base64 payment response header into a settle response.\n *\n * @param paymentResponseHeader - The base64 encoded payment response header\n * @returns The decoded settle response\n */\nexport function decodePaymentResponseHeader(paymentResponseHeader: string): SettleResponse {\n  if (!Base64EncodedRegex.test(paymentResponseHeader)) {\n    throw new Error(\"Invalid payment response header\");\n  }\n  return JSON.parse(safeBase64Decode(paymentResponseHeader)) as SettleResponse;\n}\n\n// Export HTTP service and types\nexport {\n  x402HTTPResourceServer,\n  HTTPAdapter,\n  HTTPRequestContext,\n  HTTPResponseInstructions,\n  HTTPProcessResult,\n  PaywallConfig,\n  PaywallProvider,\n  PaymentOption,\n  RouteConfig,\n  RoutesConfig,\n  CompiledRoute,\n  DynamicPayTo,\n  DynamicPrice,\n  UnpaidResponseBody,\n  UnpaidResponseResult,\n  ProcessSettleResultResponse,\n  ProcessSettleSuccessResponse,\n  ProcessSettleFailureResponse,\n  RouteValidationError,\n  RouteConfigurationError,\n} from \"./x402HTTPResourceServer\";\nexport {\n  HTTPFacilitatorClient,\n  FacilitatorClient,\n  FacilitatorConfig,\n} from \"./httpFacilitatorClient\";\nexport { x402HTTPClient } from \"./x402HTTPClient\";\n","export const x402Version = 2;\n","import { x402Version } from \"..\";\nimport { SchemeNetworkClient } from \"../types/mechanisms\";\nimport { PaymentPayload, PaymentRequirements } from \"../types/payments\";\nimport { Network, PaymentRequired } from \"../types\";\nimport { findByNetworkAndScheme, findSchemesByNetwork } from \"../utils\";\n\n/**\n * Client Hook Context Interfaces\n */\n\nexport interface PaymentCreationContext {\n  paymentRequired: PaymentRequired;\n  selectedRequirements: PaymentRequirements;\n}\n\nexport interface PaymentCreatedContext extends PaymentCreationContext {\n  paymentPayload: PaymentPayload;\n}\n\nexport interface PaymentCreationFailureContext extends PaymentCreationContext {\n  error: Error;\n}\n\n/**\n * Client Hook Type Definitions\n */\n\nexport type BeforePaymentCreationHook = (\n  context: PaymentCreationContext,\n) => Promise<void | { abort: true; reason: string }>;\n\nexport type AfterPaymentCreationHook = (context: PaymentCreatedContext) => Promise<void>;\n\nexport type OnPaymentCreationFailureHook = (\n  context: PaymentCreationFailureContext,\n) => Promise<void | { recovered: true; payload: PaymentPayload }>;\n\nexport type SelectPaymentRequirements = (x402Version: number, paymentRequirements: PaymentRequirements[]) => PaymentRequirements;\n\n/**\n * A policy function that filters or transforms payment requirements.\n * Policies are applied in order before the selector chooses the final option.\n *\n * @param x402Version - The x402 protocol version\n * @param paymentRequirements - Array of payment requirements to filter/transform\n * @returns Filtered array of payment requirements\n */\nexport type PaymentPolicy = (x402Version: number, paymentRequirements: PaymentRequirements[]) => PaymentRequirements[];\n\n\n/**\n * Configuration for registering a payment scheme with a specific network\n */\nexport interface SchemeRegistration {\n  /**\n   * The network identifier (e.g., 'eip155:8453', 'solana:mainnet')\n   */\n  network: Network;\n\n  /**\n   * The scheme client implementation for this network\n   */\n  client: SchemeNetworkClient;\n\n  /**\n   * The x402 protocol version to use for this scheme\n   *\n   * @default 2\n   */\n  x402Version?: number;\n}\n\n/**\n * Configuration options for the fetch wrapper\n */\nexport interface x402ClientConfig {\n  /**\n   * Array of scheme registrations defining which payment methods are supported\n   */\n  schemes: SchemeRegistration[];\n\n  /**\n   * Policies to apply to the client\n   */\n  policies?: PaymentPolicy[];\n\n  /**\n   * Custom payment requirements selector function\n   * If not provided, uses the default selector (first available option)\n   */\n  paymentRequirementsSelector?: SelectPaymentRequirements;\n}\n\n/**\n * Core client for managing x402 payment schemes and creating payment payloads.\n *\n * Handles registration of payment schemes, policy-based filtering of payment requirements,\n * and creation of payment payloads based on server requirements.\n */\nexport class x402Client {\n  private readonly paymentRequirementsSelector: SelectPaymentRequirements;\n  private readonly registeredClientSchemes: Map<number, Map<string, Map<string, SchemeNetworkClient>>> = new Map();\n  private readonly policies: PaymentPolicy[] = [];\n\n  private beforePaymentCreationHooks: BeforePaymentCreationHook[] = [];\n  private afterPaymentCreationHooks: AfterPaymentCreationHook[] = [];\n  private onPaymentCreationFailureHooks: OnPaymentCreationFailureHook[] = [];\n\n  /**\n   * Creates a new x402Client instance.\n   *\n   * @param paymentRequirementsSelector - Function to select payment requirements from available options\n   */\n  constructor(paymentRequirementsSelector?: SelectPaymentRequirements) {\n    this.paymentRequirementsSelector = paymentRequirementsSelector || ((x402Version, accepts) => accepts[0]);\n  }\n\n  /**\n   * Creates a new x402Client instance from a configuration object.\n   *\n   * @param config - The client configuration including schemes, policies, and payment requirements selector\n   * @returns A configured x402Client instance\n   */\n  static fromConfig(config: x402ClientConfig): x402Client {\n    const client = new x402Client(config.paymentRequirementsSelector);\n    config.schemes.forEach(scheme => {\n      if (scheme.x402Version === 1) {\n        client.registerV1(scheme.network, scheme.client);\n      } else {\n        client.register(scheme.network, scheme.client);\n      }\n    });\n    config.policies?.forEach(policy => {\n      client.registerPolicy(policy);\n    });\n    return client;\n  }\n\n  /**\n   * Registers a scheme client for the current x402 version.\n   *\n   * @param network - The network to register the client for\n   * @param client - The scheme network client to register\n   * @returns The x402Client instance for chaining\n   */\n  register(network: Network, client: SchemeNetworkClient): x402Client {\n    return this._registerScheme(x402Version, network, client);\n  }\n\n  /**\n   * Registers a scheme client for x402 version 1.\n   *\n   * @param network - The v1 network identifier (e.g., 'base-sepolia', 'solana-devnet')\n   * @param client - The scheme network client to register\n   * @returns The x402Client instance for chaining\n   */\n  registerV1(network: string, client: SchemeNetworkClient): x402Client {\n    return this._registerScheme(1, network as Network, client);\n  }\n\n  /**\n   * Registers a policy to filter or transform payment requirements.\n   *\n   * Policies are applied in order after filtering by registered schemes\n   * and before the selector chooses the final payment requirement.\n   *\n   * @param policy - Function to filter/transform payment requirements\n   * @returns The x402Client instance for chaining\n   *\n   * @example\n   * ```typescript\n   * // Prefer cheaper options\n   * client.registerPolicy((version, reqs) =>\n   *   reqs.filter(r => BigInt(r.value) < BigInt('1000000'))\n   * );\n   *\n   * // Prefer specific networks\n   * client.registerPolicy((version, reqs) =>\n   *   reqs.filter(r => r.network.startsWith('eip155:'))\n   * );\n   * ```\n   */\n  registerPolicy(policy: PaymentPolicy): x402Client {\n    this.policies.push(policy);\n    return this;\n  }\n\n  /**\n   * Register a hook to execute before payment payload creation.\n   * Can abort creation by returning { abort: true, reason: string }\n   *\n   * @param hook - The hook function to register\n   * @returns The x402Client instance for chaining\n   */\n  onBeforePaymentCreation(hook: BeforePaymentCreationHook): x402Client {\n    this.beforePaymentCreationHooks.push(hook);\n    return this;\n  }\n\n  /**\n   * Register a hook to execute after successful payment payload creation.\n   *\n   * @param hook - The hook function to register\n   * @returns The x402Client instance for chaining\n   */\n  onAfterPaymentCreation(hook: AfterPaymentCreationHook): x402Client {\n    this.afterPaymentCreationHooks.push(hook);\n    return this;\n  }\n\n  /**\n   * Register a hook to execute when payment payload creation fails.\n   * Can recover from failure by returning { recovered: true, payload: PaymentPayload }\n   *\n   * @param hook - The hook function to register\n   * @returns The x402Client instance for chaining\n   */\n  onPaymentCreationFailure(hook: OnPaymentCreationFailureHook): x402Client {\n    this.onPaymentCreationFailureHooks.push(hook);\n    return this;\n  }\n\n  /**\n   * Creates a payment payload based on a PaymentRequired response.\n   *\n   * Automatically extracts x402Version, resource, and extensions from the PaymentRequired\n   * response and constructs a complete PaymentPayload with the accepted requirements.\n   *\n   * @param paymentRequired - The PaymentRequired response from the server\n   * @returns Promise resolving to the complete payment payload\n   */\n  async createPaymentPayload(\n    paymentRequired: PaymentRequired,\n  ): Promise<PaymentPayload> {\n    const clientSchemesByNetwork = this.registeredClientSchemes.get(paymentRequired.x402Version);\n    if (!clientSchemesByNetwork) {\n      throw new Error(`No client registered for x402 version: ${paymentRequired.x402Version}`);\n    }\n\n    const requirements = this.selectPaymentRequirements(paymentRequired.x402Version, paymentRequired.accepts);\n\n    const context: PaymentCreationContext = {\n      paymentRequired,\n      selectedRequirements: requirements,\n    };\n\n    // Execute beforePaymentCreation hooks\n    for (const hook of this.beforePaymentCreationHooks) {\n      const result = await hook(context);\n      if (result && \"abort\" in result && result.abort) {\n        throw new Error(`Payment creation aborted: ${result.reason}`);\n      }\n    }\n\n    try {\n      const schemeNetworkClient = findByNetworkAndScheme(clientSchemesByNetwork, requirements.scheme, requirements.network);\n      if (!schemeNetworkClient) {\n        throw new Error(`No client registered for scheme: ${requirements.scheme} and network: ${requirements.network}`);\n      }\n\n      const partialPayload = await schemeNetworkClient.createPaymentPayload(paymentRequired.x402Version, requirements);\n\n      let paymentPayload: PaymentPayload;\n      if (partialPayload.x402Version == 1) {\n        paymentPayload = partialPayload as PaymentPayload;\n      } else {\n        paymentPayload = {\n          ...partialPayload,\n          extensions: paymentRequired.extensions,\n          resource: paymentRequired.resource,\n          accepted: requirements,\n        };\n      }\n\n      // Execute afterPaymentCreation hooks\n      const createdContext: PaymentCreatedContext = {\n        ...context,\n        paymentPayload,\n      };\n\n      for (const hook of this.afterPaymentCreationHooks) {\n        await hook(createdContext);\n      }\n\n      return paymentPayload;\n    } catch (error) {\n      const failureContext: PaymentCreationFailureContext = {\n        ...context,\n        error: error as Error,\n      };\n\n      // Execute onPaymentCreationFailure hooks\n      for (const hook of this.onPaymentCreationFailureHooks) {\n        const result = await hook(failureContext);\n        if (result && \"recovered\" in result && result.recovered) {\n          return result.payload;\n        }\n      }\n\n      throw error;\n    }\n  }\n\n\n\n  /**\n   * Selects appropriate payment requirements based on registered clients and policies.\n   *\n   * Selection process:\n   * 1. Filter by registered schemes (network + scheme support)\n   * 2. Apply all registered policies in order\n   * 3. Use selector to choose final requirement\n   *\n   * @param x402Version - The x402 protocol version\n   * @param paymentRequirements - Array of available payment requirements\n   * @returns The selected payment requirements\n   */\n  private selectPaymentRequirements(x402Version: number, paymentRequirements: PaymentRequirements[]): PaymentRequirements {\n    const clientSchemesByNetwork = this.registeredClientSchemes.get(x402Version);\n    if (!clientSchemesByNetwork) {\n      throw new Error(`No client registered for x402 version: ${x402Version}`);\n    }\n\n    // Step 1: Filter by registered schemes\n    const supportedPaymentRequirements = paymentRequirements.filter(requirement => {\n      let clientSchemes = findSchemesByNetwork(clientSchemesByNetwork, requirement.network);\n      if (!clientSchemes) {\n        return false;\n      }\n\n      return clientSchemes.has(requirement.scheme);\n    })\n\n    if (supportedPaymentRequirements.length === 0) {\n      throw new Error(`No network/scheme registered for x402 version: ${x402Version} which comply with the payment requirements. ${JSON.stringify({\n        x402Version,\n        paymentRequirements,\n        x402Versions: Array.from(this.registeredClientSchemes.keys()),\n        networks: Array.from(clientSchemesByNetwork.keys()),\n        schemes: Array.from(clientSchemesByNetwork.values()).map(schemes => Array.from(schemes.keys())).flat(),\n      })}`);\n    }\n\n    // Step 2: Apply all policies in order\n    let filteredRequirements = supportedPaymentRequirements;\n    for (const policy of this.policies) {\n      filteredRequirements = policy(x402Version, filteredRequirements);\n\n      if (filteredRequirements.length === 0) {\n        throw new Error(`All payment requirements were filtered out by policies for x402 version: ${x402Version}`);\n      }\n    }\n\n    // Step 3: Use selector to choose final requirement\n    return this.paymentRequirementsSelector(x402Version, filteredRequirements);\n  }\n\n  /**\n   * Internal method to register a scheme client.\n   *\n   * @param x402Version - The x402 protocol version\n   * @param network - The network to register the client for\n   * @param client - The scheme network client to register\n   * @returns The x402Client instance for chaining\n   */\n  private _registerScheme(x402Version: number, network: Network, client: SchemeNetworkClient): x402Client {\n    if (!this.registeredClientSchemes.has(x402Version)) {\n      this.registeredClientSchemes.set(x402Version, new Map());\n    }\n    const clientSchemesByNetwork = this.registeredClientSchemes.get(x402Version)!;\n    if (!clientSchemesByNetwork.has(network)) {\n      clientSchemesByNetwork.set(network, new Map());\n    }\n\n    const clientByScheme = clientSchemesByNetwork.get(network)!;\n    if (!clientByScheme.has(client.scheme)) {\n      clientByScheme.set(client.scheme, client);\n    }\n\n    return this;\n  }\n}\n","import { x402Client, x402ClientConfig, x402HTTPClient } from \"@x402/core/client\";\nimport { type PaymentRequired } from \"@x402/core/types\";\n\n/**\n * Enables the payment of APIs using the x402 payment protocol v2.\n *\n * This function wraps the native fetch API to automatically handle 402 Payment Required responses\n * by creating and sending payment headers. It will:\n * 1. Make the initial request\n * 2. If a 402 response is received, parse the payment requirements\n * 3. Create a payment header using the configured x402HTTPClient\n * 4. Retry the request with the payment header\n *\n * @param fetch - The fetch function to wrap (typically globalThis.fetch)\n * @param client - Configured x402Client or x402HTTPClient instance for handling payments\n * @returns A wrapped fetch function that handles 402 responses automatically\n *\n * @example\n * ```typescript\n * import { wrapFetchWithPayment, x402Client } from '@x402/fetch';\n * import { ExactEvmScheme } from '@x402/evm';\n * import { ExactSvmScheme } from '@x402/svm';\n *\n * const client = new x402Client()\n *   .register('eip155:8453', new ExactEvmScheme(evmSigner))\n *   .register('solana:mainnet', new ExactSvmScheme(svmSigner))\n *   .register('eip155:1', new ExactEvmScheme(evmSigner), 1); // v1 protocol\n *\n * const fetchWithPay = wrapFetchWithPayment(fetch, client);\n *\n * // Make a request that may require payment\n * const response = await fetchWithPay('https://api.example.com/paid-endpoint');\n * ```\n *\n * @throws {Error} If no schemes are provided\n * @throws {Error} If the request configuration is missing\n * @throws {Error} If a payment has already been attempted for this request\n * @throws {Error} If there's an error creating the payment header\n */\nexport function wrapFetchWithPayment(\n  fetch: typeof globalThis.fetch,\n  client: x402Client | x402HTTPClient,\n) {\n  const httpClient = client instanceof x402HTTPClient ? client : new x402HTTPClient(client);\n\n  return async (input: RequestInfo | URL, init?: RequestInit) => {\n    const request = new Request(input, init);\n    const clonedRequest = request.clone();\n\n    const response = await fetch(request);\n\n    if (response.status !== 402) {\n      return response;\n    }\n\n    // Parse payment requirements from response\n    let paymentRequired: PaymentRequired;\n    try {\n      // Create getHeader function for case-insensitive header lookup\n      const getHeader = (name: string) => response.headers.get(name);\n\n      // Try to get from headers first (v2), then from body (v1)\n      let body: PaymentRequired | undefined;\n      try {\n        const responseText = await response.text();\n        if (responseText) {\n          body = JSON.parse(responseText) as PaymentRequired;\n        }\n      } catch {\n        // Ignore JSON parse errors - might be header-only response\n      }\n\n      paymentRequired = httpClient.getPaymentRequiredResponse(getHeader, body);\n    } catch (error) {\n      throw new Error(\n        `Failed to parse payment requirements: ${error instanceof Error ? error.message : \"Unknown error\"}`,\n      );\n    }\n\n    // Create payment payload (copy extensions from PaymentRequired)\n    let paymentPayload;\n    try {\n      paymentPayload = await client.createPaymentPayload(paymentRequired);\n    } catch (error) {\n      throw new Error(\n        `Failed to create payment payload: ${error instanceof Error ? error.message : \"Unknown error\"}`,\n      );\n    }\n\n    // Encode payment header\n    const paymentHeaders = httpClient.encodePaymentSignatureHeader(paymentPayload);\n\n    // Check if this is already a retry to prevent infinite loops\n    if (clonedRequest.headers.has(\"PAYMENT-SIGNATURE\") || clonedRequest.headers.has(\"X-PAYMENT\")) {\n      throw new Error(\"Payment already attempted\");\n    }\n\n    // Add payment headers to cloned request\n    for (const [key, value] of Object.entries(paymentHeaders)) {\n      clonedRequest.headers.set(key, value);\n    }\n    clonedRequest.headers.set(\n      \"Access-Control-Expose-Headers\",\n      \"PAYMENT-RESPONSE,X-PAYMENT-RESPONSE\",\n    );\n\n    // Retry the request with payment\n    const secondResponse = await fetch(clonedRequest);\n    return secondResponse;\n  };\n}\n\n/**\n * Creates a payment-enabled fetch function from a configuration object.\n *\n * @param fetch - The fetch function to wrap (typically globalThis.fetch)\n * @param config - Configuration options including scheme registrations and selectors\n * @returns A wrapped fetch function that handles 402 responses automatically\n */\nexport function wrapFetchWithPaymentFromConfig(\n  fetch: typeof globalThis.fetch,\n  config: x402ClientConfig,\n) {\n  const client = x402Client.fromConfig(config);\n  return wrapFetchWithPayment(fetch, client);\n}\n\n// Re-export types and utilities for convenience\nexport { x402Client, x402HTTPClient } from \"@x402/core/client\";\nexport type {\n  PaymentPolicy,\n  SchemeRegistration,\n  SelectPaymentRequirements,\n  x402ClientConfig,\n} from \"@x402/core/client\";\nexport { decodePaymentResponseHeader } from \"@x402/core/http\";\nexport type {\n  Network,\n  PaymentPayload,\n  PaymentRequired,\n  PaymentRequirements,\n  SchemeNetworkClient,\n} from \"@x402/core/types\";\n"],"names":["findSchemesByNetwork","Error","map","network","implementationsByScheme","get","registeredNetworkPattern","implementations","entries","pattern","replace","RegExp","concat","test","Base64EncodedRegex","safeBase64Decode","data","globalThis","atob","binaryString","bytes","Uint8Array","length","i","charCodeAt","TextDecoder","decode","Buffer","from","toString","x402HTTPClient","constructor","client","encodePaymentSignatureHeader","paymentPayload","x402Version","getPaymentRequiredResponse","getHeader","body","paymentRequired","paymentRequiredHeader","JSON","parse","decodePaymentRequiredHeader","Object","getPaymentSettleResponse","paymentResponse","decodePaymentResponseHeader","xPaymentResponse","createPaymentPayload","this","btoa","TextEncoder","encode","Array","byte","String","fromCharCode","join","safeBase64Encode","stringify","paymentResponseHeader","x402Client","_x402Client","paymentRequirementsSelector","registeredClientSchemes","Map","policies","beforePaymentCreationHooks","afterPaymentCreationHooks","onPaymentCreationFailureHooks","x402Version2","accepts","fromConfig","config","_config$policies","schemes","forEach","scheme","registerV1","register","policy","registerPolicy","_registerScheme","push","onBeforePaymentCreation","hook","onAfterPaymentCreation","onPaymentCreationFailure","clientSchemesByNetwork","requirements","selectPaymentRequirements","context","selectedRequirements","result","abort","reason","schemeNetworkClient","findByNetworkAndScheme","_findSchemesByNetwork","partialPayload","_objectSpread","extensions","resource","accepted","createdContext","error","failureContext","recovered","payload","paymentRequirements","supportedPaymentRequirements","filter","requirement","clientSchemes","has","x402Versions","keys","networks","values","flat","filteredRequirements","set","clientByScheme","wrapFetchWithPayment","fetch","httpClient","async","input","init","request","Request","clonedRequest","clone","response","status","name","headers","responseText","text","_unused","message","paymentHeaders","key","value"],"ignoreList":[],"sourceRoot":""}