{"version":3,"file":"static/js/206.adbfd12d.chunk.js","mappings":"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","sources":["../node_modules/@x402/evm/node_modules/viem/errors/version.ts","../node_modules/@x402/evm/node_modules/viem/errors/base.ts","../node_modules/@x402/evm/node_modules/viem/errors/encoding.ts","../node_modules/@x402/evm/node_modules/viem/errors/data.ts","../node_modules/@x402/evm/node_modules/viem/utils/data/pad.ts","../node_modules/@x402/evm/node_modules/viem/utils/data/isHex.ts","../node_modules/@x402/evm/node_modules/viem/utils/data/size.ts","../node_modules/@x402/evm/node_modules/viem/utils/encoding/fromHex.ts","../node_modules/@x402/evm/node_modules/viem/utils/encoding/toHex.ts","../node_modules/@x402/evm/src/constants.ts","../node_modules/@x402/evm/src/utils.ts","../node_modules/@x402/evm/node_modules/viem/errors/address.ts","../node_modules/@x402/evm/node_modules/viem/utils/encoding/toBytes.ts","../node_modules/@x402/evm/node_modules/@noble/hashes/src/_u64.ts","../node_modules/@x402/evm/node_modules/@noble/hashes/src/utils.ts","../node_modules/@x402/evm/node_modules/@noble/hashes/src/sha3.ts","../node_modules/@x402/evm/node_modules/viem/utils/lru.ts","../node_modules/@x402/evm/node_modules/viem/utils/address/isAddress.ts","../node_modules/@x402/evm/node_modules/viem/utils/address/getAddress.ts","../node_modules/@x402/evm/node_modules/viem/utils/hash/keccak256.ts","../node_modules/@x402/evm/src/exact/client/scheme.ts","../node_modules/@x402/evm/src/v1/index.ts","../node_modules/@x402/evm/src/exact/v1/client/scheme.ts","../node_modules/@x402/evm/src/exact/client/register.ts"],"sourcesContent":["export const version = '2.44.4'\n","import { version } from './version.js'\n\ntype ErrorConfig = {\n  getDocsUrl?: ((args: BaseErrorParameters) => string | undefined) | undefined\n  version?: string | undefined\n}\n\nlet errorConfig: ErrorConfig = {\n  getDocsUrl: ({\n    docsBaseUrl,\n    docsPath = '',\n    docsSlug,\n  }: BaseErrorParameters) =>\n    docsPath\n      ? `${docsBaseUrl ?? 'https://viem.sh'}${docsPath}${\n          docsSlug ? `#${docsSlug}` : ''\n        }`\n      : undefined,\n  version: `viem@${version}`,\n}\n\nexport function setErrorConfig(config: ErrorConfig) {\n  errorConfig = config\n}\n\ntype BaseErrorParameters = {\n  cause?: BaseError | Error | undefined\n  details?: string | undefined\n  docsBaseUrl?: string | undefined\n  docsPath?: string | undefined\n  docsSlug?: string | undefined\n  metaMessages?: string[] | undefined\n  name?: string | undefined\n}\n\nexport type BaseErrorType = BaseError & { name: 'BaseError' }\nexport class BaseError extends Error {\n  details: string\n  docsPath?: string | undefined\n  metaMessages?: string[] | undefined\n  shortMessage: string\n  version: string\n\n  override name = 'BaseError'\n\n  constructor(shortMessage: string, args: BaseErrorParameters = {}) {\n    const details = (() => {\n      if (args.cause instanceof BaseError) return args.cause.details\n      if (args.cause?.message) return args.cause.message\n      return args.details!\n    })()\n    const docsPath = (() => {\n      if (args.cause instanceof BaseError)\n        return args.cause.docsPath || args.docsPath\n      return args.docsPath\n    })()\n    const docsUrl = errorConfig.getDocsUrl?.({ ...args, docsPath })\n\n    const message = [\n      shortMessage || 'An error occurred.',\n      '',\n      ...(args.metaMessages ? [...args.metaMessages, ''] : []),\n      ...(docsUrl ? [`Docs: ${docsUrl}`] : []),\n      ...(details ? [`Details: ${details}`] : []),\n      ...(errorConfig.version ? [`Version: ${errorConfig.version}`] : []),\n    ].join('\\n')\n\n    super(message, args.cause ? { cause: args.cause } : undefined)\n\n    this.details = details\n    this.docsPath = docsPath\n    this.metaMessages = args.metaMessages\n    this.name = args.name ?? this.name\n    this.shortMessage = shortMessage\n    this.version = version\n  }\n\n  walk(): Error\n  walk(fn: (err: unknown) => boolean): Error | null\n  walk(fn?: any): any {\n    return walk(this, fn)\n  }\n}\n\nfunction walk(\n  err: unknown,\n  fn?: ((err: unknown) => boolean) | undefined,\n): unknown {\n  if (fn?.(err)) return err\n  if (\n    err &&\n    typeof err === 'object' &&\n    'cause' in err &&\n    err.cause !== undefined\n  )\n    return walk(err.cause, fn)\n  return fn ? null : err\n}\n","import type { ByteArray, Hex } from '../types/misc.js'\n\nimport { BaseError } from './base.js'\n\nexport type IntegerOutOfRangeErrorType = IntegerOutOfRangeError & {\n  name: 'IntegerOutOfRangeError'\n}\nexport class IntegerOutOfRangeError extends BaseError {\n  constructor({\n    max,\n    min,\n    signed,\n    size,\n    value,\n  }: {\n    max?: string | undefined\n    min: string\n    signed?: boolean | undefined\n    size?: number | undefined\n    value: string\n  }) {\n    super(\n      `Number \"${value}\" is not in safe ${\n        size ? `${size * 8}-bit ${signed ? 'signed' : 'unsigned'} ` : ''\n      }integer range ${max ? `(${min} to ${max})` : `(above ${min})`}`,\n      { name: 'IntegerOutOfRangeError' },\n    )\n  }\n}\n\nexport type InvalidBytesBooleanErrorType = InvalidBytesBooleanError & {\n  name: 'InvalidBytesBooleanError'\n}\nexport class InvalidBytesBooleanError extends BaseError {\n  constructor(bytes: ByteArray) {\n    super(\n      `Bytes value \"${bytes}\" is not a valid boolean. The bytes array must contain a single byte of either a 0 or 1 value.`,\n      {\n        name: 'InvalidBytesBooleanError',\n      },\n    )\n  }\n}\n\nexport type InvalidHexBooleanErrorType = InvalidHexBooleanError & {\n  name: 'InvalidHexBooleanError'\n}\nexport class InvalidHexBooleanError extends BaseError {\n  constructor(hex: Hex) {\n    super(\n      `Hex value \"${hex}\" is not a valid boolean. The hex value must be \"0x0\" (false) or \"0x1\" (true).`,\n      { name: 'InvalidHexBooleanError' },\n    )\n  }\n}\n\nexport type InvalidHexValueErrorType = InvalidHexValueError & {\n  name: 'InvalidHexValueError'\n}\nexport class InvalidHexValueError extends BaseError {\n  constructor(value: Hex) {\n    super(\n      `Hex value \"${value}\" is an odd length (${value.length}). It must be an even length.`,\n      { name: 'InvalidHexValueError' },\n    )\n  }\n}\n\nexport type SizeOverflowErrorType = SizeOverflowError & {\n  name: 'SizeOverflowError'\n}\nexport class SizeOverflowError extends BaseError {\n  constructor({ givenSize, maxSize }: { givenSize: number; maxSize: number }) {\n    super(\n      `Size cannot exceed ${maxSize} bytes. Given size: ${givenSize} bytes.`,\n      { name: 'SizeOverflowError' },\n    )\n  }\n}\n","import { BaseError } from './base.js'\n\nexport type SliceOffsetOutOfBoundsErrorType = SliceOffsetOutOfBoundsError & {\n  name: 'SliceOffsetOutOfBoundsError'\n}\nexport class SliceOffsetOutOfBoundsError extends BaseError {\n  constructor({\n    offset,\n    position,\n    size,\n  }: { offset: number; position: 'start' | 'end'; size: number }) {\n    super(\n      `Slice ${\n        position === 'start' ? 'starting' : 'ending'\n      } at offset \"${offset}\" is out-of-bounds (size: ${size}).`,\n      { name: 'SliceOffsetOutOfBoundsError' },\n    )\n  }\n}\n\nexport type SizeExceedsPaddingSizeErrorType = SizeExceedsPaddingSizeError & {\n  name: 'SizeExceedsPaddingSizeError'\n}\nexport class SizeExceedsPaddingSizeError extends BaseError {\n  constructor({\n    size,\n    targetSize,\n    type,\n  }: {\n    size: number\n    targetSize: number\n    type: 'hex' | 'bytes'\n  }) {\n    super(\n      `${type.charAt(0).toUpperCase()}${type\n        .slice(1)\n        .toLowerCase()} size (${size}) exceeds padding size (${targetSize}).`,\n      { name: 'SizeExceedsPaddingSizeError' },\n    )\n  }\n}\n\nexport type InvalidBytesLengthErrorType = InvalidBytesLengthError & {\n  name: 'InvalidBytesLengthError'\n}\nexport class InvalidBytesLengthError extends BaseError {\n  constructor({\n    size,\n    targetSize,\n    type,\n  }: {\n    size: number\n    targetSize: number\n    type: 'hex' | 'bytes'\n  }) {\n    super(\n      `${type.charAt(0).toUpperCase()}${type\n        .slice(1)\n        .toLowerCase()} is expected to be ${targetSize} ${type} long, but is ${size} ${type} long.`,\n      { name: 'InvalidBytesLengthError' },\n    )\n  }\n}\n","import {\n  SizeExceedsPaddingSizeError,\n  type SizeExceedsPaddingSizeErrorType,\n} from '../../errors/data.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\n\ntype PadOptions = {\n  dir?: 'left' | 'right' | undefined\n  size?: number | null | undefined\n}\nexport type PadReturnType<value extends ByteArray | Hex> = value extends Hex\n  ? Hex\n  : ByteArray\n\nexport type PadErrorType = PadHexErrorType | PadBytesErrorType | ErrorType\n\nexport function pad<value extends ByteArray | Hex>(\n  hexOrBytes: value,\n  { dir, size = 32 }: PadOptions = {},\n): PadReturnType<value> {\n  if (typeof hexOrBytes === 'string')\n    return padHex(hexOrBytes, { dir, size }) as PadReturnType<value>\n  return padBytes(hexOrBytes, { dir, size }) as PadReturnType<value>\n}\n\nexport type PadHexErrorType = SizeExceedsPaddingSizeErrorType | ErrorType\n\nexport function padHex(hex_: Hex, { dir, size = 32 }: PadOptions = {}) {\n  if (size === null) return hex_\n  const hex = hex_.replace('0x', '')\n  if (hex.length > size * 2)\n    throw new SizeExceedsPaddingSizeError({\n      size: Math.ceil(hex.length / 2),\n      targetSize: size,\n      type: 'hex',\n    })\n\n  return `0x${hex[dir === 'right' ? 'padEnd' : 'padStart'](\n    size * 2,\n    '0',\n  )}` as Hex\n}\n\nexport type PadBytesErrorType = SizeExceedsPaddingSizeErrorType | ErrorType\n\nexport function padBytes(\n  bytes: ByteArray,\n  { dir, size = 32 }: PadOptions = {},\n) {\n  if (size === null) return bytes\n  if (bytes.length > size)\n    throw new SizeExceedsPaddingSizeError({\n      size: bytes.length,\n      targetSize: size,\n      type: 'bytes',\n    })\n  const paddedBytes = new Uint8Array(size)\n  for (let i = 0; i < size; i++) {\n    const padEnd = dir === 'right'\n    paddedBytes[padEnd ? i : size - i - 1] =\n      bytes[padEnd ? i : bytes.length - i - 1]\n  }\n  return paddedBytes\n}\n","import type { ErrorType } from '../../errors/utils.js'\nimport type { Hex } from '../../types/misc.js'\n\nexport type IsHexErrorType = ErrorType\n\nexport function isHex(\n  value: unknown,\n  { strict = true }: { strict?: boolean | undefined } = {},\n): value is Hex {\n  if (!value) return false\n  if (typeof value !== 'string') return false\n  return strict ? /^0x[0-9a-fA-F]*$/.test(value) : value.startsWith('0x')\n}\n","import type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\n\nimport { type IsHexErrorType, isHex } from './isHex.js'\n\nexport type SizeErrorType = IsHexErrorType | ErrorType\n\n/**\n * @description Retrieves the size of the value (in bytes).\n *\n * @param value The value (hex or byte array) to retrieve the size of.\n * @returns The size of the value (in bytes).\n */\nexport function size(value: Hex | ByteArray) {\n  if (isHex(value, { strict: false })) return Math.ceil((value.length - 2) / 2)\n  return value.length\n}\n","import {\n  IntegerOutOfRangeError,\n  type IntegerOutOfRangeErrorType,\n  InvalidHexBooleanError,\n  type InvalidHexBooleanErrorType,\n  SizeOverflowError,\n  type SizeOverflowErrorType,\n} from '../../errors/encoding.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { type SizeErrorType, size as size_ } from '../data/size.js'\nimport { type TrimErrorType, trim } from '../data/trim.js'\n\nimport { type HexToBytesErrorType, hexToBytes } from './toBytes.js'\n\nexport type AssertSizeErrorType =\n  | SizeOverflowErrorType\n  | SizeErrorType\n  | ErrorType\n\nexport function assertSize(\n  hexOrBytes: Hex | ByteArray,\n  { size }: { size: number },\n): void {\n  if (size_(hexOrBytes) > size)\n    throw new SizeOverflowError({\n      givenSize: size_(hexOrBytes),\n      maxSize: size,\n    })\n}\n\nexport type FromHexParameters<\n  to extends 'string' | 'bigint' | 'number' | 'bytes' | 'boolean',\n> =\n  | to\n  | {\n      /** Size (in bytes) of the hex value. */\n      size?: number | undefined\n      /** Type to convert to. */\n      to: to\n    }\n\nexport type FromHexReturnType<to> = to extends 'string'\n  ? string\n  : to extends 'bigint'\n    ? bigint\n    : to extends 'number'\n      ? number\n      : to extends 'bytes'\n        ? ByteArray\n        : to extends 'boolean'\n          ? boolean\n          : never\n\nexport type FromHexErrorType =\n  | HexToNumberErrorType\n  | HexToBigIntErrorType\n  | HexToBoolErrorType\n  | HexToStringErrorType\n  | HexToBytesErrorType\n  | ErrorType\n\n/**\n * Decodes a hex string into a string, number, bigint, boolean, or byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/fromHex\n * - Example: https://viem.sh/docs/utilities/fromHex#usage\n *\n * @param hex Hex string to decode.\n * @param toOrOpts Type to convert to or options.\n * @returns Decoded value.\n *\n * @example\n * import { fromHex } from 'viem'\n * const data = fromHex('0x1a4', 'number')\n * // 420\n *\n * @example\n * import { fromHex } from 'viem'\n * const data = fromHex('0x48656c6c6f20576f726c6421', 'string')\n * // 'Hello world'\n *\n * @example\n * import { fromHex } from 'viem'\n * const data = fromHex('0x48656c6c6f20576f726c64210000000000000000000000000000000000000000', {\n *   size: 32,\n *   to: 'string'\n * })\n * // 'Hello world'\n */\nexport function fromHex<\n  to extends 'string' | 'bigint' | 'number' | 'bytes' | 'boolean',\n>(hex: Hex, toOrOpts: FromHexParameters<to>): FromHexReturnType<to> {\n  const opts = typeof toOrOpts === 'string' ? { to: toOrOpts } : toOrOpts\n  const to = opts.to\n\n  if (to === 'number') return hexToNumber(hex, opts) as FromHexReturnType<to>\n  if (to === 'bigint') return hexToBigInt(hex, opts) as FromHexReturnType<to>\n  if (to === 'string') return hexToString(hex, opts) as FromHexReturnType<to>\n  if (to === 'boolean') return hexToBool(hex, opts) as FromHexReturnType<to>\n  return hexToBytes(hex, opts) as FromHexReturnType<to>\n}\n\nexport type HexToBigIntOpts = {\n  /** Whether or not the number of a signed representation. */\n  signed?: boolean | undefined\n  /** Size (in bytes) of the hex value. */\n  size?: number | undefined\n}\n\nexport type HexToBigIntErrorType = AssertSizeErrorType | ErrorType\n\n/**\n * Decodes a hex value into a bigint.\n *\n * - Docs: https://viem.sh/docs/utilities/fromHex#hextobigint\n *\n * @param hex Hex value to decode.\n * @param opts Options.\n * @returns BigInt value.\n *\n * @example\n * import { hexToBigInt } from 'viem'\n * const data = hexToBigInt('0x1a4', { signed: true })\n * // 420n\n *\n * @example\n * import { hexToBigInt } from 'viem'\n * const data = hexToBigInt('0x00000000000000000000000000000000000000000000000000000000000001a4', { size: 32 })\n * // 420n\n */\nexport function hexToBigInt(hex: Hex, opts: HexToBigIntOpts = {}): bigint {\n  const { signed } = opts\n\n  if (opts.size) assertSize(hex, { size: opts.size })\n\n  const value = BigInt(hex)\n  if (!signed) return value\n\n  const size = (hex.length - 2) / 2\n  const max = (1n << (BigInt(size) * 8n - 1n)) - 1n\n  if (value <= max) return value\n\n  return value - BigInt(`0x${'f'.padStart(size * 2, 'f')}`) - 1n\n}\n\nexport type HexToBoolOpts = {\n  /** Size (in bytes) of the hex value. */\n  size?: number | undefined\n}\n\nexport type HexToBoolErrorType =\n  | AssertSizeErrorType\n  | InvalidHexBooleanErrorType\n  | TrimErrorType\n  | ErrorType\n\n/**\n * Decodes a hex value into a boolean.\n *\n * - Docs: https://viem.sh/docs/utilities/fromHex#hextobool\n *\n * @param hex Hex value to decode.\n * @param opts Options.\n * @returns Boolean value.\n *\n * @example\n * import { hexToBool } from 'viem'\n * const data = hexToBool('0x01')\n * // true\n *\n * @example\n * import { hexToBool } from 'viem'\n * const data = hexToBool('0x0000000000000000000000000000000000000000000000000000000000000001', { size: 32 })\n * // true\n */\nexport function hexToBool(hex_: Hex, opts: HexToBoolOpts = {}): boolean {\n  let hex = hex_\n  if (opts.size) {\n    assertSize(hex, { size: opts.size })\n    hex = trim(hex)\n  }\n  if (trim(hex) === '0x00') return false\n  if (trim(hex) === '0x01') return true\n  throw new InvalidHexBooleanError(hex)\n}\n\nexport type HexToNumberOpts = HexToBigIntOpts\n\nexport type HexToNumberErrorType =\n  | HexToBigIntErrorType\n  | IntegerOutOfRangeErrorType\n  | ErrorType\n\n/**\n * Decodes a hex string into a number.\n *\n * - Docs: https://viem.sh/docs/utilities/fromHex#hextonumber\n *\n * @param hex Hex value to decode.\n * @param opts Options.\n * @returns Number value.\n *\n * @example\n * import { hexToNumber } from 'viem'\n * const data = hexToNumber('0x1a4')\n * // 420\n *\n * @example\n * import { hexToNumber } from 'viem'\n * const data = hexToBigInt('0x00000000000000000000000000000000000000000000000000000000000001a4', { size: 32 })\n * // 420\n */\nexport function hexToNumber(hex: Hex, opts: HexToNumberOpts = {}): number {\n  const value = hexToBigInt(hex, opts)\n  const number = Number(value)\n  if (!Number.isSafeInteger(number))\n    throw new IntegerOutOfRangeError({\n      max: `${Number.MAX_SAFE_INTEGER}`,\n      min: `${Number.MIN_SAFE_INTEGER}`,\n      signed: opts.signed,\n      size: opts.size,\n      value: `${value}n`,\n    })\n  return number\n}\n\nexport type HexToStringOpts = {\n  /** Size (in bytes) of the hex value. */\n  size?: number | undefined\n}\n\nexport type HexToStringErrorType =\n  | AssertSizeErrorType\n  | HexToBytesErrorType\n  | TrimErrorType\n  | ErrorType\n\n/**\n * Decodes a hex value into a UTF-8 string.\n *\n * - Docs: https://viem.sh/docs/utilities/fromHex#hextostring\n *\n * @param hex Hex value to decode.\n * @param opts Options.\n * @returns String value.\n *\n * @example\n * import { hexToString } from 'viem'\n * const data = hexToString('0x48656c6c6f20576f726c6421')\n * // 'Hello world!'\n *\n * @example\n * import { hexToString } from 'viem'\n * const data = hexToString('0x48656c6c6f20576f726c64210000000000000000000000000000000000000000', {\n *  size: 32,\n * })\n * // 'Hello world'\n */\nexport function hexToString(hex: Hex, opts: HexToStringOpts = {}): string {\n  let bytes = hexToBytes(hex)\n  if (opts.size) {\n    assertSize(bytes, { size: opts.size })\n    bytes = trim(bytes, { dir: 'right' })\n  }\n  return new TextDecoder().decode(bytes)\n}\n","import {\n  IntegerOutOfRangeError,\n  type IntegerOutOfRangeErrorType,\n} from '../../errors/encoding.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { type PadErrorType, pad } from '../data/pad.js'\n\nimport { type AssertSizeErrorType, assertSize } from './fromHex.js'\n\nconst hexes = /*#__PURE__*/ Array.from({ length: 256 }, (_v, i) =>\n  i.toString(16).padStart(2, '0'),\n)\n\nexport type ToHexParameters = {\n  /** The size (in bytes) of the output hex value. */\n  size?: number | undefined\n}\n\nexport type ToHexErrorType =\n  | BoolToHexErrorType\n  | BytesToHexErrorType\n  | NumberToHexErrorType\n  | StringToHexErrorType\n  | ErrorType\n\n/**\n * Encodes a string, number, bigint, or ByteArray into a hex string\n *\n * - Docs: https://viem.sh/docs/utilities/toHex\n * - Example: https://viem.sh/docs/utilities/toHex#usage\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Hex value.\n *\n * @example\n * import { toHex } from 'viem'\n * const data = toHex('Hello world')\n * // '0x48656c6c6f20776f726c6421'\n *\n * @example\n * import { toHex } from 'viem'\n * const data = toHex(420)\n * // '0x1a4'\n *\n * @example\n * import { toHex } from 'viem'\n * const data = toHex('Hello world', { size: 32 })\n * // '0x48656c6c6f20776f726c64210000000000000000000000000000000000000000'\n */\nexport function toHex(\n  value: string | number | bigint | boolean | ByteArray,\n  opts: ToHexParameters = {},\n): Hex {\n  if (typeof value === 'number' || typeof value === 'bigint')\n    return numberToHex(value, opts)\n  if (typeof value === 'string') {\n    return stringToHex(value, opts)\n  }\n  if (typeof value === 'boolean') return boolToHex(value, opts)\n  return bytesToHex(value, opts)\n}\n\nexport type BoolToHexOpts = {\n  /** The size (in bytes) of the output hex value. */\n  size?: number | undefined\n}\n\nexport type BoolToHexErrorType = AssertSizeErrorType | PadErrorType | ErrorType\n\n/**\n * Encodes a boolean into a hex string\n *\n * - Docs: https://viem.sh/docs/utilities/toHex#booltohex\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Hex value.\n *\n * @example\n * import { boolToHex } from 'viem'\n * const data = boolToHex(true)\n * // '0x1'\n *\n * @example\n * import { boolToHex } from 'viem'\n * const data = boolToHex(false)\n * // '0x0'\n *\n * @example\n * import { boolToHex } from 'viem'\n * const data = boolToHex(true, { size: 32 })\n * // '0x0000000000000000000000000000000000000000000000000000000000000001'\n */\nexport function boolToHex(value: boolean, opts: BoolToHexOpts = {}): Hex {\n  const hex: Hex = `0x${Number(value)}`\n  if (typeof opts.size === 'number') {\n    assertSize(hex, { size: opts.size })\n    return pad(hex, { size: opts.size })\n  }\n  return hex\n}\n\nexport type BytesToHexOpts = {\n  /** The size (in bytes) of the output hex value. */\n  size?: number | undefined\n}\n\nexport type BytesToHexErrorType = AssertSizeErrorType | PadErrorType | ErrorType\n\n/**\n * Encodes a bytes array into a hex string\n *\n * - Docs: https://viem.sh/docs/utilities/toHex#bytestohex\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Hex value.\n *\n * @example\n * import { bytesToHex } from 'viem'\n * const data = bytesToHex(Uint8Array.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])\n * // '0x48656c6c6f20576f726c6421'\n *\n * @example\n * import { bytesToHex } from 'viem'\n * const data = bytesToHex(Uint8Array.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]), { size: 32 })\n * // '0x48656c6c6f20576f726c64210000000000000000000000000000000000000000'\n */\nexport function bytesToHex(value: ByteArray, opts: BytesToHexOpts = {}): Hex {\n  let string = ''\n  for (let i = 0; i < value.length; i++) {\n    string += hexes[value[i]]\n  }\n  const hex = `0x${string}` as const\n\n  if (typeof opts.size === 'number') {\n    assertSize(hex, { size: opts.size })\n    return pad(hex, { dir: 'right', size: opts.size })\n  }\n  return hex\n}\n\nexport type NumberToHexOpts =\n  | {\n      /** Whether or not the number of a signed representation. */\n      signed?: boolean | undefined\n      /** The size (in bytes) of the output hex value. */\n      size: number\n    }\n  | {\n      signed?: undefined\n      /** The size (in bytes) of the output hex value. */\n      size?: number | undefined\n    }\n\nexport type NumberToHexErrorType =\n  | IntegerOutOfRangeErrorType\n  | PadErrorType\n  | ErrorType\n\n/**\n * Encodes a number or bigint into a hex string\n *\n * - Docs: https://viem.sh/docs/utilities/toHex#numbertohex\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Hex value.\n *\n * @example\n * import { numberToHex } from 'viem'\n * const data = numberToHex(420)\n * // '0x1a4'\n *\n * @example\n * import { numberToHex } from 'viem'\n * const data = numberToHex(420, { size: 32 })\n * // '0x00000000000000000000000000000000000000000000000000000000000001a4'\n */\nexport function numberToHex(\n  value_: number | bigint,\n  opts: NumberToHexOpts = {},\n): Hex {\n  const { signed, size } = opts\n\n  const value = BigInt(value_)\n\n  let maxValue: bigint | number | undefined\n  if (size) {\n    if (signed) maxValue = (1n << (BigInt(size) * 8n - 1n)) - 1n\n    else maxValue = 2n ** (BigInt(size) * 8n) - 1n\n  } else if (typeof value_ === 'number') {\n    maxValue = BigInt(Number.MAX_SAFE_INTEGER)\n  }\n\n  const minValue = typeof maxValue === 'bigint' && signed ? -maxValue - 1n : 0\n\n  if ((maxValue && value > maxValue) || value < minValue) {\n    const suffix = typeof value_ === 'bigint' ? 'n' : ''\n    throw new IntegerOutOfRangeError({\n      max: maxValue ? `${maxValue}${suffix}` : undefined,\n      min: `${minValue}${suffix}`,\n      signed,\n      size,\n      value: `${value_}${suffix}`,\n    })\n  }\n\n  const hex = `0x${(\n    signed && value < 0 ? (1n << BigInt(size * 8)) + BigInt(value) : value\n  ).toString(16)}` as Hex\n  if (size) return pad(hex, { size }) as Hex\n  return hex\n}\n\nexport type StringToHexOpts = {\n  /** The size (in bytes) of the output hex value. */\n  size?: number | undefined\n}\n\nexport type StringToHexErrorType = BytesToHexErrorType | ErrorType\n\nconst encoder = /*#__PURE__*/ new TextEncoder()\n\n/**\n * Encodes a UTF-8 string into a hex string\n *\n * - Docs: https://viem.sh/docs/utilities/toHex#stringtohex\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Hex value.\n *\n * @example\n * import { stringToHex } from 'viem'\n * const data = stringToHex('Hello World!')\n * // '0x48656c6c6f20576f726c6421'\n *\n * @example\n * import { stringToHex } from 'viem'\n * const data = stringToHex('Hello World!', { size: 32 })\n * // '0x48656c6c6f20576f726c64210000000000000000000000000000000000000000'\n */\nexport function stringToHex(value_: string, opts: StringToHexOpts = {}): Hex {\n  const value = encoder.encode(value_)\n  return bytesToHex(value, opts)\n}\n","// EIP-3009 TransferWithAuthorization types for EIP-712 signing\nexport const authorizationTypes = {\n  TransferWithAuthorization: [\n    { name: \"from\", type: \"address\" },\n    { name: \"to\", type: \"address\" },\n    { name: \"value\", type: \"uint256\" },\n    { name: \"validAfter\", type: \"uint256\" },\n    { name: \"validBefore\", type: \"uint256\" },\n    { name: \"nonce\", type: \"bytes32\" },\n  ],\n} as const;\n\n// EIP3009 ABI for transferWithAuthorization function\nexport const eip3009ABI = [\n  {\n    inputs: [\n      { name: \"from\", type: \"address\" },\n      { name: \"to\", type: \"address\" },\n      { name: \"value\", type: \"uint256\" },\n      { name: \"validAfter\", type: \"uint256\" },\n      { name: \"validBefore\", type: \"uint256\" },\n      { name: \"nonce\", type: \"bytes32\" },\n      { name: \"v\", type: \"uint8\" },\n      { name: \"r\", type: \"bytes32\" },\n      { name: \"s\", type: \"bytes32\" },\n    ],\n    name: \"transferWithAuthorization\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      { name: \"from\", type: \"address\" },\n      { name: \"to\", type: \"address\" },\n      { name: \"value\", type: \"uint256\" },\n      { name: \"validAfter\", type: \"uint256\" },\n      { name: \"validBefore\", type: \"uint256\" },\n      { name: \"nonce\", type: \"bytes32\" },\n      { name: \"signature\", type: \"bytes\" },\n    ],\n    name: \"transferWithAuthorization\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [{ name: \"account\", type: \"address\" }],\n    name: \"balanceOf\",\n    outputs: [{ name: \"\", type: \"uint256\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"version\",\n    outputs: [{ name: \"\", type: \"string\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n] as const;\n","import { toHex } from \"viem\";\nimport { Network } from \"@x402/core/types\";\n\n/**\n * Extract chain ID from network string (e.g., \"base-sepolia\" -> 84532)\n * Used by v1 implementations\n *\n * @param network - The network identifier\n * @returns The numeric chain ID\n */\nexport function getEvmChainId(network: Network): number {\n  const networkMap: Record<string, number> = {\n    base: 8453,\n    \"base-sepolia\": 84532,\n    ethereum: 1,\n    sepolia: 11155111,\n    polygon: 137,\n    \"polygon-amoy\": 80002,\n  };\n  return networkMap[network] || 1;\n}\n\n/**\n * Create a random 32-byte nonce for authorization\n *\n * @returns A hex-encoded 32-byte nonce\n */\nexport function createNonce(): `0x${string}` {\n  // Use dynamic import to avoid require() in ESM context\n  const cryptoObj =\n    typeof globalThis.crypto !== \"undefined\"\n      ? globalThis.crypto\n      : (globalThis as { crypto?: Crypto }).crypto;\n\n  if (!cryptoObj) {\n    throw new Error(\"Crypto API not available\");\n  }\n\n  return toHex(cryptoObj.getRandomValues(new Uint8Array(32)));\n}\n","import { BaseError } from './base.js'\n\nexport type InvalidAddressErrorType = InvalidAddressError & {\n  name: 'InvalidAddressError'\n}\nexport class InvalidAddressError extends BaseError {\n  constructor({ address }: { address: string }) {\n    super(`Address \"${address}\" is invalid.`, {\n      metaMessages: [\n        '- Address must be a hex value of 20 bytes (40 hex characters).',\n        '- Address must match its checksum counterpart.',\n      ],\n      name: 'InvalidAddressError',\n    })\n  }\n}\n","import { BaseError } from '../../errors/base.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { type IsHexErrorType, isHex } from '../data/isHex.js'\nimport { type PadErrorType, pad } from '../data/pad.js'\n\nimport { type AssertSizeErrorType, assertSize } from './fromHex.js'\nimport {\n  type NumberToHexErrorType,\n  type NumberToHexOpts,\n  numberToHex,\n} from './toHex.js'\n\nconst encoder = /*#__PURE__*/ new TextEncoder()\n\nexport type ToBytesParameters = {\n  /** Size of the output bytes. */\n  size?: number | undefined\n}\n\nexport type ToBytesErrorType =\n  | NumberToBytesErrorType\n  | BoolToBytesErrorType\n  | HexToBytesErrorType\n  | StringToBytesErrorType\n  | IsHexErrorType\n  | ErrorType\n\n/**\n * Encodes a UTF-8 string, hex value, bigint, number or boolean to a byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/toBytes\n * - Example: https://viem.sh/docs/utilities/toBytes#usage\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Byte array value.\n *\n * @example\n * import { toBytes } from 'viem'\n * const data = toBytes('Hello world')\n * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])\n *\n * @example\n * import { toBytes } from 'viem'\n * const data = toBytes(420)\n * // Uint8Array([1, 164])\n *\n * @example\n * import { toBytes } from 'viem'\n * const data = toBytes(420, { size: 4 })\n * // Uint8Array([0, 0, 1, 164])\n */\nexport function toBytes(\n  value: string | bigint | number | boolean | Hex,\n  opts: ToBytesParameters = {},\n): ByteArray {\n  if (typeof value === 'number' || typeof value === 'bigint')\n    return numberToBytes(value, opts)\n  if (typeof value === 'boolean') return boolToBytes(value, opts)\n  if (isHex(value)) return hexToBytes(value, opts)\n  return stringToBytes(value, opts)\n}\n\nexport type BoolToBytesOpts = {\n  /** Size of the output bytes. */\n  size?: number | undefined\n}\n\nexport type BoolToBytesErrorType =\n  | AssertSizeErrorType\n  | PadErrorType\n  | ErrorType\n\n/**\n * Encodes a boolean into a byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/toBytes#booltobytes\n *\n * @param value Boolean value to encode.\n * @param opts Options.\n * @returns Byte array value.\n *\n * @example\n * import { boolToBytes } from 'viem'\n * const data = boolToBytes(true)\n * // Uint8Array([1])\n *\n * @example\n * import { boolToBytes } from 'viem'\n * const data = boolToBytes(true, { size: 32 })\n * // Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1])\n */\nexport function boolToBytes(value: boolean, opts: BoolToBytesOpts = {}) {\n  const bytes = new Uint8Array(1)\n  bytes[0] = Number(value)\n  if (typeof opts.size === 'number') {\n    assertSize(bytes, { size: opts.size })\n    return pad(bytes, { size: opts.size })\n  }\n  return bytes\n}\n\n// We use very optimized technique to convert hex string to byte array\nconst charCodeMap = {\n  zero: 48,\n  nine: 57,\n  A: 65,\n  F: 70,\n  a: 97,\n  f: 102,\n} as const\n\nfunction charCodeToBase16(char: number) {\n  if (char >= charCodeMap.zero && char <= charCodeMap.nine)\n    return char - charCodeMap.zero\n  if (char >= charCodeMap.A && char <= charCodeMap.F)\n    return char - (charCodeMap.A - 10)\n  if (char >= charCodeMap.a && char <= charCodeMap.f)\n    return char - (charCodeMap.a - 10)\n  return undefined\n}\n\nexport type HexToBytesOpts = {\n  /** Size of the output bytes. */\n  size?: number | undefined\n}\n\nexport type HexToBytesErrorType = AssertSizeErrorType | PadErrorType | ErrorType\n\n/**\n * Encodes a hex string into a byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/toBytes#hextobytes\n *\n * @param hex Hex string to encode.\n * @param opts Options.\n * @returns Byte array value.\n *\n * @example\n * import { hexToBytes } from 'viem'\n * const data = hexToBytes('0x48656c6c6f20776f726c6421')\n * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])\n *\n * @example\n * import { hexToBytes } from 'viem'\n * const data = hexToBytes('0x48656c6c6f20776f726c6421', { size: 32 })\n * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n */\nexport function hexToBytes(hex_: Hex, opts: HexToBytesOpts = {}): ByteArray {\n  let hex = hex_\n  if (opts.size) {\n    assertSize(hex, { size: opts.size })\n    hex = pad(hex, { dir: 'right', size: opts.size })\n  }\n\n  let hexString = hex.slice(2) as string\n  if (hexString.length % 2) hexString = `0${hexString}`\n\n  const length = hexString.length / 2\n  const bytes = new Uint8Array(length)\n  for (let index = 0, j = 0; index < length; index++) {\n    const nibbleLeft = charCodeToBase16(hexString.charCodeAt(j++))\n    const nibbleRight = charCodeToBase16(hexString.charCodeAt(j++))\n    if (nibbleLeft === undefined || nibbleRight === undefined) {\n      throw new BaseError(\n        `Invalid byte sequence (\"${hexString[j - 2]}${\n          hexString[j - 1]\n        }\" in \"${hexString}\").`,\n      )\n    }\n    bytes[index] = nibbleLeft * 16 + nibbleRight\n  }\n  return bytes\n}\n\nexport type NumberToBytesErrorType =\n  | NumberToHexErrorType\n  | HexToBytesErrorType\n  | ErrorType\n\n/**\n * Encodes a number into a byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/toBytes#numbertobytes\n *\n * @param value Number to encode.\n * @param opts Options.\n * @returns Byte array value.\n *\n * @example\n * import { numberToBytes } from 'viem'\n * const data = numberToBytes(420)\n * // Uint8Array([1, 164])\n *\n * @example\n * import { numberToBytes } from 'viem'\n * const data = numberToBytes(420, { size: 4 })\n * // Uint8Array([0, 0, 1, 164])\n */\nexport function numberToBytes(\n  value: bigint | number,\n  opts?: NumberToHexOpts | undefined,\n) {\n  const hex = numberToHex(value, opts)\n  return hexToBytes(hex)\n}\n\nexport type StringToBytesOpts = {\n  /** Size of the output bytes. */\n  size?: number | undefined\n}\n\nexport type StringToBytesErrorType =\n  | AssertSizeErrorType\n  | PadErrorType\n  | ErrorType\n\n/**\n * Encodes a UTF-8 string into a byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/toBytes#stringtobytes\n *\n * @param value String to encode.\n * @param opts Options.\n * @returns Byte array value.\n *\n * @example\n * import { stringToBytes } from 'viem'\n * const data = stringToBytes('Hello world!')\n * // Uint8Array([72, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100, 33])\n *\n * @example\n * import { stringToBytes } from 'viem'\n * const data = stringToBytes('Hello world!', { size: 32 })\n * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n */\nexport function stringToBytes(\n  value: string,\n  opts: StringToBytesOpts = {},\n): ByteArray {\n  const bytes = encoder.encode(value)\n  if (typeof opts.size === 'number') {\n    assertSize(bytes, { size: opts.size })\n    return pad(bytes, { dir: 'right', size: opts.size })\n  }\n  return bytes\n}\n","/**\n * Internal helpers for u64. BigUint64Array is too slow as per 2025, so we implement it using Uint32Array.\n * @todo re-check https://issues.chromium.org/issues/42212588\n * @module\n */\nconst U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\n\nfunction fromBig(\n  n: bigint,\n  le = false\n): {\n  h: number;\n  l: number;\n} {\n  if (le) return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n  return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\n\nfunction split(lst: bigint[], le = false): Uint32Array[] {\n  const len = lst.length;\n  let Ah = new Uint32Array(len);\n  let Al = new Uint32Array(len);\n  for (let i = 0; i < len; i++) {\n    const { h, l } = fromBig(lst[i], le);\n    [Ah[i], Al[i]] = [h, l];\n  }\n  return [Ah, Al];\n}\n\nconst toBig = (h: number, l: number): bigint => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h: number, _l: number, s: number): number => h >>> s;\nconst shrSL = (h: number, l: number, s: number): number => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h: number, l: number, s: number): number => (h >>> s) | (l << (32 - s));\nconst rotrSL = (h: number, l: number, s: number): number => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h: number, l: number, s: number): number => (h << (64 - s)) | (l >>> (s - 32));\nconst rotrBL = (h: number, l: number, s: number): number => (h >>> (s - 32)) | (l << (64 - s));\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h: number, l: number): number => l;\nconst rotr32L = (h: number, _l: number): number => h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h: number, l: number, s: number): number => (h << s) | (l >>> (32 - s));\nconst rotlSL = (h: number, l: number, s: number): number => (l << s) | (h >>> (32 - s));\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h: number, l: number, s: number): number => (l << (s - 32)) | (h >>> (64 - s));\nconst rotlBL = (h: number, l: number, s: number): number => (h << (s - 32)) | (l >>> (64 - s));\n\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(\n  Ah: number,\n  Al: number,\n  Bh: number,\n  Bl: number\n): {\n  h: number;\n  l: number;\n} {\n  const l = (Al >>> 0) + (Bl >>> 0);\n  return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\n// Addition with more than 2 elements\nconst add3L = (Al: number, Bl: number, Cl: number): number => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low: number, Ah: number, Bh: number, Ch: number): number =>\n  (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nconst add4L = (Al: number, Bl: number, Cl: number, Dl: number): number =>\n  (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low: number, Ah: number, Bh: number, Ch: number, Dh: number): number =>\n  (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nconst add5L = (Al: number, Bl: number, Cl: number, Dl: number, El: number): number =>\n  (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low: number, Ah: number, Bh: number, Ch: number, Dh: number, Eh: number): number =>\n  (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\n\n// prettier-ignore\nexport {\n  add, add3H, add3L, add4H, add4L, add5H, add5L, fromBig, rotlBH, rotlBL, rotlSH, rotlSL, rotr32H, rotr32L, rotrBH, rotrBL, rotrSH, rotrSL, shrSH, shrSL, split, toBig\n};\n// prettier-ignore\nconst u64: { fromBig: typeof fromBig; split: typeof split; toBig: (h: number, l: number) => bigint; shrSH: (h: number, _l: number, s: number) => number; shrSL: (h: number, l: number, s: number) => number; rotrSH: (h: number, l: number, s: number) => number; rotrSL: (h: number, l: number, s: number) => number; rotrBH: (h: number, l: number, s: number) => number; rotrBL: (h: number, l: number, s: number) => number; rotr32H: (_h: number, l: number) => number; rotr32L: (h: number, _l: number) => number; rotlSH: (h: number, l: number, s: number) => number; rotlSL: (h: number, l: number, s: number) => number; rotlBH: (h: number, l: number, s: number) => number; rotlBL: (h: number, l: number, s: number) => number; add: typeof add; add3L: (Al: number, Bl: number, Cl: number) => number; add3H: (low: number, Ah: number, Bh: number, Ch: number) => number; add4L: (Al: number, Bl: number, Cl: number, Dl: number) => number; add4H: (low: number, Ah: number, Bh: number, Ch: number, Dh: number) => number; add5H: (low: number, Ah: number, Bh: number, Ch: number, Dh: number, Eh: number) => number; add5L: (Al: number, Bl: number, Cl: number, Dl: number, El: number) => number; } = {\n  fromBig, split, toBig,\n  shrSH, shrSL,\n  rotrSH, rotrSL, rotrBH, rotrBL,\n  rotr32H, rotr32L,\n  rotlSH, rotlSL, rotlBH, rotlBL,\n  add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\nexport default u64;\n","/**\n * Utilities for hex, bytes, CSPRNG.\n * @module\n */\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\nimport { crypto } from '@noble/hashes/crypto';\n\n/** Checks if something is Uint8Array. Be careful: nodejs Buffer will return true. */\nexport function isBytes(a: unknown): a is Uint8Array {\n  return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n\n/** Asserts something is positive integer. */\nexport function anumber(n: number): void {\n  if (!Number.isSafeInteger(n) || n < 0) throw new Error('positive integer expected, got ' + n);\n}\n\n/** Asserts something is Uint8Array. */\nexport function abytes(b: Uint8Array | undefined, ...lengths: number[]): void {\n  if (!isBytes(b)) throw new Error('Uint8Array expected');\n  if (lengths.length > 0 && !lengths.includes(b.length))\n    throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);\n}\n\n/** Asserts something is hash */\nexport function ahash(h: IHash): void {\n  if (typeof h !== 'function' || typeof h.create !== 'function')\n    throw new Error('Hash should be wrapped by utils.createHasher');\n  anumber(h.outputLen);\n  anumber(h.blockLen);\n}\n\n/** Asserts a hash instance has not been destroyed / finished */\nexport function aexists(instance: any, checkFinished = true): void {\n  if (instance.destroyed) throw new Error('Hash instance has been destroyed');\n  if (checkFinished && instance.finished) throw new Error('Hash#digest() has already been called');\n}\n\n/** Asserts output is properly-sized byte array */\nexport function aoutput(out: any, instance: any): void {\n  abytes(out);\n  const min = instance.outputLen;\n  if (out.length < min) {\n    throw new Error('digestInto() expects output buffer of length at least ' + min);\n  }\n}\n\n/** Generic type encompassing 8/16/32-byte arrays - but not 64-byte. */\n// prettier-ignore\nexport type TypedArray = Int8Array | Uint8ClampedArray | Uint8Array |\n  Uint16Array | Int16Array | Uint32Array | Int32Array;\n\n/** Cast u8 / u16 / u32 to u8. */\nexport function u8(arr: TypedArray): Uint8Array {\n  return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n\n/** Cast u8 / u16 / u32 to u32. */\nexport function u32(arr: TypedArray): Uint32Array {\n  return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n}\n\n/** Zeroize a byte array. Warning: JS provides no guarantees. */\nexport function clean(...arrays: TypedArray[]): void {\n  for (let i = 0; i < arrays.length; i++) {\n    arrays[i].fill(0);\n  }\n}\n\n/** Create DataView of an array for easy byte-level manipulation. */\nexport function createView(arr: TypedArray): DataView {\n  return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n\n/** The rotate right (circular right shift) operation for uint32 */\nexport function rotr(word: number, shift: number): number {\n  return (word << (32 - shift)) | (word >>> shift);\n}\n\n/** The rotate left (circular left shift) operation for uint32 */\nexport function rotl(word: number, shift: number): number {\n  return (word << shift) | ((word >>> (32 - shift)) >>> 0);\n}\n\n/** Is current platform little-endian? Most are. Big-Endian platform: IBM */\nexport const isLE: boolean = /* @__PURE__ */ (() =>\n  new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44)();\n\n/** The byte swap operation for uint32 */\nexport function byteSwap(word: number): number {\n  return (\n    ((word << 24) & 0xff000000) |\n    ((word << 8) & 0xff0000) |\n    ((word >>> 8) & 0xff00) |\n    ((word >>> 24) & 0xff)\n  );\n}\n/** Conditionally byte swap if on a big-endian platform */\nexport const swap8IfBE: (n: number) => number = isLE\n  ? (n: number) => n\n  : (n: number) => byteSwap(n);\n\n/** @deprecated */\nexport const byteSwapIfBE: typeof swap8IfBE = swap8IfBE;\n/** In place byte swap for Uint32Array */\nexport function byteSwap32(arr: Uint32Array): Uint32Array {\n  for (let i = 0; i < arr.length; i++) {\n    arr[i] = byteSwap(arr[i]);\n  }\n  return arr;\n}\n\nexport const swap32IfBE: (u: Uint32Array) => Uint32Array = isLE\n  ? (u: Uint32Array) => u\n  : byteSwap32;\n\n// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex\nconst hasHexBuiltin: boolean = /* @__PURE__ */ (() =>\n  // @ts-ignore\n  typeof Uint8Array.from([]).toHex === 'function' && typeof Uint8Array.fromHex === 'function')();\n\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) =>\n  i.toString(16).padStart(2, '0')\n);\n\n/**\n * Convert byte array to hex string. Uses built-in function, when available.\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes: Uint8Array): string {\n  abytes(bytes);\n  // @ts-ignore\n  if (hasHexBuiltin) return bytes.toHex();\n  // pre-caching improves the speed 6x\n  let hex = '';\n  for (let i = 0; i < bytes.length; i++) {\n    hex += hexes[bytes[i]];\n  }\n  return hex;\n}\n\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 } as const;\nfunction asciiToBase16(ch: number): number | undefined {\n  if (ch >= asciis._0 && ch <= asciis._9) return ch - asciis._0; // '2' => 50-48\n  if (ch >= asciis.A && ch <= asciis.F) return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n  if (ch >= asciis.a && ch <= asciis.f) return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n  return;\n}\n\n/**\n * Convert hex string to byte array. Uses built-in function, when available.\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex: string): Uint8Array {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  // @ts-ignore\n  if (hasHexBuiltin) return Uint8Array.fromHex(hex);\n  const hl = hex.length;\n  const al = hl / 2;\n  if (hl % 2) throw new Error('hex string expected, got unpadded hex of length ' + hl);\n  const array = new Uint8Array(al);\n  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n    const n1 = asciiToBase16(hex.charCodeAt(hi));\n    const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n    if (n1 === undefined || n2 === undefined) {\n      const char = hex[hi] + hex[hi + 1];\n      throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n    }\n    array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n  }\n  return array;\n}\n\n/**\n * There is no setImmediate in browser and setTimeout is slow.\n * Call of async fn will return Promise, which will be fullfiled only on\n * next scheduler queue processing step and this is exactly what we need.\n */\nexport const nextTick = async (): Promise<void> => {};\n\n/** Returns control to thread each 'tick' ms to avoid blocking. */\nexport async function asyncLoop(\n  iters: number,\n  tick: number,\n  cb: (i: number) => void\n): Promise<void> {\n  let ts = Date.now();\n  for (let i = 0; i < iters; i++) {\n    cb(i);\n    // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n    const diff = Date.now() - ts;\n    if (diff >= 0 && diff < tick) continue;\n    await nextTick();\n    ts += diff;\n  }\n}\n\n// Global symbols, but ts doesn't see them: https://github.com/microsoft/TypeScript/issues/31535\ndeclare const TextEncoder: any;\ndeclare const TextDecoder: any;\n\n/**\n * Converts string to bytes using UTF8 encoding.\n * @example utf8ToBytes('abc') // Uint8Array.from([97, 98, 99])\n */\nexport function utf8ToBytes(str: string): Uint8Array {\n  if (typeof str !== 'string') throw new Error('string expected');\n  return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n\n/**\n * Converts bytes to string using UTF8 encoding.\n * @example bytesToUtf8(Uint8Array.from([97, 98, 99])) // 'abc'\n */\nexport function bytesToUtf8(bytes: Uint8Array): string {\n  return new TextDecoder().decode(bytes);\n}\n\n/** Accepted input of hash functions. Strings are converted to byte arrays. */\nexport type Input = string | Uint8Array;\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nexport function toBytes(data: Input): Uint8Array {\n  if (typeof data === 'string') data = utf8ToBytes(data);\n  abytes(data);\n  return data;\n}\n\n/** KDFs can accept string or Uint8Array for user convenience. */\nexport type KDFInput = string | Uint8Array;\n/**\n * Helper for KDFs: consumes uint8array or string.\n * When string is passed, does utf8 decoding, using TextDecoder.\n */\nexport function kdfInputToBytes(data: KDFInput): Uint8Array {\n  if (typeof data === 'string') data = utf8ToBytes(data);\n  abytes(data);\n  return data;\n}\n\n/** Copies several Uint8Arrays into one. */\nexport function concatBytes(...arrays: Uint8Array[]): Uint8Array {\n  let sum = 0;\n  for (let i = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    abytes(a);\n    sum += a.length;\n  }\n  const res = new Uint8Array(sum);\n  for (let i = 0, pad = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    res.set(a, pad);\n    pad += a.length;\n  }\n  return res;\n}\n\ntype EmptyObj = {};\nexport function checkOpts<T1 extends EmptyObj, T2 extends EmptyObj>(\n  defaults: T1,\n  opts?: T2\n): T1 & T2 {\n  if (opts !== undefined && {}.toString.call(opts) !== '[object Object]')\n    throw new Error('options should be object or undefined');\n  const merged = Object.assign(defaults, opts);\n  return merged as T1 & T2;\n}\n\n/** Hash interface. */\nexport type IHash = {\n  (data: Uint8Array): Uint8Array;\n  blockLen: number;\n  outputLen: number;\n  create: any;\n};\n\n/** For runtime check if class implements interface */\nexport abstract class Hash<T extends Hash<T>> {\n  abstract blockLen: number; // Bytes per block\n  abstract outputLen: number; // Bytes in output\n  abstract update(buf: Input): this;\n  // Writes digest into buf\n  abstract digestInto(buf: Uint8Array): void;\n  abstract digest(): Uint8Array;\n  /**\n   * Resets internal state. Makes Hash instance unusable.\n   * Reset is impossible for keyed hashes if key is consumed into state. If digest is not consumed\n   * by user, they will need to manually call `destroy()` when zeroing is necessary.\n   */\n  abstract destroy(): void;\n  /**\n   * Clones hash instance. Unsafe: doesn't check whether `to` is valid. Can be used as `clone()`\n   * when no options are passed.\n   * Reasons to use `_cloneInto` instead of clone: 1) performance 2) reuse instance => all internal\n   * buffers are overwritten => causes buffer overwrite which is used for digest in some cases.\n   * There are no guarantees for clean-up because it's impossible in JS.\n   */\n  abstract _cloneInto(to?: T): T;\n  // Safe version that clones internal state\n  abstract clone(): T;\n}\n\n/**\n * XOF: streaming API to read digest in chunks.\n * Same as 'squeeze' in keccak/k12 and 'seek' in blake3, but more generic name.\n * When hash used in XOF mode it is up to user to call '.destroy' afterwards, since we cannot\n * destroy state, next call can require more bytes.\n */\nexport type HashXOF<T extends Hash<T>> = Hash<T> & {\n  xof(bytes: number): Uint8Array; // Read 'bytes' bytes from digest stream\n  xofInto(buf: Uint8Array): Uint8Array; // read buf.length bytes from digest stream into buf\n};\n\n/** Hash function */\nexport type CHash = ReturnType<typeof createHasher>;\n/** Hash function with output */\nexport type CHashO = ReturnType<typeof createOptHasher>;\n/** XOF with output */\nexport type CHashXO = ReturnType<typeof createXOFer>;\n\n/** Wraps hash function, creating an interface on top of it */\nexport function createHasher<T extends Hash<T>>(\n  hashCons: () => Hash<T>\n): {\n  (msg: Input): Uint8Array;\n  outputLen: number;\n  blockLen: number;\n  create(): Hash<T>;\n} {\n  const hashC = (msg: Input): Uint8Array => hashCons().update(toBytes(msg)).digest();\n  const tmp = hashCons();\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = () => hashCons();\n  return hashC;\n}\n\nexport function createOptHasher<H extends Hash<H>, T extends Object>(\n  hashCons: (opts?: T) => Hash<H>\n): {\n  (msg: Input, opts?: T): Uint8Array;\n  outputLen: number;\n  blockLen: number;\n  create(opts?: T): Hash<H>;\n} {\n  const hashC = (msg: Input, opts?: T): Uint8Array => hashCons(opts).update(toBytes(msg)).digest();\n  const tmp = hashCons({} as T);\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = (opts?: T) => hashCons(opts);\n  return hashC;\n}\n\nexport function createXOFer<H extends HashXOF<H>, T extends Object>(\n  hashCons: (opts?: T) => HashXOF<H>\n): {\n  (msg: Input, opts?: T): Uint8Array;\n  outputLen: number;\n  blockLen: number;\n  create(opts?: T): HashXOF<H>;\n} {\n  const hashC = (msg: Input, opts?: T): Uint8Array => hashCons(opts).update(toBytes(msg)).digest();\n  const tmp = hashCons({} as T);\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = (opts?: T) => hashCons(opts);\n  return hashC;\n}\nexport const wrapConstructor: typeof createHasher = createHasher;\nexport const wrapConstructorWithOpts: typeof createOptHasher = createOptHasher;\nexport const wrapXOFConstructorWithOpts: typeof createXOFer = createXOFer;\n\n/** Cryptographically secure PRNG. Uses internal OS-level `crypto.getRandomValues`. */\nexport function randomBytes(bytesLength = 32): Uint8Array {\n  if (crypto && typeof crypto.getRandomValues === 'function') {\n    return crypto.getRandomValues(new Uint8Array(bytesLength));\n  }\n  // Legacy Node.js compatibility\n  if (crypto && typeof crypto.randomBytes === 'function') {\n    return Uint8Array.from(crypto.randomBytes(bytesLength));\n  }\n  throw new Error('crypto.getRandomValues must be defined');\n}\n","/**\n * SHA3 (keccak) hash function, based on a new \"Sponge function\" design.\n * Different from older hashes, the internal state is bigger than output size.\n *\n * Check out [FIPS-202](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf),\n * [Website](https://keccak.team/keccak.html),\n * [the differences between SHA-3 and Keccak](https://crypto.stackexchange.com/questions/15727/what-are-the-key-differences-between-the-draft-sha-3-standard-and-the-keccak-sub).\n *\n * Check out `sha3-addons` module for cSHAKE, k12, and others.\n * @module\n */\nimport { rotlBH, rotlBL, rotlSH, rotlSL, split } from './_u64.ts';\n// prettier-ignore\nimport {\n  abytes, aexists, anumber, aoutput,\n  clean, createHasher, createXOFer, Hash,\n  swap32IfBE,\n  toBytes, u32,\n  type CHash, type CHashXO, type HashXOF, type Input\n} from './utils.ts';\n\n// No __PURE__ annotations in sha3 header:\n// EVERYTHING is in fact used on every export.\n// Various per round constants calculations\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst _7n = BigInt(7);\nconst _256n = BigInt(256);\nconst _0x71n = BigInt(0x71);\nconst SHA3_PI: number[] = [];\nconst SHA3_ROTL: number[] = [];\nconst _SHA3_IOTA: bigint[] = [];\nfor (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {\n  // Pi\n  [x, y] = [y, (2 * x + 3 * y) % 5];\n  SHA3_PI.push(2 * (5 * y + x));\n  // Rotational\n  SHA3_ROTL.push((((round + 1) * (round + 2)) / 2) % 64);\n  // Iota\n  let t = _0n;\n  for (let j = 0; j < 7; j++) {\n    R = ((R << _1n) ^ ((R >> _7n) * _0x71n)) % _256n;\n    if (R & _2n) t ^= _1n << ((_1n << /* @__PURE__ */ BigInt(j)) - _1n);\n  }\n  _SHA3_IOTA.push(t);\n}\nconst IOTAS = split(_SHA3_IOTA, true);\nconst SHA3_IOTA_H = IOTAS[0];\nconst SHA3_IOTA_L = IOTAS[1];\n\n// Left rotation (without 0, 32, 64)\nconst rotlH = (h: number, l: number, s: number) => (s > 32 ? rotlBH(h, l, s) : rotlSH(h, l, s));\nconst rotlL = (h: number, l: number, s: number) => (s > 32 ? rotlBL(h, l, s) : rotlSL(h, l, s));\n\n/** `keccakf1600` internal function, additionally allows to adjust round count. */\nexport function keccakP(s: Uint32Array, rounds: number = 24): void {\n  const B = new Uint32Array(5 * 2);\n  // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)\n  for (let round = 24 - rounds; round < 24; round++) {\n    // Theta \n    for (let x = 0; x < 10; x++) B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];\n    for (let x = 0; x < 10; x += 2) {\n      const idx1 = (x + 8) % 10;\n      const idx0 = (x + 2) % 10;\n      const B0 = B[idx0];\n      const B1 = B[idx0 + 1];\n      const Th = rotlH(B0, B1, 1) ^ B[idx1];\n      const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];\n      for (let y = 0; y < 50; y += 10) {\n        s[x + y] ^= Th;\n        s[x + y + 1] ^= Tl;\n      }\n    }\n    // Rho () and Pi ()\n    let curH = s[2];\n    let curL = s[3];\n    for (let t = 0; t < 24; t++) {\n      const shift = SHA3_ROTL[t];\n      const Th = rotlH(curH, curL, shift);\n      const Tl = rotlL(curH, curL, shift);\n      const PI = SHA3_PI[t];\n      curH = s[PI];\n      curL = s[PI + 1];\n      s[PI] = Th;\n      s[PI + 1] = Tl;\n    }\n    // Chi ()\n    for (let y = 0; y < 50; y += 10) {\n      for (let x = 0; x < 10; x++) B[x] = s[y + x];\n      for (let x = 0; x < 10; x++) s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];\n    }\n    // Iota ()\n    s[0] ^= SHA3_IOTA_H[round];\n    s[1] ^= SHA3_IOTA_L[round];\n  }\n  clean(B);\n}\n\n/** Keccak sponge function. */\nexport class Keccak extends Hash<Keccak> implements HashXOF<Keccak> {\n  protected state: Uint8Array;\n  protected pos = 0;\n  protected posOut = 0;\n  protected finished = false;\n  protected state32: Uint32Array;\n  protected destroyed = false;\n\n  public blockLen: number;\n  public suffix: number;\n  public outputLen: number;\n  protected enableXOF = false;\n  protected rounds: number;\n\n  // NOTE: we accept arguments in bytes instead of bits here.\n  constructor(\n    blockLen: number,\n    suffix: number,\n    outputLen: number,\n    enableXOF = false,\n    rounds: number = 24\n  ) {\n    super();\n    this.blockLen = blockLen;\n    this.suffix = suffix;\n    this.outputLen = outputLen;\n    this.enableXOF = enableXOF;\n    this.rounds = rounds;\n    // Can be passed from user as dkLen\n    anumber(outputLen);\n    // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes\n    // 0 < blockLen < 200\n    if (!(0 < blockLen && blockLen < 200))\n      throw new Error('only keccak-f1600 function is supported');\n    this.state = new Uint8Array(200);\n    this.state32 = u32(this.state);\n  }\n  clone(): Keccak {\n    return this._cloneInto();\n  }\n  protected keccak(): void {\n    swap32IfBE(this.state32);\n    keccakP(this.state32, this.rounds);\n    swap32IfBE(this.state32);\n    this.posOut = 0;\n    this.pos = 0;\n  }\n  update(data: Input): this {\n    aexists(this);\n    data = toBytes(data);\n    abytes(data);\n    const { blockLen, state } = this;\n    const len = data.length;\n    for (let pos = 0; pos < len; ) {\n      const take = Math.min(blockLen - this.pos, len - pos);\n      for (let i = 0; i < take; i++) state[this.pos++] ^= data[pos++];\n      if (this.pos === blockLen) this.keccak();\n    }\n    return this;\n  }\n  protected finish(): void {\n    if (this.finished) return;\n    this.finished = true;\n    const { state, suffix, pos, blockLen } = this;\n    // Do the padding\n    state[pos] ^= suffix;\n    if ((suffix & 0x80) !== 0 && pos === blockLen - 1) this.keccak();\n    state[blockLen - 1] ^= 0x80;\n    this.keccak();\n  }\n  protected writeInto(out: Uint8Array): Uint8Array {\n    aexists(this, false);\n    abytes(out);\n    this.finish();\n    const bufferOut = this.state;\n    const { blockLen } = this;\n    for (let pos = 0, len = out.length; pos < len; ) {\n      if (this.posOut >= blockLen) this.keccak();\n      const take = Math.min(blockLen - this.posOut, len - pos);\n      out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);\n      this.posOut += take;\n      pos += take;\n    }\n    return out;\n  }\n  xofInto(out: Uint8Array): Uint8Array {\n    // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF\n    if (!this.enableXOF) throw new Error('XOF is not possible for this instance');\n    return this.writeInto(out);\n  }\n  xof(bytes: number): Uint8Array {\n    anumber(bytes);\n    return this.xofInto(new Uint8Array(bytes));\n  }\n  digestInto(out: Uint8Array): Uint8Array {\n    aoutput(out, this);\n    if (this.finished) throw new Error('digest() was already called');\n    this.writeInto(out);\n    this.destroy();\n    return out;\n  }\n  digest(): Uint8Array {\n    return this.digestInto(new Uint8Array(this.outputLen));\n  }\n  destroy(): void {\n    this.destroyed = true;\n    clean(this.state);\n  }\n  _cloneInto(to?: Keccak): Keccak {\n    const { blockLen, suffix, outputLen, rounds, enableXOF } = this;\n    to ||= new Keccak(blockLen, suffix, outputLen, enableXOF, rounds);\n    to.state32.set(this.state32);\n    to.pos = this.pos;\n    to.posOut = this.posOut;\n    to.finished = this.finished;\n    to.rounds = rounds;\n    // Suffix can change in cSHAKE\n    to.suffix = suffix;\n    to.outputLen = outputLen;\n    to.enableXOF = enableXOF;\n    to.destroyed = this.destroyed;\n    return to;\n  }\n}\n\nconst gen = (suffix: number, blockLen: number, outputLen: number) =>\n  createHasher(() => new Keccak(blockLen, suffix, outputLen));\n\n/** SHA3-224 hash function. */\nexport const sha3_224: CHash = /* @__PURE__ */ (() => gen(0x06, 144, 224 / 8))();\n/** SHA3-256 hash function. Different from keccak-256. */\nexport const sha3_256: CHash = /* @__PURE__ */ (() => gen(0x06, 136, 256 / 8))();\n/** SHA3-384 hash function. */\nexport const sha3_384: CHash = /* @__PURE__ */ (() => gen(0x06, 104, 384 / 8))();\n/** SHA3-512 hash function. */\nexport const sha3_512: CHash = /* @__PURE__ */ (() => gen(0x06, 72, 512 / 8))();\n\n/** keccak-224 hash function. */\nexport const keccak_224: CHash = /* @__PURE__ */ (() => gen(0x01, 144, 224 / 8))();\n/** keccak-256 hash function. Different from SHA3-256. */\nexport const keccak_256: CHash = /* @__PURE__ */ (() => gen(0x01, 136, 256 / 8))();\n/** keccak-384 hash function. */\nexport const keccak_384: CHash = /* @__PURE__ */ (() => gen(0x01, 104, 384 / 8))();\n/** keccak-512 hash function. */\nexport const keccak_512: CHash = /* @__PURE__ */ (() => gen(0x01, 72, 512 / 8))();\n\nexport type ShakeOpts = { dkLen?: number };\n\nconst genShake = (suffix: number, blockLen: number, outputLen: number) =>\n  createXOFer<HashXOF<Keccak>, ShakeOpts>(\n    (opts: ShakeOpts = {}) =>\n      new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true)\n  );\n\n/** SHAKE128 XOF with 128-bit security. */\nexport const shake128: CHashXO = /* @__PURE__ */ (() => genShake(0x1f, 168, 128 / 8))();\n/** SHAKE256 XOF with 256-bit security. */\nexport const shake256: CHashXO = /* @__PURE__ */ (() => genShake(0x1f, 136, 256 / 8))();\n","/**\n * Map with a LRU (Least recently used) policy.\n *\n * @link https://en.wikipedia.org/wiki/Cache_replacement_policies#LRU\n */\nexport class LruMap<value = unknown> extends Map<string, value> {\n  maxSize: number\n\n  constructor(size: number) {\n    super()\n    this.maxSize = size\n  }\n\n  override get(key: string) {\n    const value = super.get(key)\n\n    if (super.has(key) && value !== undefined) {\n      this.delete(key)\n      super.set(key, value)\n    }\n\n    return value\n  }\n\n  override set(key: string, value: value) {\n    super.set(key, value)\n    if (this.maxSize && this.size > this.maxSize) {\n      const firstKey = this.keys().next().value\n      if (firstKey) this.delete(firstKey)\n    }\n    return this\n  }\n}\n","import type { Address } from 'abitype'\nimport type { ErrorType } from '../../errors/utils.js'\nimport { LruMap } from '../lru.js'\nimport { checksumAddress } from './getAddress.js'\n\nconst addressRegex = /^0x[a-fA-F0-9]{40}$/\n\n/** @internal */\nexport const isAddressCache = /*#__PURE__*/ new LruMap<boolean>(8192)\n\nexport type IsAddressOptions = {\n  /**\n   * Enables strict mode. Whether or not to compare the address against its checksum.\n   *\n   * @default true\n   */\n  strict?: boolean | undefined\n}\n\nexport type IsAddressErrorType = ErrorType\n\nexport function isAddress(\n  address: string,\n  options?: IsAddressOptions | undefined,\n): address is Address {\n  const { strict = true } = options ?? {}\n  const cacheKey = `${address}.${strict}`\n\n  if (isAddressCache.has(cacheKey)) return isAddressCache.get(cacheKey)!\n\n  const result = (() => {\n    if (!addressRegex.test(address)) return false\n    if (address.toLowerCase() === address) return true\n    if (strict) return checksumAddress(address as Address) === address\n    return true\n  })()\n  isAddressCache.set(cacheKey, result)\n  return result\n}\n","import type { Address } from 'abitype'\n\nimport { InvalidAddressError } from '../../errors/address.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport {\n  type StringToBytesErrorType,\n  stringToBytes,\n} from '../encoding/toBytes.js'\nimport { type Keccak256ErrorType, keccak256 } from '../hash/keccak256.js'\nimport { LruMap } from '../lru.js'\nimport { type IsAddressErrorType, isAddress } from './isAddress.js'\n\nconst checksumAddressCache = /*#__PURE__*/ new LruMap<Address>(8192)\n\nexport type ChecksumAddressErrorType =\n  | Keccak256ErrorType\n  | StringToBytesErrorType\n  | ErrorType\n\nexport function checksumAddress(\n  address_: Address,\n  /**\n   * Warning: EIP-1191 checksum addresses are generally not backwards compatible with the\n   * wider Ethereum ecosystem, meaning it will break when validated against an application/tool\n   * that relies on EIP-55 checksum encoding (checksum without chainId).\n   *\n   * It is highly recommended to not use this feature unless you\n   * know what you are doing.\n   *\n   * See more: https://github.com/ethereum/EIPs/issues/1121\n   */\n  chainId?: number | undefined,\n): Address {\n  if (checksumAddressCache.has(`${address_}.${chainId}`))\n    return checksumAddressCache.get(`${address_}.${chainId}`)!\n\n  const hexAddress = chainId\n    ? `${chainId}${address_.toLowerCase()}`\n    : address_.substring(2).toLowerCase()\n  const hash = keccak256(stringToBytes(hexAddress), 'bytes')\n\n  const address = (\n    chainId ? hexAddress.substring(`${chainId}0x`.length) : hexAddress\n  ).split('')\n  for (let i = 0; i < 40; i += 2) {\n    if (hash[i >> 1] >> 4 >= 8 && address[i]) {\n      address[i] = address[i].toUpperCase()\n    }\n    if ((hash[i >> 1] & 0x0f) >= 8 && address[i + 1]) {\n      address[i + 1] = address[i + 1].toUpperCase()\n    }\n  }\n\n  const result = `0x${address.join('')}` as const\n  checksumAddressCache.set(`${address_}.${chainId}`, result)\n  return result\n}\n\nexport type GetAddressErrorType =\n  | ChecksumAddressErrorType\n  | IsAddressErrorType\n  | ErrorType\n\nexport function getAddress(\n  address: string,\n  /**\n   * Warning: EIP-1191 checksum addresses are generally not backwards compatible with the\n   * wider Ethereum ecosystem, meaning it will break when validated against an application/tool\n   * that relies on EIP-55 checksum encoding (checksum without chainId).\n   *\n   * It is highly recommended to not use this feature unless you\n   * know what you are doing.\n   *\n   * See more: https://github.com/ethereum/EIPs/issues/1121\n   */\n  chainId?: number,\n): Address {\n  if (!isAddress(address, { strict: false }))\n    throw new InvalidAddressError({ address })\n  return checksumAddress(address, chainId)\n}\n","import { keccak_256 } from '@noble/hashes/sha3'\n\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { type IsHexErrorType, isHex } from '../data/isHex.js'\nimport { type ToBytesErrorType, toBytes } from '../encoding/toBytes.js'\nimport { type ToHexErrorType, toHex } from '../encoding/toHex.js'\n\ntype To = 'hex' | 'bytes'\n\nexport type Keccak256Hash<to extends To> =\n  | (to extends 'bytes' ? ByteArray : never)\n  | (to extends 'hex' ? Hex : never)\n\nexport type Keccak256ErrorType =\n  | IsHexErrorType\n  | ToBytesErrorType\n  | ToHexErrorType\n  | ErrorType\n\nexport function keccak256<to extends To = 'hex'>(\n  value: Hex | ByteArray,\n  to_?: to | undefined,\n): Keccak256Hash<to> {\n  const to = to_ || 'hex'\n  const bytes = keccak_256(\n    isHex(value, { strict: false }) ? toBytes(value) : value,\n  )\n  if (to === 'bytes') return bytes as Keccak256Hash<to>\n  return toHex(bytes) as Keccak256Hash<to>\n}\n","import { PaymentPayload, PaymentRequirements, SchemeNetworkClient } from \"@x402/core/types\";\nimport { getAddress } from \"viem\";\nimport { authorizationTypes } from \"../../constants\";\nimport { ClientEvmSigner } from \"../../signer\";\nimport { ExactEvmPayloadV2 } from \"../../types\";\nimport { createNonce } from \"../../utils\";\n\n/**\n * EVM client implementation for the Exact payment scheme.\n *\n */\nexport class ExactEvmScheme implements SchemeNetworkClient {\n  readonly scheme = \"exact\";\n\n  /**\n   * Creates a new ExactEvmClient instance.\n   *\n   * @param signer - The EVM signer for client operations\n   */\n  constructor(private readonly signer: ClientEvmSigner) {}\n\n  /**\n   * Creates a payment payload for the Exact scheme.\n   *\n   * @param x402Version - The x402 protocol version\n   * @param paymentRequirements - The payment requirements\n   * @returns Promise resolving to a payment payload\n   */\n  async createPaymentPayload(\n    x402Version: number,\n    paymentRequirements: PaymentRequirements,\n  ): Promise<Pick<PaymentPayload, \"x402Version\" | \"payload\">> {\n    const nonce = createNonce();\n    const now = Math.floor(Date.now() / 1000);\n\n    const authorization: ExactEvmPayloadV2[\"authorization\"] = {\n      from: this.signer.address,\n      to: getAddress(paymentRequirements.payTo),\n      value: paymentRequirements.amount,\n      validAfter: (now - 600).toString(), // 10 minutes before\n      validBefore: (now + paymentRequirements.maxTimeoutSeconds).toString(),\n      nonce,\n    };\n\n    // Sign the authorization\n    const signature = await this.signAuthorization(authorization, paymentRequirements);\n\n    const payload: ExactEvmPayloadV2 = {\n      authorization,\n      signature,\n    };\n\n    return {\n      x402Version,\n      payload,\n    };\n  }\n\n  /**\n   * Sign the EIP-3009 authorization using EIP-712\n   *\n   * @param authorization - The authorization to sign\n   * @param requirements - The payment requirements\n   * @returns Promise resolving to the signature\n   */\n  private async signAuthorization(\n    authorization: ExactEvmPayloadV2[\"authorization\"],\n    requirements: PaymentRequirements,\n  ): Promise<`0x${string}`> {\n    const chainId = parseInt(requirements.network.split(\":\")[1]);\n\n    if (!requirements.extra?.name || !requirements.extra?.version) {\n      throw new Error(\n        `EIP-712 domain parameters (name, version) are required in payment requirements for asset ${requirements.asset}`,\n      );\n    }\n\n    const { name, version } = requirements.extra;\n\n    const domain = {\n      name,\n      version,\n      chainId,\n      verifyingContract: getAddress(requirements.asset),\n    };\n\n    const message = {\n      from: getAddress(authorization.from),\n      to: getAddress(authorization.to),\n      value: BigInt(authorization.value),\n      validAfter: BigInt(authorization.validAfter),\n      validBefore: BigInt(authorization.validBefore),\n      nonce: authorization.nonce,\n    };\n\n    return await this.signer.signTypedData({\n      domain,\n      types: authorizationTypes,\n      primaryType: \"TransferWithAuthorization\",\n      message,\n    });\n  }\n}\n","export { ExactEvmSchemeV1 } from \"../exact/v1\";\n\nexport const NETWORKS: string[] = [\n  \"abstract\",\n  \"abstract-testnet\",\n  \"base-sepolia\",\n  \"base\",\n  \"avalanche-fuji\",\n  \"avalanche\",\n  \"iotex\",\n  \"sei\",\n  \"sei-testnet\",\n  \"polygon\",\n  \"polygon-amoy\",\n  \"peaq\",\n  \"story\",\n  \"educhain\",\n  \"skale-base-sepolia\",\n];\n","import {\n  Network,\n  PaymentPayload,\n  PaymentRequirements,\n  SchemeNetworkClient,\n} from \"@x402/core/types\";\nimport { PaymentRequirementsV1 } from \"@x402/core/types/v1\";\nimport { getAddress } from \"viem\";\nimport { authorizationTypes } from \"../../../constants\";\nimport { ClientEvmSigner } from \"../../../signer\";\nimport { ExactEvmPayloadV1 } from \"../../../types\";\nimport { createNonce, getEvmChainId } from \"../../../utils\";\n\n/**\n * EVM client implementation for the Exact payment scheme (V1).\n */\nexport class ExactEvmSchemeV1 implements SchemeNetworkClient {\n  readonly scheme = \"exact\";\n\n  /**\n   * Creates a new ExactEvmClientV1 instance.\n   *\n   * @param signer - The EVM signer for client operations\n   */\n  constructor(private readonly signer: ClientEvmSigner) {}\n\n  /**\n   * Creates a payment payload for the Exact scheme (V1).\n   *\n   * @param x402Version - The x402 protocol version\n   * @param paymentRequirements - The payment requirements\n   * @returns Promise resolving to a payment payload\n   */\n  async createPaymentPayload(\n    x402Version: number,\n    paymentRequirements: PaymentRequirements,\n  ): Promise<\n    Pick<PaymentPayload, \"x402Version\" | \"payload\"> & { scheme: string; network: Network }\n  > {\n    const selectedV1 = paymentRequirements as unknown as PaymentRequirementsV1;\n    const nonce = createNonce();\n    const now = Math.floor(Date.now() / 1000);\n\n    const authorization: ExactEvmPayloadV1[\"authorization\"] = {\n      from: this.signer.address,\n      to: getAddress(selectedV1.payTo),\n      value: selectedV1.maxAmountRequired,\n      validAfter: (now - 600).toString(), // 10 minutes before\n      validBefore: (now + selectedV1.maxTimeoutSeconds).toString(),\n      nonce,\n    };\n\n    // Sign the authorization\n    const signature = await this.signAuthorization(authorization, selectedV1);\n\n    const payload: ExactEvmPayloadV1 = {\n      authorization,\n      signature,\n    };\n\n    return {\n      x402Version,\n      scheme: selectedV1.scheme,\n      network: selectedV1.network,\n      payload,\n    };\n  }\n\n  /**\n   * Sign the EIP-3009 authorization using EIP-712\n   *\n   * @param authorization - The authorization to sign\n   * @param requirements - The payment requirements\n   * @returns Promise resolving to the signature\n   */\n  private async signAuthorization(\n    authorization: ExactEvmPayloadV1[\"authorization\"],\n    requirements: PaymentRequirementsV1,\n  ): Promise<`0x${string}`> {\n    const chainId = getEvmChainId(requirements.network);\n\n    if (!requirements.extra?.name || !requirements.extra?.version) {\n      throw new Error(\n        `EIP-712 domain parameters (name, version) are required in payment requirements for asset ${requirements.asset}`,\n      );\n    }\n\n    const { name, version } = requirements.extra;\n\n    const domain = {\n      name,\n      version,\n      chainId,\n      verifyingContract: getAddress(requirements.asset),\n    };\n\n    const message = {\n      from: getAddress(authorization.from),\n      to: getAddress(authorization.to),\n      value: BigInt(authorization.value),\n      validAfter: BigInt(authorization.validAfter),\n      validBefore: BigInt(authorization.validBefore),\n      nonce: authorization.nonce,\n    };\n\n    return await this.signer.signTypedData({\n      domain,\n      types: authorizationTypes,\n      primaryType: \"TransferWithAuthorization\",\n      message,\n    });\n  }\n}\n","import { x402Client, SelectPaymentRequirements, PaymentPolicy } from \"@x402/core/client\";\nimport { Network } from \"@x402/core/types\";\nimport { ClientEvmSigner } from \"../../signer\";\nimport { ExactEvmScheme } from \"./scheme\";\nimport { ExactEvmSchemeV1 } from \"../v1/client/scheme\";\nimport { NETWORKS } from \"../../v1\";\n\n/**\n * Configuration options for registering EVM schemes to an x402Client\n */\nexport interface EvmClientConfig {\n  /**\n   * The EVM signer to use for creating payment payloads\n   */\n  signer: ClientEvmSigner;\n\n  /**\n   * Optional payment requirements selector function\n   * If not provided, uses the default selector (first available option)\n   */\n  paymentRequirementsSelector?: SelectPaymentRequirements;\n\n  /**\n   * Optional policies to apply to the client\n   */\n  policies?: PaymentPolicy[];\n\n  /**\n   * Optional specific networks to register\n   * If not provided, registers wildcard support (eip155:*)\n   */\n  networks?: Network[];\n}\n\n/**\n * Registers EVM exact payment schemes to an x402Client instance.\n *\n * This function registers:\n * - V2: eip155:* wildcard scheme with ExactEvmScheme (or specific networks if provided)\n * - V1: All supported EVM networks with ExactEvmSchemeV1\n *\n * @param client - The x402Client instance to register schemes to\n * @param config - Configuration for EVM client registration\n * @returns The client instance for chaining\n *\n * @example\n * ```typescript\n * import { registerExactEvmScheme } from \"@x402/evm/exact/client/register\";\n * import { x402Client } from \"@x402/core/client\";\n * import { privateKeyToAccount } from \"viem/accounts\";\n *\n * const account = privateKeyToAccount(\"0x...\");\n * const client = new x402Client();\n * registerExactEvmScheme(client, { signer: account });\n * ```\n */\nexport function registerExactEvmScheme(client: x402Client, config: EvmClientConfig): x402Client {\n  // Register V2 scheme\n  if (config.networks && config.networks.length > 0) {\n    // Register specific networks\n    config.networks.forEach(network => {\n      client.register(network, new ExactEvmScheme(config.signer));\n    });\n  } else {\n    // Register wildcard for all EVM chains\n    client.register(\"eip155:*\", new ExactEvmScheme(config.signer));\n  }\n\n  // Register all V1 networks\n  NETWORKS.forEach(network => {\n    client.registerV1(network as Network, new ExactEvmSchemeV1(config.signer));\n  });\n\n  // Apply policies if provided\n  if (config.policies) {\n    config.policies.forEach(policy => {\n      client.registerPolicy(policy);\n    });\n  }\n\n  return client;\n}\n"],"names":["version","errorConfig","getDocsUrl","_ref","docsBaseUrl","docsPath","docsSlug","concat","undefined","BaseError","Error","constructor","shortMessage","_errorConfig$getDocsU","_errorConfig","_args$name","args","arguments","length","details","cause","_args$cause","message","docsUrl","call","_objectSpread","super","metaMessages","join","Object","defineProperty","this","name","walk","fn","err","IntegerOutOfRangeError","max","min","signed","size","value","SizeOverflowError","_ref2","givenSize","maxSize","SizeExceedsPaddingSizeError","targetSize","type","charAt","toUpperCase","slice","toLowerCase","pad","hexOrBytes","dir","hex_","hex","replace","Math","ceil","padHex","bytes","paddedBytes","Uint8Array","i","padEnd","padBytes","isHex","strict","test","startsWith","assertSize","size_","hexes","Array","from","_v","toString","padStart","toHex","opts","numberToHex","value_","encoder","encode","bytesToHex","stringToHex","Number","boolToHex","string","BigInt","maxValue","MAX_SAFE_INTEGER","minValue","suffix","TextEncoder","authorizationTypes","TransferWithAuthorization","createNonce","cryptoObj","globalThis","crypto","getRandomValues","InvalidAddressError","address","toBytes","hexToBytes","numberToBytes","boolToBytes","stringToBytes","charCodeMap","charCodeToBase16","char","hexString","index","j","nibbleLeft","charCodeAt","nibbleRight","U32_MASK64","_32n","fromBig","n","h","l","split","lst","le","len","Ah","Uint32Array","Al","rotlSH","s","rotlSL","rotlBH","rotlBL","anumber","isSafeInteger","abytes","b","a","ArrayBuffer","isView","_len","lengths","_key","includes","aexists","instance","checkFinished","destroyed","finished","clean","_len2","arrays","_key2","fill","isLE","buffer","byteSwap","word","swap32IfBE","u","arr","utf8ToBytes","str","data","Hash","createHasher","hashCons","hashC","msg","update","digest","tmp","outputLen","blockLen","create","_0n","_1n","_2n","_7n","_256n","_0x71n","SHA3_PI","SHA3_ROTL","_SHA3_IOTA","round","R","x","y","push","t","IOTAS","SHA3_IOTA_H","SHA3_IOTA_L","rotlH","rotlL","Keccak","enableXOF","rounds","pos","posOut","state","state32","byteOffset","floor","byteLength","clone","_cloneInto","keccak","B","idx1","idx0","B0","B1","Th","Tl","curH","curL","shift","PI","keccakP","take","finish","writeInto","out","bufferOut","set","subarray","xofInto","xof","digestInto","aoutput","destroy","to","gen","keccak_256","LruMap","Map","get","key","has","delete","firstKey","keys","next","addressRegex","isAddressCache","checksumAddressCache","checksumAddress","address_","chainId","hexAddress","substring","hash","to_","keccak256","result","getAddress","options","cacheKey","isAddress","ExactEvmScheme","signer","scheme","createPaymentPayload","x402Version","paymentRequirements","nonce","now","Date","authorization","payTo","amount","validAfter","validBefore","maxTimeoutSeconds","payload","signature","signAuthorization","requirements","_requirements$extra","_requirements$extra2","parseInt","network","extra","asset","domain","verifyingContract","signTypedData","types","primaryType","NETWORKS","ExactEvmSchemeV1","selectedV1","maxAmountRequired","base","ethereum","sepolia","polygon","registerExactEvmScheme","client","config","networks","forEach","register","registerV1","policies","policy","registerPolicy"],"ignoreList":[],"sourceRoot":""}