{"version":3,"file":"static/js/28.e4fab9aa.chunk.js","mappings":"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","sources":["../../../src/wordlists/czech.ts","../../../src/wordlists/english.ts","../../../src/wordlists/french.ts","../../../src/wordlists/italian.ts","../../../src/wordlists/japanese.ts","../../../src/wordlists/korean.ts","../../../src/wordlists/simplified-chinese.ts","../../../src/wordlists/spanish.ts","../../../src/wordlists/traditional-chinese.ts","../node_modules/viem/node_modules/@noble/hashes/src/_assert.ts","../node_modules/viem/node_modules/@noble/hashes/src/crypto.ts","../node_modules/viem/node_modules/@noble/hashes/src/utils.ts","../node_modules/viem/node_modules/@noble/hashes/src/_sha2.ts","../node_modules/viem/node_modules/@noble/hashes/src/sha256.ts","../node_modules/viem/node_modules/@noble/curves/src/abstract/utils.ts","../node_modules/viem/node_modules/@noble/curves/src/abstract/modular.ts","../node_modules/viem/node_modules/@noble/hashes/src/hmac.ts","../node_modules/viem/node_modules/@noble/curves/src/abstract/curve.ts","../node_modules/viem/node_modules/@noble/curves/src/abstract/weierstrass.ts","../node_modules/viem/node_modules/@noble/curves/src/_shortw_utils.ts","../node_modules/viem/node_modules/@noble/curves/src/secp256k1.ts","../node_modules/viem/errors/base.ts","../node_modules/viem/errors/utils.ts","../node_modules/viem/errors/version.ts","../node_modules/viem/errors/encoding.ts","../node_modules/viem/errors/data.ts","../node_modules/viem/utils/data/pad.ts","../node_modules/viem/utils/data/isHex.ts","../node_modules/viem/utils/data/size.ts","../node_modules/viem/utils/encoding/fromHex.ts","../node_modules/viem/utils/encoding/toHex.ts","../node_modules/viem/errors/address.ts","../node_modules/viem/utils/address/isAddress.ts","../node_modules/viem/utils/encoding/toBytes.ts","../node_modules/viem/node_modules/@noble/hashes/src/_u64.ts","../node_modules/viem/node_modules/@noble/hashes/src/sha3.ts","../node_modules/viem/utils/hash/keccak256.ts","../node_modules/viem/utils/address/getAddress.ts","../node_modules/viem/utils/data/concat.ts","../node_modules/viem/utils/signature/hashMessage.ts","../node_modules/viem/constants/strings.ts","../node_modules/viem/utils/signature/signatureToHex.ts","../node_modules/viem/accounts/utils/sign.ts","../node_modules/viem/constants/unit.ts","../node_modules/viem/utils/unit/formatUnits.ts","../node_modules/viem/utils/unit/formatGwei.ts","../node_modules/viem/errors/transaction.ts","../node_modules/viem/utils/data/trim.ts","../node_modules/viem/errors/cursor.ts","../node_modules/viem/utils/cursor.ts","../node_modules/viem/utils/encoding/toRlp.ts","../node_modules/viem/errors/chain.ts","../node_modules/viem/errors/node.ts","../node_modules/viem/utils/transaction/serializeAccessList.ts","../node_modules/viem/utils/transaction/serializeTransaction.ts","../node_modules/viem/utils/transaction/getTransactionType.ts","../node_modules/viem/utils/transaction/assertTransaction.ts","../node_modules/viem/errors/abi.ts","../node_modules/viem/utils/data/slice.ts","../node_modules/viem/utils/abi/encodeAbiParameters.ts","../node_modules/viem/utils/regex.ts","../node_modules/viem/utils/typedData.ts","../node_modules/viem/utils/signature/hashTypedData.ts","../node_modules/viem/accounts/privateKeyToAccount.ts","../node_modules/viem/accounts/utils/publicKeyToAddress.ts","../node_modules/viem/accounts/toAccount.ts","../node_modules/viem/accounts/utils/signMessage.ts","../node_modules/viem/accounts/utils/signTransaction.ts","../node_modules/viem/accounts/utils/signTypedData.ts"],"sourcesContent":[null,null,null,null,null,null,null,null,null,"function number(n: number) {\n  if (!Number.isSafeInteger(n) || n < 0) throw new Error(`Wrong positive integer: ${n}`);\n}\n\nfunction bool(b: boolean) {\n  if (typeof b !== 'boolean') throw new Error(`Expected boolean, not ${b}`);\n}\n\nfunction bytes(b: Uint8Array | undefined, ...lengths: number[]) {\n  if (!(b instanceof Uint8Array)) throw new Error('Expected Uint8Array');\n  if (lengths.length > 0 && !lengths.includes(b.length))\n    throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);\n}\n\ntype Hash = {\n  (data: Uint8Array): Uint8Array;\n  blockLen: number;\n  outputLen: number;\n  create: any;\n};\nfunction hash(hash: Hash) {\n  if (typeof hash !== 'function' || typeof hash.create !== 'function')\n    throw new Error('Hash should be wrapped by utils.wrapConstructor');\n  number(hash.outputLen);\n  number(hash.blockLen);\n}\n\nfunction exists(instance: any, checkFinished = true) {\n  if (instance.destroyed) throw new Error('Hash instance has been destroyed');\n  if (checkFinished && instance.finished) throw new Error('Hash#digest() has already been called');\n}\nfunction output(out: any, instance: any) {\n  bytes(out);\n  const min = instance.outputLen;\n  if (out.length < min) {\n    throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n  }\n}\n\nexport { number, bool, bytes, hash, exists, output };\n\nconst assert = { number, bool, bytes, hash, exists, output };\nexport default assert;\n","// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// See utils.ts for details.\ndeclare const globalThis: Record<string, any> | undefined;\nexport const crypto =\n  typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;\n","/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated, we can just drop the import.\nimport { crypto } from '@noble/hashes/crypto';\n\n// prettier-ignore\nexport type TypedArray = Int8Array | Uint8ClampedArray | Uint8Array |\n  Uint16Array | Int16Array | Uint32Array | Int32Array;\n\nconst u8a = (a: any): a is Uint8Array => a instanceof Uint8Array;\n// Cast array to different type\nexport const u8 = (arr: TypedArray) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nexport const u32 = (arr: TypedArray) =>\n  new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n\n// Cast array to view\nexport const createView = (arr: TypedArray) =>\n  new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n\n// The rotate right (circular right shift) operation for uint32\nexport const rotr = (word: number, shift: number) => (word << (32 - shift)) | (word >>> shift);\n\n// big-endian hardware is rare. Just in case someone still decides to run hashes:\n// early-throw an error because we don't support BE yet.\nexport const isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\nif (!isLE) throw new Error('Non little-endian hardware is not supported');\n\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) =>\n  i.toString(16).padStart(2, '0')\n);\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes: Uint8Array): string {\n  if (!u8a(bytes)) throw new Error('Uint8Array expected');\n  // pre-caching improves the speed 6x\n  let hex = '';\n  for (let i = 0; i < bytes.length; i++) {\n    hex += hexes[bytes[i]];\n  }\n  return hex;\n}\n\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex: string): Uint8Array {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  const len = hex.length;\n  if (len % 2) throw new Error('padded hex string expected, got unpadded hex of length ' + len);\n  const array = new Uint8Array(len / 2);\n  for (let i = 0; i < array.length; i++) {\n    const j = i * 2;\n    const hexByte = hex.slice(j, j + 2);\n    const byte = Number.parseInt(hexByte, 16);\n    if (Number.isNaN(byte) || byte < 0) throw new Error('Invalid byte sequence');\n    array[i] = byte;\n  }\n  return array;\n}\n\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nexport const nextTick = async () => {};\n\n// Returns control to thread each 'tick' ms to avoid blocking\nexport async function asyncLoop(iters: number, tick: number, cb: (i: number) => void) {\n  let ts = Date.now();\n  for (let i = 0; i < iters; i++) {\n    cb(i);\n    // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n    const diff = Date.now() - ts;\n    if (diff >= 0 && diff < tick) continue;\n    await nextTick();\n    ts += diff;\n  }\n}\n\n// Global symbols in both browsers and Node.js since v11\n// See https://github.com/microsoft/TypeScript/issues/31535\ndeclare const TextEncoder: any;\n\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nexport function utf8ToBytes(str: string): Uint8Array {\n  if (typeof str !== 'string') throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n  return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n\nexport type Input = Uint8Array | string;\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nexport function toBytes(data: Input): Uint8Array {\n  if (typeof data === 'string') data = utf8ToBytes(data);\n  if (!u8a(data)) throw new Error(`expected Uint8Array, got ${typeof data}`);\n  return data;\n}\n\n/**\n * Copies several Uint8Arrays into one.\n */\nexport function concatBytes(...arrays: Uint8Array[]): Uint8Array {\n  const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));\n  let pad = 0; // walk through each item, ensure they have proper type\n  arrays.forEach((a) => {\n    if (!u8a(a)) throw new Error('Uint8Array expected');\n    r.set(a, pad);\n    pad += a.length;\n  });\n  return r;\n}\n\n// For runtime check if class implements interface\nexport abstract class Hash<T extends Hash<T>> {\n  abstract blockLen: number; // Bytes per block\n  abstract outputLen: number; // Bytes in output\n  abstract update(buf: Input): this;\n  // Writes digest into buf\n  abstract digestInto(buf: Uint8Array): void;\n  abstract digest(): Uint8Array;\n  /**\n   * Resets internal state. Makes Hash instance unusable.\n   * Reset is impossible for keyed hashes if key is consumed into state. If digest is not consumed\n   * by user, they will need to manually call `destroy()` when zeroing is necessary.\n   */\n  abstract destroy(): void;\n  /**\n   * Clones hash instance. Unsafe: doesn't check whether `to` is valid. Can be used as `clone()`\n   * when no options are passed.\n   * Reasons to use `_cloneInto` instead of clone: 1) performance 2) reuse instance => all internal\n   * buffers are overwritten => causes buffer overwrite which is used for digest in some cases.\n   * There are no guarantees for clean-up because it's impossible in JS.\n   */\n  abstract _cloneInto(to?: T): T;\n  // Safe version that clones internal state\n  clone(): T {\n    return this._cloneInto();\n  }\n}\n\n/**\n * XOF: streaming API to read digest in chunks.\n * Same as 'squeeze' in keccak/k12 and 'seek' in blake3, but more generic name.\n * When hash used in XOF mode it is up to user to call '.destroy' afterwards, since we cannot\n * destroy state, next call can require more bytes.\n */\nexport type HashXOF<T extends Hash<T>> = Hash<T> & {\n  xof(bytes: number): Uint8Array; // Read 'bytes' bytes from digest stream\n  xofInto(buf: Uint8Array): Uint8Array; // read buf.length bytes from digest stream into buf\n};\n\nconst toStr = {}.toString;\ntype EmptyObj = {};\nexport function checkOpts<T1 extends EmptyObj, T2 extends EmptyObj>(\n  defaults: T1,\n  opts?: T2\n): T1 & T2 {\n  if (opts !== undefined && toStr.call(opts) !== '[object Object]')\n    throw new Error('Options should be object or undefined');\n  const merged = Object.assign(defaults, opts);\n  return merged as T1 & T2;\n}\n\nexport type CHash = ReturnType<typeof wrapConstructor>;\n\nexport function wrapConstructor<T extends Hash<T>>(hashCons: () => Hash<T>) {\n  const hashC = (msg: Input): Uint8Array => hashCons().update(toBytes(msg)).digest();\n  const tmp = hashCons();\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = () => hashCons();\n  return hashC;\n}\n\nexport function wrapConstructorWithOpts<H extends Hash<H>, T extends Object>(\n  hashCons: (opts?: T) => Hash<H>\n) {\n  const hashC = (msg: Input, opts?: T): Uint8Array => hashCons(opts).update(toBytes(msg)).digest();\n  const tmp = hashCons({} as T);\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = (opts: T) => hashCons(opts);\n  return hashC;\n}\n\nexport function wrapXOFConstructorWithOpts<H extends HashXOF<H>, T extends Object>(\n  hashCons: (opts?: T) => HashXOF<H>\n) {\n  const hashC = (msg: Input, opts?: T): Uint8Array => hashCons(opts).update(toBytes(msg)).digest();\n  const tmp = hashCons({} as T);\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = (opts: T) => hashCons(opts);\n  return hashC;\n}\n\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */\nexport function randomBytes(bytesLength = 32): Uint8Array {\n  if (crypto && typeof crypto.getRandomValues === 'function') {\n    return crypto.getRandomValues(new Uint8Array(bytesLength));\n  }\n  throw new Error('crypto.getRandomValues must be defined');\n}\n","import { exists, output } from './_assert.js';\nimport { Hash, createView, Input, toBytes } from './utils.js';\n\n// Polyfill for Safari 14\nfunction setBigUint64(view: DataView, byteOffset: number, value: bigint, isLE: boolean): void {\n  if (typeof view.setBigUint64 === 'function') return view.setBigUint64(byteOffset, value, isLE);\n  const _32n = BigInt(32);\n  const _u32_max = BigInt(0xffffffff);\n  const wh = Number((value >> _32n) & _u32_max);\n  const wl = Number(value & _u32_max);\n  const h = isLE ? 4 : 0;\n  const l = isLE ? 0 : 4;\n  view.setUint32(byteOffset + h, wh, isLE);\n  view.setUint32(byteOffset + l, wl, isLE);\n}\n\n// Base SHA2 class (RFC 6234)\nexport abstract class SHA2<T extends SHA2<T>> extends Hash<T> {\n  protected abstract process(buf: DataView, offset: number): void;\n  protected abstract get(): number[];\n  protected abstract set(...args: number[]): void;\n  abstract destroy(): void;\n  protected abstract roundClean(): void;\n  // For partial updates less than block size\n  protected buffer: Uint8Array;\n  protected view: DataView;\n  protected finished = false;\n  protected length = 0;\n  protected pos = 0;\n  protected destroyed = false;\n\n  constructor(\n    readonly blockLen: number,\n    public outputLen: number,\n    readonly padOffset: number,\n    readonly isLE: boolean\n  ) {\n    super();\n    this.buffer = new Uint8Array(blockLen);\n    this.view = createView(this.buffer);\n  }\n  update(data: Input): this {\n    exists(this);\n    const { view, buffer, blockLen } = this;\n    data = toBytes(data);\n    const len = data.length;\n    for (let pos = 0; pos < len; ) {\n      const take = Math.min(blockLen - this.pos, len - pos);\n      // Fast path: we have at least one block in input, cast it to view and process\n      if (take === blockLen) {\n        const dataView = createView(data);\n        for (; blockLen <= len - pos; pos += blockLen) this.process(dataView, pos);\n        continue;\n      }\n      buffer.set(data.subarray(pos, pos + take), this.pos);\n      this.pos += take;\n      pos += take;\n      if (this.pos === blockLen) {\n        this.process(view, 0);\n        this.pos = 0;\n      }\n    }\n    this.length += data.length;\n    this.roundClean();\n    return this;\n  }\n  digestInto(out: Uint8Array) {\n    exists(this);\n    output(out, this);\n    this.finished = true;\n    // Padding\n    // We can avoid allocation of buffer for padding completely if it\n    // was previously not allocated here. But it won't change performance.\n    const { buffer, view, blockLen, isLE } = this;\n    let { pos } = this;\n    // append the bit '1' to the message\n    buffer[pos++] = 0b10000000;\n    this.buffer.subarray(pos).fill(0);\n    // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again\n    if (this.padOffset > blockLen - pos) {\n      this.process(view, 0);\n      pos = 0;\n    }\n    // Pad until full block byte with zeros\n    for (let i = pos; i < blockLen; i++) buffer[i] = 0;\n    // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n    // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n    // So we just write lowest 64 bits of that value.\n    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n    this.process(view, 0);\n    const oview = createView(out);\n    const len = this.outputLen;\n    // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n    if (len % 4) throw new Error('_sha2: outputLen should be aligned to 32bit');\n    const outLen = len / 4;\n    const state = this.get();\n    if (outLen > state.length) throw new Error('_sha2: outputLen bigger than state');\n    for (let i = 0; i < outLen; i++) oview.setUint32(4 * i, state[i], isLE);\n  }\n  digest() {\n    const { buffer, outputLen } = this;\n    this.digestInto(buffer);\n    const res = buffer.slice(0, outputLen);\n    this.destroy();\n    return res;\n  }\n  _cloneInto(to?: T): T {\n    to ||= new (this.constructor as any)() as T;\n    to.set(...this.get());\n    const { blockLen, buffer, length, finished, destroyed, pos } = this;\n    to.length = length;\n    to.pos = pos;\n    to.finished = finished;\n    to.destroyed = destroyed;\n    if (length % blockLen) to.buffer.set(buffer);\n    return to;\n  }\n}\n","import { SHA2 } from './_sha2.js';\nimport { rotr, wrapConstructor } from './utils.js';\n\n// SHA2-256 need to try 2^128 hashes to execute birthday attack.\n// BTC network is doing 2^67 hashes/sec as per early 2023.\n\n// Choice: a ? b : c\nconst Chi = (a: number, b: number, c: number) => (a & b) ^ (~a & c);\n// Majority function, true if any two inpust is true\nconst Maj = (a: number, b: number, c: number) => (a & b) ^ (a & c) ^ (b & c);\n\n// Round constants:\n// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */new Uint32Array([\n  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n\n// Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n// prettier-ignore\nconst IV = /* @__PURE__ */new Uint32Array([\n  0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n]);\n\n// Temporary buffer, not used to store anything between runs\n// Named this way because it matches specification.\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nclass SHA256 extends SHA2<SHA256> {\n  // We cannot use array here since array allows indexing by variable\n  // which means optimizer/compiler cannot use registers.\n  A = IV[0] | 0;\n  B = IV[1] | 0;\n  C = IV[2] | 0;\n  D = IV[3] | 0;\n  E = IV[4] | 0;\n  F = IV[5] | 0;\n  G = IV[6] | 0;\n  H = IV[7] | 0;\n\n  constructor() {\n    super(64, 32, 8, false);\n  }\n  protected get(): [number, number, number, number, number, number, number, number] {\n    const { A, B, C, D, E, F, G, H } = this;\n    return [A, B, C, D, E, F, G, H];\n  }\n  // prettier-ignore\n  protected set(\n    A: number, B: number, C: number, D: number, E: number, F: number, G: number, H: number\n  ) {\n    this.A = A | 0;\n    this.B = B | 0;\n    this.C = C | 0;\n    this.D = D | 0;\n    this.E = E | 0;\n    this.F = F | 0;\n    this.G = G | 0;\n    this.H = H | 0;\n  }\n  protected process(view: DataView, offset: number): void {\n    // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n    for (let i = 0; i < 16; i++, offset += 4) SHA256_W[i] = view.getUint32(offset, false);\n    for (let i = 16; i < 64; i++) {\n      const W15 = SHA256_W[i - 15];\n      const W2 = SHA256_W[i - 2];\n      const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ (W15 >>> 3);\n      const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ (W2 >>> 10);\n      SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n    }\n    // Compression function main loop, 64 rounds\n    let { A, B, C, D, E, F, G, H } = this;\n    for (let i = 0; i < 64; i++) {\n      const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);\n      const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n      const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);\n      const T2 = (sigma0 + Maj(A, B, C)) | 0;\n      H = G;\n      G = F;\n      F = E;\n      E = (D + T1) | 0;\n      D = C;\n      C = B;\n      B = A;\n      A = (T1 + T2) | 0;\n    }\n    // Add the compressed chunk to the current hash value\n    A = (A + this.A) | 0;\n    B = (B + this.B) | 0;\n    C = (C + this.C) | 0;\n    D = (D + this.D) | 0;\n    E = (E + this.E) | 0;\n    F = (F + this.F) | 0;\n    G = (G + this.G) | 0;\n    H = (H + this.H) | 0;\n    this.set(A, B, C, D, E, F, G, H);\n  }\n  protected roundClean() {\n    SHA256_W.fill(0);\n  }\n  destroy() {\n    this.set(0, 0, 0, 0, 0, 0, 0, 0);\n    this.buffer.fill(0);\n  }\n}\n// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf\nclass SHA224 extends SHA256 {\n  A = 0xc1059ed8 | 0;\n  B = 0x367cd507 | 0;\n  C = 0x3070dd17 | 0;\n  D = 0xf70e5939 | 0;\n  E = 0xffc00b31 | 0;\n  F = 0x68581511 | 0;\n  G = 0x64f98fa7 | 0;\n  H = 0xbefa4fa4 | 0;\n  constructor() {\n    super();\n    this.outputLen = 28;\n  }\n}\n\n/**\n * SHA2-256 hash function\n * @param message - data that would be hashed\n */\nexport const sha256 = /* @__PURE__ */ wrapConstructor(() => new SHA256());\nexport const sha224 = /* @__PURE__ */ wrapConstructor(() => new SHA224());\n","/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// 100 lines of code in the file are duplicated from noble-hashes (utils).\n// This is OK: `abstract` directory does not use noble-hashes.\n// User may opt-in into using different hashing library. This way, noble-hashes\n// won't be included into their bundle.\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst u8a = (a: any): a is Uint8Array => a instanceof Uint8Array;\nexport type Hex = Uint8Array | string; // hex strings are accepted for simplicity\nexport type PrivKey = Hex | bigint; // bigints are accepted to ease learning curve\nexport type CHash = {\n  (message: Uint8Array | string): Uint8Array;\n  blockLen: number;\n  outputLen: number;\n  create(opts?: { dkLen?: number }): any; // For shake\n};\nexport type FHash = (message: Uint8Array | string) => Uint8Array;\n\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) =>\n  i.toString(16).padStart(2, '0')\n);\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes: Uint8Array): string {\n  if (!u8a(bytes)) throw new Error('Uint8Array expected');\n  // pre-caching improves the speed 6x\n  let hex = '';\n  for (let i = 0; i < bytes.length; i++) {\n    hex += hexes[bytes[i]];\n  }\n  return hex;\n}\n\nexport function numberToHexUnpadded(num: number | bigint): string {\n  const hex = num.toString(16);\n  return hex.length & 1 ? `0${hex}` : hex;\n}\n\nexport function hexToNumber(hex: string): bigint {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  // Big Endian\n  return BigInt(hex === '' ? '0' : `0x${hex}`);\n}\n\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex: string): Uint8Array {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  const len = hex.length;\n  if (len % 2) throw new Error('padded hex string expected, got unpadded hex of length ' + len);\n  const array = new Uint8Array(len / 2);\n  for (let i = 0; i < array.length; i++) {\n    const j = i * 2;\n    const hexByte = hex.slice(j, j + 2);\n    const byte = Number.parseInt(hexByte, 16);\n    if (Number.isNaN(byte) || byte < 0) throw new Error('Invalid byte sequence');\n    array[i] = byte;\n  }\n  return array;\n}\n\n// BE: Big Endian, LE: Little Endian\nexport function bytesToNumberBE(bytes: Uint8Array): bigint {\n  return hexToNumber(bytesToHex(bytes));\n}\nexport function bytesToNumberLE(bytes: Uint8Array): bigint {\n  if (!u8a(bytes)) throw new Error('Uint8Array expected');\n  return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));\n}\n\nexport function numberToBytesBE(n: number | bigint, len: number): Uint8Array {\n  return hexToBytes(n.toString(16).padStart(len * 2, '0'));\n}\nexport function numberToBytesLE(n: number | bigint, len: number): Uint8Array {\n  return numberToBytesBE(n, len).reverse();\n}\n// Unpadded, rarely used\nexport function numberToVarBytesBE(n: number | bigint): Uint8Array {\n  return hexToBytes(numberToHexUnpadded(n));\n}\n\n/**\n * Takes hex string or Uint8Array, converts to Uint8Array.\n * Validates output length.\n * Will throw error for other types.\n * @param title descriptive title for an error e.g. 'private key'\n * @param hex hex string or Uint8Array\n * @param expectedLength optional, will compare to result array's length\n * @returns\n */\nexport function ensureBytes(title: string, hex: Hex, expectedLength?: number): Uint8Array {\n  let res: Uint8Array;\n  if (typeof hex === 'string') {\n    try {\n      res = hexToBytes(hex);\n    } catch (e) {\n      throw new Error(`${title} must be valid hex string, got \"${hex}\". Cause: ${e}`);\n    }\n  } else if (u8a(hex)) {\n    // Uint8Array.from() instead of hash.slice() because node.js Buffer\n    // is instance of Uint8Array, and its slice() creates **mutable** copy\n    res = Uint8Array.from(hex);\n  } else {\n    throw new Error(`${title} must be hex string or Uint8Array`);\n  }\n  const len = res.length;\n  if (typeof expectedLength === 'number' && len !== expectedLength)\n    throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);\n  return res;\n}\n\n/**\n * Copies several Uint8Arrays into one.\n */\nexport function concatBytes(...arrays: Uint8Array[]): Uint8Array {\n  const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));\n  let pad = 0; // walk through each item, ensure they have proper type\n  arrays.forEach((a) => {\n    if (!u8a(a)) throw new Error('Uint8Array expected');\n    r.set(a, pad);\n    pad += a.length;\n  });\n  return r;\n}\n\nexport function equalBytes(b1: Uint8Array, b2: Uint8Array) {\n  // We don't care about timing attacks here\n  if (b1.length !== b2.length) return false;\n  for (let i = 0; i < b1.length; i++) if (b1[i] !== b2[i]) return false;\n  return true;\n}\n\n// Global symbols in both browsers and Node.js since v11\n// See https://github.com/microsoft/TypeScript/issues/31535\ndeclare const TextEncoder: any;\n\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nexport function utf8ToBytes(str: string): Uint8Array {\n  if (typeof str !== 'string') throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n  return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n\n// Bit operations\n\n/**\n * Calculates amount of bits in a bigint.\n * Same as `n.toString(2).length`\n */\nexport function bitLen(n: bigint) {\n  let len;\n  for (len = 0; n > _0n; n >>= _1n, len += 1);\n  return len;\n}\n\n/**\n * Gets single bit at position.\n * NOTE: first bit position is 0 (same as arrays)\n * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`\n */\nexport function bitGet(n: bigint, pos: number) {\n  return (n >> BigInt(pos)) & _1n;\n}\n\n/**\n * Sets single bit at position.\n */\nexport const bitSet = (n: bigint, pos: number, value: boolean) => {\n  return n | ((value ? _1n : _0n) << BigInt(pos));\n};\n\n/**\n * Calculate mask for N bits. Not using ** operator with bigints because of old engines.\n * Same as BigInt(`0b${Array(i).fill('1').join('')}`)\n */\nexport const bitMask = (n: number) => (_2n << BigInt(n - 1)) - _1n;\n\n// DRBG\n\nconst u8n = (data?: any) => new Uint8Array(data); // creates Uint8Array\nconst u8fr = (arr: any) => Uint8Array.from(arr); // another shortcut\ntype Pred<T> = (v: Uint8Array) => T | undefined;\n/**\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n * @returns function that will call DRBG until 2nd arg returns something meaningful\n * @example\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\n */\nexport function createHmacDrbg<T>(\n  hashLen: number,\n  qByteLen: number,\n  hmacFn: (key: Uint8Array, ...messages: Uint8Array[]) => Uint8Array\n): (seed: Uint8Array, predicate: Pred<T>) => T {\n  if (typeof hashLen !== 'number' || hashLen < 2) throw new Error('hashLen must be a number');\n  if (typeof qByteLen !== 'number' || qByteLen < 2) throw new Error('qByteLen must be a number');\n  if (typeof hmacFn !== 'function') throw new Error('hmacFn must be a function');\n  // Step B, Step C: set hashLen to 8*ceil(hlen/8)\n  let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n  let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\n  let i = 0; // Iterations counter, will throw when over 1000\n  const reset = () => {\n    v.fill(1);\n    k.fill(0);\n    i = 0;\n  };\n  const h = (...b: Uint8Array[]) => hmacFn(k, v, ...b); // hmac(k)(v, ...values)\n  const reseed = (seed = u8n()) => {\n    // HMAC-DRBG reseed() function. Steps D-G\n    k = h(u8fr([0x00]), seed); // k = hmac(k || v || 0x00 || seed)\n    v = h(); // v = hmac(k || v)\n    if (seed.length === 0) return;\n    k = h(u8fr([0x01]), seed); // k = hmac(k || v || 0x01 || seed)\n    v = h(); // v = hmac(k || v)\n  };\n  const gen = () => {\n    // HMAC-DRBG generate() function\n    if (i++ >= 1000) throw new Error('drbg: tried 1000 values');\n    let len = 0;\n    const out: Uint8Array[] = [];\n    while (len < qByteLen) {\n      v = h();\n      const sl = v.slice();\n      out.push(sl);\n      len += v.length;\n    }\n    return concatBytes(...out);\n  };\n  const genUntil = (seed: Uint8Array, pred: Pred<T>): T => {\n    reset();\n    reseed(seed); // Steps D-G\n    let res: T | undefined = undefined; // Step H: grind until k is in [1..n-1]\n    while (!(res = pred(gen()))) reseed();\n    reset();\n    return res;\n  };\n  return genUntil;\n}\n\n// Validating curves and fields\n\nconst validatorFns = {\n  bigint: (val: any) => typeof val === 'bigint',\n  function: (val: any) => typeof val === 'function',\n  boolean: (val: any) => typeof val === 'boolean',\n  string: (val: any) => typeof val === 'string',\n  stringOrUint8Array: (val: any) => typeof val === 'string' || val instanceof Uint8Array,\n  isSafeInteger: (val: any) => Number.isSafeInteger(val),\n  array: (val: any) => Array.isArray(val),\n  field: (val: any, object: any) => (object as any).Fp.isValid(val),\n  hash: (val: any) => typeof val === 'function' && Number.isSafeInteger(val.outputLen),\n} as const;\ntype Validator = keyof typeof validatorFns;\ntype ValMap<T extends Record<string, any>> = { [K in keyof T]?: Validator };\n// type Record<K extends string | number | symbol, T> = { [P in K]: T; }\n\nexport function validateObject<T extends Record<string, any>>(\n  object: T,\n  validators: ValMap<T>,\n  optValidators: ValMap<T> = {}\n) {\n  const checkField = (fieldName: keyof T, type: Validator, isOptional: boolean) => {\n    const checkVal = validatorFns[type];\n    if (typeof checkVal !== 'function')\n      throw new Error(`Invalid validator \"${type}\", expected function`);\n\n    const val = object[fieldName as keyof typeof object];\n    if (isOptional && val === undefined) return;\n    if (!checkVal(val, object)) {\n      throw new Error(\n        `Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`\n      );\n    }\n  };\n  for (const [fieldName, type] of Object.entries(validators)) checkField(fieldName, type!, false);\n  for (const [fieldName, type] of Object.entries(optValidators)) checkField(fieldName, type!, true);\n  return object;\n}\n// validate type tests\n// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };\n// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!\n// // Should fail type-check\n// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });\n// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });\n// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });\n// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });\n","/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Utilities for modular arithmetics and finite fields\nimport {\n  bitMask,\n  numberToBytesBE,\n  numberToBytesLE,\n  bytesToNumberBE,\n  bytesToNumberLE,\n  ensureBytes,\n  validateObject,\n} from './utils.js';\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);\n// prettier-ignore\nconst _4n = BigInt(4), _5n = BigInt(5), _8n = BigInt(8);\n// prettier-ignore\nconst _9n = BigInt(9), _16n = BigInt(16);\n\n// Calculates a modulo b\nexport function mod(a: bigint, b: bigint): bigint {\n  const result = a % b;\n  return result >= _0n ? result : b + result;\n}\n/**\n * Efficiently raise num to power and do modular division.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n * @example\n * pow(2n, 6n, 11n) // 64n % 11n == 9n\n */\n// TODO: use field version && remove\nexport function pow(num: bigint, power: bigint, modulo: bigint): bigint {\n  if (modulo <= _0n || power < _0n) throw new Error('Expected power/modulo > 0');\n  if (modulo === _1n) return _0n;\n  let res = _1n;\n  while (power > _0n) {\n    if (power & _1n) res = (res * num) % modulo;\n    num = (num * num) % modulo;\n    power >>= _1n;\n  }\n  return res;\n}\n\n// Does x ^ (2 ^ power) mod p. pow2(30, 4) == 30 ^ (2 ^ 4)\nexport function pow2(x: bigint, power: bigint, modulo: bigint): bigint {\n  let res = x;\n  while (power-- > _0n) {\n    res *= res;\n    res %= modulo;\n  }\n  return res;\n}\n\n// Inverses number over modulo\nexport function invert(number: bigint, modulo: bigint): bigint {\n  if (number === _0n || modulo <= _0n) {\n    throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);\n  }\n  // Euclidean GCD https://brilliant.org/wiki/extended-euclidean-algorithm/\n  // Fermat's little theorem \"CT-like\" version inv(n) = n^(m-2) mod m is 30x slower.\n  let a = mod(number, modulo);\n  let b = modulo;\n  // prettier-ignore\n  let x = _0n, y = _1n, u = _1n, v = _0n;\n  while (a !== _0n) {\n    // JIT applies optimization if those two lines follow each other\n    const q = b / a;\n    const r = b % a;\n    const m = x - u * q;\n    const n = y - v * q;\n    // prettier-ignore\n    b = a, a = r, x = u, y = v, u = m, v = n;\n  }\n  const gcd = b;\n  if (gcd !== _1n) throw new Error('invert: does not exist');\n  return mod(x, modulo);\n}\n\n/**\n * Tonelli-Shanks square root search algorithm.\n * 1. https://eprint.iacr.org/2012/685.pdf (page 12)\n * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks\n * Will start an infinite loop if field order P is not prime.\n * @param P field order\n * @returns function that takes field Fp (created from P) and number n\n */\nexport function tonelliShanks(P: bigint) {\n  // Legendre constant: used to calculate Legendre symbol (a | p),\n  // which denotes the value of a^((p-1)/2) (mod p).\n  // (a | p)  1    if a is a square (mod p)\n  // (a | p)  -1   if a is not a square (mod p)\n  // (a | p)  0    if a  0 (mod p)\n  const legendreC = (P - _1n) / _2n;\n\n  let Q: bigint, S: number, Z: bigint;\n  // Step 1: By factoring out powers of 2 from p - 1,\n  // find q and s such that p - 1 = q*(2^s) with q odd\n  for (Q = P - _1n, S = 0; Q % _2n === _0n; Q /= _2n, S++);\n\n  // Step 2: Select a non-square z such that (z | p)  -1 and set c  zq\n  for (Z = _2n; Z < P && pow(Z, legendreC, P) !== P - _1n; Z++);\n\n  // Fast-path\n  if (S === 1) {\n    const p1div4 = (P + _1n) / _4n;\n    return function tonelliFast<T>(Fp: IField<T>, n: T) {\n      const root = Fp.pow(n, p1div4);\n      if (!Fp.eql(Fp.sqr(root), n)) throw new Error('Cannot find square root');\n      return root;\n    };\n  }\n\n  // Slow-path\n  const Q1div2 = (Q + _1n) / _2n;\n  return function tonelliSlow<T>(Fp: IField<T>, n: T): T {\n    // Step 0: Check that n is indeed a square: (n | p) should not be  -1\n    if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE)) throw new Error('Cannot find square root');\n    let r = S;\n    // TODO: will fail at Fp2/etc\n    let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q); // will update both x and b\n    let x = Fp.pow(n, Q1div2); // first guess at the square root\n    let b = Fp.pow(n, Q); // first guess at the fudge factor\n\n    while (!Fp.eql(b, Fp.ONE)) {\n      if (Fp.eql(b, Fp.ZERO)) return Fp.ZERO; // https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm (4. If t = 0, return r = 0)\n      // Find m such b^(2^m)==1\n      let m = 1;\n      for (let t2 = Fp.sqr(b); m < r; m++) {\n        if (Fp.eql(t2, Fp.ONE)) break;\n        t2 = Fp.sqr(t2); // t2 *= t2\n      }\n      // NOTE: r-m-1 can be bigger than 32, need to convert to bigint before shift, otherwise there will be overflow\n      const ge = Fp.pow(g, _1n << BigInt(r - m - 1)); // ge = 2^(r-m-1)\n      g = Fp.sqr(ge); // g = ge * ge\n      x = Fp.mul(x, ge); // x *= ge\n      b = Fp.mul(b, g); // b *= g\n      r = m;\n    }\n    return x;\n  };\n}\n\nexport function FpSqrt(P: bigint) {\n  // NOTE: different algorithms can give different roots, it is up to user to decide which one they want.\n  // For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).\n\n  // P  3 (mod 4)\n  // n = n^((P+1)/4)\n  if (P % _4n === _3n) {\n    // Not all roots possible!\n    // const ORDER =\n    //   0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn;\n    // const NUM = 72057594037927816n;\n    const p1div4 = (P + _1n) / _4n;\n    return function sqrt3mod4<T>(Fp: IField<T>, n: T) {\n      const root = Fp.pow(n, p1div4);\n      // Throw if root**2 != n\n      if (!Fp.eql(Fp.sqr(root), n)) throw new Error('Cannot find square root');\n      return root;\n    };\n  }\n\n  // Atkin algorithm for q  5 (mod 8), https://eprint.iacr.org/2012/685.pdf (page 10)\n  if (P % _8n === _5n) {\n    const c1 = (P - _5n) / _8n;\n    return function sqrt5mod8<T>(Fp: IField<T>, n: T) {\n      const n2 = Fp.mul(n, _2n);\n      const v = Fp.pow(n2, c1);\n      const nv = Fp.mul(n, v);\n      const i = Fp.mul(Fp.mul(nv, _2n), v);\n      const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));\n      if (!Fp.eql(Fp.sqr(root), n)) throw new Error('Cannot find square root');\n      return root;\n    };\n  }\n\n  // P  9 (mod 16)\n  if (P % _16n === _9n) {\n    // NOTE: tonelli is too slow for bls-Fp2 calculations even on start\n    // Means we cannot use sqrt for constants at all!\n    //\n    // const c1 = Fp.sqrt(Fp.negate(Fp.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F\n    // const c2 = Fp.sqrt(c1);                //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F\n    // const c3 = Fp.sqrt(Fp.negate(c1));     //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F\n    // const c4 = (P + _7n) / _16n;           //  4. c4 = (q + 7) / 16        # Integer arithmetic\n    // sqrt = (x) => {\n    //   let tv1 = Fp.pow(x, c4);             //  1. tv1 = x^c4\n    //   let tv2 = Fp.mul(c1, tv1);           //  2. tv2 = c1 * tv1\n    //   const tv3 = Fp.mul(c2, tv1);         //  3. tv3 = c2 * tv1\n    //   let tv4 = Fp.mul(c3, tv1);           //  4. tv4 = c3 * tv1\n    //   const e1 = Fp.equals(Fp.square(tv2), x); //  5.  e1 = (tv2^2) == x\n    //   const e2 = Fp.equals(Fp.square(tv3), x); //  6.  e2 = (tv3^2) == x\n    //   tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x\n    //   tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x\n    //   const e3 = Fp.equals(Fp.square(tv2), x); //  9.  e3 = (tv2^2) == x\n    //   return Fp.cmov(tv1, tv2, e3); //  10.  z = CMOV(tv1, tv2, e3)  # Select the sqrt from tv1 and tv2\n    // }\n  }\n\n  // Other cases: Tonelli-Shanks algorithm\n  return tonelliShanks(P);\n}\n\n// Little-endian check for first LE bit (last BE bit);\nexport const isNegativeLE = (num: bigint, modulo: bigint) => (mod(num, modulo) & _1n) === _1n;\n\n// Field is not always over prime: for example, Fp2 has ORDER(q)=p^m\nexport interface IField<T> {\n  ORDER: bigint;\n  BYTES: number;\n  BITS: number;\n  MASK: bigint;\n  ZERO: T;\n  ONE: T;\n  // 1-arg\n  create: (num: T) => T;\n  isValid: (num: T) => boolean;\n  is0: (num: T) => boolean;\n  neg(num: T): T;\n  inv(num: T): T;\n  sqrt(num: T): T;\n  sqr(num: T): T;\n  // 2-args\n  eql(lhs: T, rhs: T): boolean;\n  add(lhs: T, rhs: T): T;\n  sub(lhs: T, rhs: T): T;\n  mul(lhs: T, rhs: T | bigint): T;\n  pow(lhs: T, power: bigint): T;\n  div(lhs: T, rhs: T | bigint): T;\n  // N for NonNormalized (for now)\n  addN(lhs: T, rhs: T): T;\n  subN(lhs: T, rhs: T): T;\n  mulN(lhs: T, rhs: T | bigint): T;\n  sqrN(num: T): T;\n\n  // Optional\n  // Should be same as sgn0 function in\n  // [RFC9380](https://www.rfc-editor.org/rfc/rfc9380#section-4.1).\n  // NOTE: sgn0 is 'negative in LE', which is same as odd. And negative in LE is kinda strange definition anyway.\n  isOdd?(num: T): boolean; // Odd instead of even since we have it for Fp2\n  // legendre?(num: T): T;\n  pow(lhs: T, power: bigint): T;\n  invertBatch: (lst: T[]) => T[];\n  toBytes(num: T): Uint8Array;\n  fromBytes(bytes: Uint8Array): T;\n  // If c is False, CMOV returns a, otherwise it returns b.\n  cmov(a: T, b: T, c: boolean): T;\n}\n// prettier-ignore\nconst FIELD_FIELDS = [\n  'create', 'isValid', 'is0', 'neg', 'inv', 'sqrt', 'sqr',\n  'eql', 'add', 'sub', 'mul', 'pow', 'div',\n  'addN', 'subN', 'mulN', 'sqrN'\n] as const;\nexport function validateField<T>(field: IField<T>) {\n  const initial = {\n    ORDER: 'bigint',\n    MASK: 'bigint',\n    BYTES: 'isSafeInteger',\n    BITS: 'isSafeInteger',\n  } as Record<string, string>;\n  const opts = FIELD_FIELDS.reduce((map, val: string) => {\n    map[val] = 'function';\n    return map;\n  }, initial);\n  return validateObject(field, opts);\n}\n\n// Generic field functions\n\n/**\n * Same as `pow` but for Fp: non-constant-time.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n */\nexport function FpPow<T>(f: IField<T>, num: T, power: bigint): T {\n  // Should have same speed as pow for bigints\n  // TODO: benchmark!\n  if (power < _0n) throw new Error('Expected power > 0');\n  if (power === _0n) return f.ONE;\n  if (power === _1n) return num;\n  let p = f.ONE;\n  let d = num;\n  while (power > _0n) {\n    if (power & _1n) p = f.mul(p, d);\n    d = f.sqr(d);\n    power >>= _1n;\n  }\n  return p;\n}\n\n/**\n * Efficiently invert an array of Field elements.\n * `inv(0)` will return `undefined` here: make sure to throw an error.\n */\nexport function FpInvertBatch<T>(f: IField<T>, nums: T[]): T[] {\n  const tmp = new Array(nums.length);\n  // Walk from first to last, multiply them by each other MOD p\n  const lastMultiplied = nums.reduce((acc, num, i) => {\n    if (f.is0(num)) return acc;\n    tmp[i] = acc;\n    return f.mul(acc, num);\n  }, f.ONE);\n  // Invert last element\n  const inverted = f.inv(lastMultiplied);\n  // Walk from last to first, multiply them by inverted each other MOD p\n  nums.reduceRight((acc, num, i) => {\n    if (f.is0(num)) return acc;\n    tmp[i] = f.mul(acc, tmp[i]);\n    return f.mul(acc, num);\n  }, inverted);\n  return tmp;\n}\n\nexport function FpDiv<T>(f: IField<T>, lhs: T, rhs: T | bigint): T {\n  return f.mul(lhs, typeof rhs === 'bigint' ? invert(rhs, f.ORDER) : f.inv(rhs));\n}\n\n// This function returns True whenever the value x is a square in the field F.\nexport function FpIsSquare<T>(f: IField<T>) {\n  const legendreConst = (f.ORDER - _1n) / _2n; // Integer arithmetic\n  return (x: T): boolean => {\n    const p = f.pow(x, legendreConst);\n    return f.eql(p, f.ZERO) || f.eql(p, f.ONE);\n  };\n}\n\n// CURVE.n lengths\nexport function nLength(n: bigint, nBitLength?: number) {\n  // Bit size, byte size of CURVE.n\n  const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;\n  const nByteLength = Math.ceil(_nBitLength / 8);\n  return { nBitLength: _nBitLength, nByteLength };\n}\n\ntype FpField = IField<bigint> & Required<Pick<IField<bigint>, 'isOdd'>>;\n/**\n * Initializes a finite field over prime. **Non-primes are not supported.**\n * Do not init in loop: slow. Very fragile: always run a benchmark on a change.\n * Major performance optimizations:\n * * a) denormalized operations like mulN instead of mul\n * * b) same object shape: never add or remove keys\n * * c) Object.freeze\n * @param ORDER prime positive bigint\n * @param bitLen how many bits the field consumes\n * @param isLE (def: false) if encoding / decoding should be in little-endian\n * @param redef optional faster redefinitions of sqrt and other methods\n */\nexport function Field(\n  ORDER: bigint,\n  bitLen?: number,\n  isLE = false,\n  redef: Partial<IField<bigint>> = {}\n): Readonly<FpField> {\n  if (ORDER <= _0n) throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);\n  const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);\n  if (BYTES > 2048) throw new Error('Field lengths over 2048 bytes are not supported');\n  const sqrtP = FpSqrt(ORDER);\n  const f: Readonly<FpField> = Object.freeze({\n    ORDER,\n    BITS,\n    BYTES,\n    MASK: bitMask(BITS),\n    ZERO: _0n,\n    ONE: _1n,\n    create: (num) => mod(num, ORDER),\n    isValid: (num) => {\n      if (typeof num !== 'bigint')\n        throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);\n      return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible\n    },\n    is0: (num) => num === _0n,\n    isOdd: (num) => (num & _1n) === _1n,\n    neg: (num) => mod(-num, ORDER),\n    eql: (lhs, rhs) => lhs === rhs,\n\n    sqr: (num) => mod(num * num, ORDER),\n    add: (lhs, rhs) => mod(lhs + rhs, ORDER),\n    sub: (lhs, rhs) => mod(lhs - rhs, ORDER),\n    mul: (lhs, rhs) => mod(lhs * rhs, ORDER),\n    pow: (num, power) => FpPow(f, num, power),\n    div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),\n\n    // Same as above, but doesn't normalize\n    sqrN: (num) => num * num,\n    addN: (lhs, rhs) => lhs + rhs,\n    subN: (lhs, rhs) => lhs - rhs,\n    mulN: (lhs, rhs) => lhs * rhs,\n\n    inv: (num) => invert(num, ORDER),\n    sqrt: redef.sqrt || ((n) => sqrtP(f, n)),\n    invertBatch: (lst) => FpInvertBatch(f, lst),\n    // TODO: do we really need constant cmov?\n    // We don't have const-time bigints anyway, so probably will be not very useful\n    cmov: (a, b, c) => (c ? b : a),\n    toBytes: (num) => (isLE ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES)),\n    fromBytes: (bytes) => {\n      if (bytes.length !== BYTES)\n        throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes.length}`);\n      return isLE ? bytesToNumberLE(bytes) : bytesToNumberBE(bytes);\n    },\n  } as FpField);\n  return Object.freeze(f);\n}\n\nexport function FpSqrtOdd<T>(Fp: IField<T>, elm: T) {\n  if (!Fp.isOdd) throw new Error(`Field doesn't have isOdd`);\n  const root = Fp.sqrt(elm);\n  return Fp.isOdd(root) ? root : Fp.neg(root);\n}\n\nexport function FpSqrtEven<T>(Fp: IField<T>, elm: T) {\n  if (!Fp.isOdd) throw new Error(`Field doesn't have isOdd`);\n  const root = Fp.sqrt(elm);\n  return Fp.isOdd(root) ? Fp.neg(root) : root;\n}\n\n/**\n * \"Constant-time\" private key generation utility.\n * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).\n * Which makes it slightly more biased, less secure.\n * @deprecated use mapKeyToField instead\n */\nexport function hashToPrivateScalar(\n  hash: string | Uint8Array,\n  groupOrder: bigint,\n  isLE = false\n): bigint {\n  hash = ensureBytes('privateHash', hash);\n  const hashLen = hash.length;\n  const minLen = nLength(groupOrder).nByteLength + 8;\n  if (minLen < 24 || hashLen < minLen || hashLen > 1024)\n    throw new Error(`hashToPrivateScalar: expected ${minLen}-1024 bytes of input, got ${hashLen}`);\n  const num = isLE ? bytesToNumberLE(hash) : bytesToNumberBE(hash);\n  return mod(num, groupOrder - _1n) + _1n;\n}\n\n/**\n * Returns total number of bytes consumed by the field element.\n * For example, 32 bytes for usual 256-bit weierstrass curve.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of field\n */\nexport function getFieldBytesLength(fieldOrder: bigint): number {\n  if (typeof fieldOrder !== 'bigint') throw new Error('field order must be bigint');\n  const bitLength = fieldOrder.toString(2).length;\n  return Math.ceil(bitLength / 8);\n}\n\n/**\n * Returns minimal amount of bytes that can be safely reduced\n * by field order.\n * Should be 2^-128 for 128-bit curve such as P256.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of target hash\n */\nexport function getMinHashLength(fieldOrder: bigint): number {\n  const length = getFieldBytesLength(fieldOrder);\n  return length + Math.ceil(length / 2);\n}\n\n/**\n * \"Constant-time\" private key generation utility.\n * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF\n * and convert them into private scalar, with the modulo bias being negligible.\n * Needs at least 48 bytes of input for 32-byte private key.\n * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/\n * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final\n * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5\n * @param hash hash output from SHA3 or a similar function\n * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)\n * @param isLE interpret hash bytes as LE num\n * @returns valid private scalar\n */\nexport function mapHashToField(key: Uint8Array, fieldOrder: bigint, isLE = false): Uint8Array {\n  const len = key.length;\n  const fieldLen = getFieldBytesLength(fieldOrder);\n  const minLen = getMinHashLength(fieldOrder);\n  // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.\n  if (len < 16 || len < minLen || len > 1024)\n    throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);\n  const num = isLE ? bytesToNumberBE(key) : bytesToNumberLE(key);\n  // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n  const reduced = mod(num, fieldOrder - _1n) + _1n;\n  return isLE ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);\n}\n","import { hash as assertHash, bytes as assertBytes, exists as assertExists } from './_assert.js';\nimport { Hash, CHash, Input, toBytes } from './utils.js';\n// HMAC (RFC 2104)\nexport class HMAC<T extends Hash<T>> extends Hash<HMAC<T>> {\n  oHash: T;\n  iHash: T;\n  blockLen: number;\n  outputLen: number;\n  private finished = false;\n  private destroyed = false;\n\n  constructor(hash: CHash, _key: Input) {\n    super();\n    assertHash(hash);\n    const key = toBytes(_key);\n    this.iHash = hash.create() as T;\n    if (typeof this.iHash.update !== 'function')\n      throw new Error('Expected instance of class which extends utils.Hash');\n    this.blockLen = this.iHash.blockLen;\n    this.outputLen = this.iHash.outputLen;\n    const blockLen = this.blockLen;\n    const pad = new Uint8Array(blockLen);\n    // blockLen can be bigger than outputLen\n    pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n    for (let i = 0; i < pad.length; i++) pad[i] ^= 0x36;\n    this.iHash.update(pad);\n    // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n    this.oHash = hash.create() as T;\n    // Undo internal XOR && apply outer XOR\n    for (let i = 0; i < pad.length; i++) pad[i] ^= 0x36 ^ 0x5c;\n    this.oHash.update(pad);\n    pad.fill(0);\n  }\n  update(buf: Input) {\n    assertExists(this);\n    this.iHash.update(buf);\n    return this;\n  }\n  digestInto(out: Uint8Array) {\n    assertExists(this);\n    assertBytes(out, this.outputLen);\n    this.finished = true;\n    this.iHash.digestInto(out);\n    this.oHash.update(out);\n    this.oHash.digestInto(out);\n    this.destroy();\n  }\n  digest() {\n    const out = new Uint8Array(this.oHash.outputLen);\n    this.digestInto(out);\n    return out;\n  }\n  _cloneInto(to?: HMAC<T>): HMAC<T> {\n    // Create new instance without calling constructor since key already in state and we don't know it.\n    to ||= Object.create(Object.getPrototypeOf(this), {});\n    const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n    to = to as this;\n    to.finished = finished;\n    to.destroyed = destroyed;\n    to.blockLen = blockLen;\n    to.outputLen = outputLen;\n    to.oHash = oHash._cloneInto(to.oHash);\n    to.iHash = iHash._cloneInto(to.iHash);\n    return to;\n  }\n  destroy() {\n    this.destroyed = true;\n    this.oHash.destroy();\n    this.iHash.destroy();\n  }\n}\n\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n */\nexport const hmac = (hash: CHash, key: Input, message: Input): Uint8Array =>\n  new HMAC<any>(hash, key).update(message).digest();\nhmac.create = (hash: CHash, key: Input) => new HMAC<any>(hash, key);\n","/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Abelian group utilities\nimport { IField, validateField, nLength } from './modular.js';\nimport { validateObject } from './utils.js';\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\n\nexport type AffinePoint<T> = {\n  x: T;\n  y: T;\n} & { z?: never; t?: never };\n\nexport interface Group<T extends Group<T>> {\n  double(): T;\n  negate(): T;\n  add(other: T): T;\n  subtract(other: T): T;\n  equals(other: T): boolean;\n  multiply(scalar: bigint): T;\n}\n\nexport type GroupConstructor<T> = {\n  BASE: T;\n  ZERO: T;\n};\nexport type Mapper<T> = (i: T[]) => T[];\n\n// Elliptic curve multiplication of Point by scalar. Fragile.\n// Scalars should always be less than curve order: this should be checked inside of a curve itself.\n// Creates precomputation tables for fast multiplication:\n// - private scalar is split by fixed size windows of W bits\n// - every window point is collected from window's table & added to accumulator\n// - since windows are different, same point inside tables won't be accessed more than once per calc\n// - each multiplication is 'Math.ceil(CURVE_ORDER / ) + 1' point additions (fixed for any scalar)\n// - +1 window is neccessary for wNAF\n// - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication\n// TODO: Research returning 2d JS array of windows, instead of a single window. This would allow\n// windows to be in different memory locations\nexport function wNAF<T extends Group<T>>(c: GroupConstructor<T>, bits: number) {\n  const constTimeNegate = (condition: boolean, item: T): T => {\n    const neg = item.negate();\n    return condition ? neg : item;\n  };\n  const opts = (W: number) => {\n    const windows = Math.ceil(bits / W) + 1; // +1, because\n    const windowSize = 2 ** (W - 1); // -1 because we skip zero\n    return { windows, windowSize };\n  };\n  return {\n    constTimeNegate,\n    // non-const time multiplication ladder\n    unsafeLadder(elm: T, n: bigint) {\n      let p = c.ZERO;\n      let d: T = elm;\n      while (n > _0n) {\n        if (n & _1n) p = p.add(d);\n        d = d.double();\n        n >>= _1n;\n      }\n      return p;\n    },\n\n    /**\n     * Creates a wNAF precomputation window. Used for caching.\n     * Default window size is set by `utils.precompute()` and is equal to 8.\n     * Number of precomputed points depends on the curve size:\n     * 2^(1) * (Math.ceil( / ) + 1), where:\n     * -  is the window size\n     * -  is the bitlength of the curve order.\n     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.\n     * @returns precomputed point tables flattened to a single array\n     */\n    precomputeWindow(elm: T, W: number): Group<T>[] {\n      const { windows, windowSize } = opts(W);\n      const points: T[] = [];\n      let p: T = elm;\n      let base = p;\n      for (let window = 0; window < windows; window++) {\n        base = p;\n        points.push(base);\n        // =1, because we skip zero\n        for (let i = 1; i < windowSize; i++) {\n          base = base.add(p);\n          points.push(base);\n        }\n        p = base.double();\n      }\n      return points;\n    },\n\n    /**\n     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.\n     * @param W window size\n     * @param precomputes precomputed tables\n     * @param n scalar (we don't check here, but should be less than curve order)\n     * @returns real and fake (for const-time) points\n     */\n    wNAF(W: number, precomputes: T[], n: bigint): { p: T; f: T } {\n      // TODO: maybe check that scalar is less than group order? wNAF behavious is undefined otherwise\n      // But need to carefully remove other checks before wNAF. ORDER == bits here\n      const { windows, windowSize } = opts(W);\n\n      let p = c.ZERO;\n      let f = c.BASE;\n\n      const mask = BigInt(2 ** W - 1); // Create mask with W ones: 0b1111 for W=4 etc.\n      const maxNumber = 2 ** W;\n      const shiftBy = BigInt(W);\n\n      for (let window = 0; window < windows; window++) {\n        const offset = window * windowSize;\n        // Extract W bits.\n        let wbits = Number(n & mask);\n\n        // Shift number by W bits.\n        n >>= shiftBy;\n\n        // If the bits are bigger than max size, we'll split those.\n        // +224 => 256 - 32\n        if (wbits > windowSize) {\n          wbits -= maxNumber;\n          n += _1n;\n        }\n\n        // This code was first written with assumption that 'f' and 'p' will never be infinity point:\n        // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,\n        // there is negate now: it is possible that negated element from low value\n        // would be the same as high element, which will create carry into next window.\n        // It's not obvious how this can fail, but still worth investigating later.\n\n        // Check if we're onto Zero point.\n        // Add random point inside current window to f.\n        const offset1 = offset;\n        const offset2 = offset + Math.abs(wbits) - 1; // -1 because we skip zero\n        const cond1 = window % 2 !== 0;\n        const cond2 = wbits < 0;\n        if (wbits === 0) {\n          // The most important part for const-time getPublicKey\n          f = f.add(constTimeNegate(cond1, precomputes[offset1]));\n        } else {\n          p = p.add(constTimeNegate(cond2, precomputes[offset2]));\n        }\n      }\n      // JIT-compiler should not eliminate f here, since it will later be used in normalizeZ()\n      // Even if the variable is still unused, there are some checks which will\n      // throw an exception, so compiler needs to prove they won't happen, which is hard.\n      // At this point there is a way to F be infinity-point even if p is not,\n      // which makes it less const-time: around 1 bigint multiply.\n      return { p, f };\n    },\n\n    wNAFCached(P: T, precomputesMap: Map<T, T[]>, n: bigint, transform: Mapper<T>): { p: T; f: T } {\n      // @ts-ignore\n      const W: number = P._WINDOW_SIZE || 1;\n      // Calculate precomputes on a first run, reuse them after\n      let comp = precomputesMap.get(P);\n      if (!comp) {\n        comp = this.precomputeWindow(P, W) as T[];\n        if (W !== 1) {\n          precomputesMap.set(P, transform(comp));\n        }\n      }\n      return this.wNAF(W, comp, n);\n    },\n  };\n}\n\n// Generic BasicCurve interface: works even for polynomial fields (BLS): P, n, h would be ok.\n// Though generator can be different (Fp2 / Fp6 for BLS).\nexport type BasicCurve<T> = {\n  Fp: IField<T>; // Field over which we'll do calculations (Fp)\n  n: bigint; // Curve order, total count of valid points in the field\n  nBitLength?: number; // bit length of curve order\n  nByteLength?: number; // byte length of curve order\n  h: bigint; // cofactor. we can assign default=1, but users will just ignore it w/o validation\n  hEff?: bigint; // Number to multiply to clear cofactor\n  Gx: T; // base point X coordinate\n  Gy: T; // base point Y coordinate\n  allowInfinityPoint?: boolean; // bls12-381 requires it. ZERO point is valid, but invalid pubkey\n};\n\nexport function validateBasic<FP, T>(curve: BasicCurve<FP> & T) {\n  validateField(curve.Fp);\n  validateObject(\n    curve,\n    {\n      n: 'bigint',\n      h: 'bigint',\n      Gx: 'field',\n      Gy: 'field',\n    },\n    {\n      nBitLength: 'isSafeInteger',\n      nByteLength: 'isSafeInteger',\n    }\n  );\n  // Set defaults\n  return Object.freeze({\n    ...nLength(curve.n, curve.nBitLength),\n    ...curve,\n    ...{ p: curve.Fp.ORDER },\n  } as const);\n}\n","/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Short Weierstrass curve. The formula is: y = x + ax + b\nimport * as mod from './modular.js';\nimport * as ut from './utils.js';\nimport { CHash, Hex, PrivKey, ensureBytes } from './utils.js';\nimport { Group, GroupConstructor, wNAF, BasicCurve, validateBasic, AffinePoint } from './curve.js';\n\nexport type { AffinePoint };\ntype HmacFnSync = (key: Uint8Array, ...messages: Uint8Array[]) => Uint8Array;\ntype EndomorphismOpts = {\n  beta: bigint;\n  splitScalar: (k: bigint) => { k1neg: boolean; k1: bigint; k2neg: boolean; k2: bigint };\n};\nexport type BasicWCurve<T> = BasicCurve<T> & {\n  // Params: a, b\n  a: T;\n  b: T;\n\n  // Optional params\n  allowedPrivateKeyLengths?: readonly number[]; // for P521\n  wrapPrivateKey?: boolean; // bls12-381 requires mod(n) instead of rejecting keys >= n\n  endo?: EndomorphismOpts; // Endomorphism options for Koblitz curves\n  // When a cofactor != 1, there can be an effective methods to:\n  // 1. Determine whether a point is torsion-free\n  isTorsionFree?: (c: ProjConstructor<T>, point: ProjPointType<T>) => boolean;\n  // 2. Clear torsion component\n  clearCofactor?: (c: ProjConstructor<T>, point: ProjPointType<T>) => ProjPointType<T>;\n};\n\ntype Entropy = Hex | true;\nexport type SignOpts = { lowS?: boolean; extraEntropy?: Entropy; prehash?: boolean };\nexport type VerOpts = { lowS?: boolean; prehash?: boolean };\n\n/**\n * ### Design rationale for types\n *\n * * Interaction between classes from different curves should fail:\n *   `k256.Point.BASE.add(p256.Point.BASE)`\n * * For this purpose we want to use `instanceof` operator, which is fast and works during runtime\n * * Different calls of `curve()` would return different classes -\n *   `curve(params) !== curve(params)`: if somebody decided to monkey-patch their curve,\n *   it won't affect others\n *\n * TypeScript can't infer types for classes created inside a function. Classes is one instance of nominative types in TypeScript and interfaces only check for shape, so it's hard to create unique type for every function call.\n *\n * We can use generic types via some param, like curve opts, but that would:\n *     1. Enable interaction between `curve(params)` and `curve(params)` (curves of same params)\n *     which is hard to debug.\n *     2. Params can be generic and we can't enforce them to be constant value:\n *     if somebody creates curve from non-constant params,\n *     it would be allowed to interact with other curves with non-constant params\n *\n * TODO: https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-7.html#unique-symbol\n */\n\n// Instance for 3d XYZ points\nexport interface ProjPointType<T> extends Group<ProjPointType<T>> {\n  readonly px: T;\n  readonly py: T;\n  readonly pz: T;\n  get x(): T;\n  get y(): T;\n  multiply(scalar: bigint): ProjPointType<T>;\n  toAffine(iz?: T): AffinePoint<T>;\n  isTorsionFree(): boolean;\n  clearCofactor(): ProjPointType<T>;\n  assertValidity(): void;\n  hasEvenY(): boolean;\n  toRawBytes(isCompressed?: boolean): Uint8Array;\n  toHex(isCompressed?: boolean): string;\n\n  multiplyUnsafe(scalar: bigint): ProjPointType<T>;\n  multiplyAndAddUnsafe(Q: ProjPointType<T>, a: bigint, b: bigint): ProjPointType<T> | undefined;\n  _setWindowSize(windowSize: number): void;\n}\n// Static methods for 3d XYZ points\nexport interface ProjConstructor<T> extends GroupConstructor<ProjPointType<T>> {\n  new (x: T, y: T, z: T): ProjPointType<T>;\n  fromAffine(p: AffinePoint<T>): ProjPointType<T>;\n  fromHex(hex: Hex): ProjPointType<T>;\n  fromPrivateKey(privateKey: PrivKey): ProjPointType<T>;\n  normalizeZ(points: ProjPointType<T>[]): ProjPointType<T>[];\n}\n\nexport type CurvePointsType<T> = BasicWCurve<T> & {\n  // Bytes\n  fromBytes?: (bytes: Uint8Array) => AffinePoint<T>;\n  toBytes?: (c: ProjConstructor<T>, point: ProjPointType<T>, isCompressed: boolean) => Uint8Array;\n};\n\nfunction validatePointOpts<T>(curve: CurvePointsType<T>) {\n  const opts = validateBasic(curve);\n  ut.validateObject(\n    opts,\n    {\n      a: 'field',\n      b: 'field',\n    },\n    {\n      allowedPrivateKeyLengths: 'array',\n      wrapPrivateKey: 'boolean',\n      isTorsionFree: 'function',\n      clearCofactor: 'function',\n      allowInfinityPoint: 'boolean',\n      fromBytes: 'function',\n      toBytes: 'function',\n    }\n  );\n  const { endo, Fp, a } = opts;\n  if (endo) {\n    if (!Fp.eql(a, Fp.ZERO)) {\n      throw new Error('Endomorphism can only be defined for Koblitz curves that have a=0');\n    }\n    if (\n      typeof endo !== 'object' ||\n      typeof endo.beta !== 'bigint' ||\n      typeof endo.splitScalar !== 'function'\n    ) {\n      throw new Error('Expected endomorphism with beta: bigint and splitScalar: function');\n    }\n  }\n  return Object.freeze({ ...opts } as const);\n}\n\nexport type CurvePointsRes<T> = {\n  ProjectivePoint: ProjConstructor<T>;\n  normPrivateKeyToScalar: (key: PrivKey) => bigint;\n  weierstrassEquation: (x: T) => T;\n  isWithinCurveOrder: (num: bigint) => boolean;\n};\n\n// ASN.1 DER encoding utilities\nconst { bytesToNumberBE: b2n, hexToBytes: h2b } = ut;\nexport const DER = {\n  // asn.1 DER encoding utils\n  Err: class DERErr extends Error {\n    constructor(m = '') {\n      super(m);\n    }\n  },\n  _parseInt(data: Uint8Array): { d: bigint; l: Uint8Array } {\n    const { Err: E } = DER;\n    if (data.length < 2 || data[0] !== 0x02) throw new E('Invalid signature integer tag');\n    const len = data[1];\n    const res = data.subarray(2, len + 2);\n    if (!len || res.length !== len) throw new E('Invalid signature integer: wrong length');\n    // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,\n    // since we always use positive integers here. It must always be empty:\n    // - add zero byte if exists\n    // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)\n    if (res[0] & 0b10000000) throw new E('Invalid signature integer: negative');\n    if (res[0] === 0x00 && !(res[1] & 0b10000000))\n      throw new E('Invalid signature integer: unnecessary leading zero');\n    return { d: b2n(res), l: data.subarray(len + 2) }; // d is data, l is left\n  },\n  toSig(hex: string | Uint8Array): { r: bigint; s: bigint } {\n    // parse DER signature\n    const { Err: E } = DER;\n    const data = typeof hex === 'string' ? h2b(hex) : hex;\n    if (!(data instanceof Uint8Array)) throw new Error('ui8a expected');\n    let l = data.length;\n    if (l < 2 || data[0] != 0x30) throw new E('Invalid signature tag');\n    if (data[1] !== l - 2) throw new E('Invalid signature: incorrect length');\n    const { d: r, l: sBytes } = DER._parseInt(data.subarray(2));\n    const { d: s, l: rBytesLeft } = DER._parseInt(sBytes);\n    if (rBytesLeft.length) throw new E('Invalid signature: left bytes after parsing');\n    return { r, s };\n  },\n  hexFromSig(sig: { r: bigint; s: bigint }): string {\n    // Add leading zero if first byte has negative bit enabled. More details in '_parseInt'\n    const slice = (s: string): string => (Number.parseInt(s[0], 16) & 0b1000 ? '00' + s : s);\n    const h = (num: number | bigint) => {\n      const hex = num.toString(16);\n      return hex.length & 1 ? `0${hex}` : hex;\n    };\n    const s = slice(h(sig.s));\n    const r = slice(h(sig.r));\n    const shl = s.length / 2;\n    const rhl = r.length / 2;\n    const sl = h(shl);\n    const rl = h(rhl);\n    return `30${h(rhl + shl + 4)}02${rl}${r}02${sl}${s}`;\n  },\n};\n\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);\n\nexport function weierstrassPoints<T>(opts: CurvePointsType<T>) {\n  const CURVE = validatePointOpts(opts);\n  const { Fp } = CURVE; // All curves has same field / group length as for now, but they can differ\n\n  const toBytes =\n    CURVE.toBytes ||\n    ((_c: ProjConstructor<T>, point: ProjPointType<T>, _isCompressed: boolean) => {\n      const a = point.toAffine();\n      return ut.concatBytes(Uint8Array.from([0x04]), Fp.toBytes(a.x), Fp.toBytes(a.y));\n    });\n  const fromBytes =\n    CURVE.fromBytes ||\n    ((bytes: Uint8Array) => {\n      // const head = bytes[0];\n      const tail = bytes.subarray(1);\n      // if (head !== 0x04) throw new Error('Only non-compressed encoding is supported');\n      const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n      const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n      return { x, y };\n    });\n\n  /**\n   * y = x + ax + b: Short weierstrass curve formula\n   * @returns y\n   */\n  function weierstrassEquation(x: T): T {\n    const { a, b } = CURVE;\n    const x2 = Fp.sqr(x); // x * x\n    const x3 = Fp.mul(x2, x); // x2 * x\n    return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x3 + a * x + b\n  }\n  // Validate whether the passed curve params are valid.\n  // We check if curve equation works for generator point.\n  // `assertValidity()` won't work: `isTorsionFree()` is not available at this point in bls12-381.\n  // ProjectivePoint class has not been initialized yet.\n  if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))\n    throw new Error('bad generator point: equation left != right');\n\n  // Valid group elements reside in range 1..n-1\n  function isWithinCurveOrder(num: bigint): boolean {\n    return typeof num === 'bigint' && _0n < num && num < CURVE.n;\n  }\n  function assertGE(num: bigint) {\n    if (!isWithinCurveOrder(num)) throw new Error('Expected valid bigint: 0 < bigint < curve.n');\n  }\n  // Validates if priv key is valid and converts it to bigint.\n  // Supports options allowedPrivateKeyLengths and wrapPrivateKey.\n  function normPrivateKeyToScalar(key: PrivKey): bigint {\n    const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n } = CURVE;\n    if (lengths && typeof key !== 'bigint') {\n      if (key instanceof Uint8Array) key = ut.bytesToHex(key);\n      // Normalize to hex string, pad. E.g. P521 would norm 130-132 char hex to 132-char bytes\n      if (typeof key !== 'string' || !lengths.includes(key.length)) throw new Error('Invalid key');\n      key = key.padStart(nByteLength * 2, '0');\n    }\n    let num: bigint;\n    try {\n      num =\n        typeof key === 'bigint'\n          ? key\n          : ut.bytesToNumberBE(ensureBytes('private key', key, nByteLength));\n    } catch (error) {\n      throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);\n    }\n    if (wrapPrivateKey) num = mod.mod(num, n); // disabled by default, enabled for BLS\n    assertGE(num); // num in range [1..N-1]\n    return num;\n  }\n\n  const pointPrecomputes = new Map<Point, Point[]>();\n  function assertPrjPoint(other: unknown) {\n    if (!(other instanceof Point)) throw new Error('ProjectivePoint expected');\n  }\n  /**\n   * Projective Point works in 3d / projective (homogeneous) coordinates: (x, y, z)  (x=x/z, y=y/z)\n   * Default Point works in 2d / affine coordinates: (x, y)\n   * We're doing calculations in projective, because its operations don't require costly inversion.\n   */\n  class Point implements ProjPointType<T> {\n    static readonly BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);\n    static readonly ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);\n\n    constructor(readonly px: T, readonly py: T, readonly pz: T) {\n      if (px == null || !Fp.isValid(px)) throw new Error('x required');\n      if (py == null || !Fp.isValid(py)) throw new Error('y required');\n      if (pz == null || !Fp.isValid(pz)) throw new Error('z required');\n    }\n\n    // Does not validate if the point is on-curve.\n    // Use fromHex instead, or call assertValidity() later.\n    static fromAffine(p: AffinePoint<T>): Point {\n      const { x, y } = p || {};\n      if (!p || !Fp.isValid(x) || !Fp.isValid(y)) throw new Error('invalid affine point');\n      if (p instanceof Point) throw new Error('projective point not allowed');\n      const is0 = (i: T) => Fp.eql(i, Fp.ZERO);\n      // fromAffine(x:0, y:0) would produce (x:0, y:0, z:1), but we need (x:0, y:1, z:0)\n      if (is0(x) && is0(y)) return Point.ZERO;\n      return new Point(x, y, Fp.ONE);\n    }\n\n    get x(): T {\n      return this.toAffine().x;\n    }\n    get y(): T {\n      return this.toAffine().y;\n    }\n\n    /**\n     * Takes a bunch of Projective Points but executes only one\n     * inversion on all of them. Inversion is very slow operation,\n     * so this improves performance massively.\n     * Optimization: converts a list of projective points to a list of identical points with Z=1.\n     */\n    static normalizeZ(points: Point[]): Point[] {\n      const toInv = Fp.invertBatch(points.map((p) => p.pz));\n      return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n    }\n\n    /**\n     * Converts hash string or Uint8Array to Point.\n     * @param hex short/long ECDSA hex\n     */\n    static fromHex(hex: Hex): Point {\n      const P = Point.fromAffine(fromBytes(ensureBytes('pointHex', hex)));\n      P.assertValidity();\n      return P;\n    }\n\n    // Multiplies generator point by privateKey.\n    static fromPrivateKey(privateKey: PrivKey) {\n      return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));\n    }\n\n    // We calculate precomputes for elliptic curve point multiplication\n    // using windowed method. This specifies window size and\n    // stores precomputed values. Usually only base point would be precomputed.\n    _WINDOW_SIZE?: number;\n\n    // \"Private method\", don't use it directly\n    _setWindowSize(windowSize: number) {\n      this._WINDOW_SIZE = windowSize;\n      pointPrecomputes.delete(this);\n    }\n\n    // A point on curve is valid if it conforms to equation.\n    assertValidity(): void {\n      if (this.is0()) {\n        // (0, 1, 0) aka ZERO is invalid in most contexts.\n        // In BLS, ZERO can be serialized, so we allow it.\n        // (0, 0, 0) is wrong representation of ZERO and is always invalid.\n        if (CURVE.allowInfinityPoint && !Fp.is0(this.py)) return;\n        throw new Error('bad point: ZERO');\n      }\n      // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`\n      const { x, y } = this.toAffine();\n      // Check if x, y are valid field elements\n      if (!Fp.isValid(x) || !Fp.isValid(y)) throw new Error('bad point: x or y not FE');\n      const left = Fp.sqr(y); // y\n      const right = weierstrassEquation(x); // x + ax + b\n      if (!Fp.eql(left, right)) throw new Error('bad point: equation left != right');\n      if (!this.isTorsionFree()) throw new Error('bad point: not in prime-order subgroup');\n    }\n    hasEvenY(): boolean {\n      const { y } = this.toAffine();\n      if (Fp.isOdd) return !Fp.isOdd(y);\n      throw new Error(\"Field doesn't support isOdd\");\n    }\n\n    /**\n     * Compare one point to another.\n     */\n    equals(other: Point): boolean {\n      assertPrjPoint(other);\n      const { px: X1, py: Y1, pz: Z1 } = this;\n      const { px: X2, py: Y2, pz: Z2 } = other;\n      const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));\n      const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));\n      return U1 && U2;\n    }\n\n    /**\n     * Flips point to one corresponding to (x, -y) in Affine coordinates.\n     */\n    negate(): Point {\n      return new Point(this.px, Fp.neg(this.py), this.pz);\n    }\n\n    // Renes-Costello-Batina exception-free doubling formula.\n    // There is 30% faster Jacobian formula, but it is not complete.\n    // https://eprint.iacr.org/2015/1060, algorithm 3\n    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.\n    double() {\n      const { a, b } = CURVE;\n      const b3 = Fp.mul(b, _3n);\n      const { px: X1, py: Y1, pz: Z1 } = this;\n      let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n      let t0 = Fp.mul(X1, X1); // step 1\n      let t1 = Fp.mul(Y1, Y1);\n      let t2 = Fp.mul(Z1, Z1);\n      let t3 = Fp.mul(X1, Y1);\n      t3 = Fp.add(t3, t3); // step 5\n      Z3 = Fp.mul(X1, Z1);\n      Z3 = Fp.add(Z3, Z3);\n      X3 = Fp.mul(a, Z3);\n      Y3 = Fp.mul(b3, t2);\n      Y3 = Fp.add(X3, Y3); // step 10\n      X3 = Fp.sub(t1, Y3);\n      Y3 = Fp.add(t1, Y3);\n      Y3 = Fp.mul(X3, Y3);\n      X3 = Fp.mul(t3, X3);\n      Z3 = Fp.mul(b3, Z3); // step 15\n      t2 = Fp.mul(a, t2);\n      t3 = Fp.sub(t0, t2);\n      t3 = Fp.mul(a, t3);\n      t3 = Fp.add(t3, Z3);\n      Z3 = Fp.add(t0, t0); // step 20\n      t0 = Fp.add(Z3, t0);\n      t0 = Fp.add(t0, t2);\n      t0 = Fp.mul(t0, t3);\n      Y3 = Fp.add(Y3, t0);\n      t2 = Fp.mul(Y1, Z1); // step 25\n      t2 = Fp.add(t2, t2);\n      t0 = Fp.mul(t2, t3);\n      X3 = Fp.sub(X3, t0);\n      Z3 = Fp.mul(t2, t1);\n      Z3 = Fp.add(Z3, Z3); // step 30\n      Z3 = Fp.add(Z3, Z3);\n      return new Point(X3, Y3, Z3);\n    }\n\n    // Renes-Costello-Batina exception-free addition formula.\n    // There is 30% faster Jacobian formula, but it is not complete.\n    // https://eprint.iacr.org/2015/1060, algorithm 1\n    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.\n    add(other: Point): Point {\n      assertPrjPoint(other);\n      const { px: X1, py: Y1, pz: Z1 } = this;\n      const { px: X2, py: Y2, pz: Z2 } = other;\n      let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n      const a = CURVE.a;\n      const b3 = Fp.mul(CURVE.b, _3n);\n      let t0 = Fp.mul(X1, X2); // step 1\n      let t1 = Fp.mul(Y1, Y2);\n      let t2 = Fp.mul(Z1, Z2);\n      let t3 = Fp.add(X1, Y1);\n      let t4 = Fp.add(X2, Y2); // step 5\n      t3 = Fp.mul(t3, t4);\n      t4 = Fp.add(t0, t1);\n      t3 = Fp.sub(t3, t4);\n      t4 = Fp.add(X1, Z1);\n      let t5 = Fp.add(X2, Z2); // step 10\n      t4 = Fp.mul(t4, t5);\n      t5 = Fp.add(t0, t2);\n      t4 = Fp.sub(t4, t5);\n      t5 = Fp.add(Y1, Z1);\n      X3 = Fp.add(Y2, Z2); // step 15\n      t5 = Fp.mul(t5, X3);\n      X3 = Fp.add(t1, t2);\n      t5 = Fp.sub(t5, X3);\n      Z3 = Fp.mul(a, t4);\n      X3 = Fp.mul(b3, t2); // step 20\n      Z3 = Fp.add(X3, Z3);\n      X3 = Fp.sub(t1, Z3);\n      Z3 = Fp.add(t1, Z3);\n      Y3 = Fp.mul(X3, Z3);\n      t1 = Fp.add(t0, t0); // step 25\n      t1 = Fp.add(t1, t0);\n      t2 = Fp.mul(a, t2);\n      t4 = Fp.mul(b3, t4);\n      t1 = Fp.add(t1, t2);\n      t2 = Fp.sub(t0, t2); // step 30\n      t2 = Fp.mul(a, t2);\n      t4 = Fp.add(t4, t2);\n      t0 = Fp.mul(t1, t4);\n      Y3 = Fp.add(Y3, t0);\n      t0 = Fp.mul(t5, t4); // step 35\n      X3 = Fp.mul(t3, X3);\n      X3 = Fp.sub(X3, t0);\n      t0 = Fp.mul(t3, t1);\n      Z3 = Fp.mul(t5, Z3);\n      Z3 = Fp.add(Z3, t0); // step 40\n      return new Point(X3, Y3, Z3);\n    }\n\n    subtract(other: Point) {\n      return this.add(other.negate());\n    }\n\n    private is0() {\n      return this.equals(Point.ZERO);\n    }\n    private wNAF(n: bigint): { p: Point; f: Point } {\n      return wnaf.wNAFCached(this, pointPrecomputes, n, (comp: Point[]) => {\n        const toInv = Fp.invertBatch(comp.map((p) => p.pz));\n        return comp.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n      });\n    }\n\n    /**\n     * Non-constant-time multiplication. Uses double-and-add algorithm.\n     * It's faster, but should only be used when you don't care about\n     * an exposed private key e.g. sig verification, which works over *public* keys.\n     */\n    multiplyUnsafe(n: bigint): Point {\n      const I = Point.ZERO;\n      if (n === _0n) return I;\n      assertGE(n); // Will throw on 0\n      if (n === _1n) return this;\n      const { endo } = CURVE;\n      if (!endo) return wnaf.unsafeLadder(this, n);\n\n      // Apply endomorphism\n      let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n      let k1p = I;\n      let k2p = I;\n      let d: Point = this;\n      while (k1 > _0n || k2 > _0n) {\n        if (k1 & _1n) k1p = k1p.add(d);\n        if (k2 & _1n) k2p = k2p.add(d);\n        d = d.double();\n        k1 >>= _1n;\n        k2 >>= _1n;\n      }\n      if (k1neg) k1p = k1p.negate();\n      if (k2neg) k2p = k2p.negate();\n      k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n      return k1p.add(k2p);\n    }\n\n    /**\n     * Constant time multiplication.\n     * Uses wNAF method. Windowed method may be 10% faster,\n     * but takes 2x longer to generate and consumes 2x memory.\n     * Uses precomputes when available.\n     * Uses endomorphism for Koblitz curves.\n     * @param scalar by which the point would be multiplied\n     * @returns New point\n     */\n    multiply(scalar: bigint): Point {\n      assertGE(scalar);\n      let n = scalar;\n      let point: Point, fake: Point; // Fake point is used to const-time mult\n      const { endo } = CURVE;\n      if (endo) {\n        const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n        let { p: k1p, f: f1p } = this.wNAF(k1);\n        let { p: k2p, f: f2p } = this.wNAF(k2);\n        k1p = wnaf.constTimeNegate(k1neg, k1p);\n        k2p = wnaf.constTimeNegate(k2neg, k2p);\n        k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n        point = k1p.add(k2p);\n        fake = f1p.add(f2p);\n      } else {\n        const { p, f } = this.wNAF(n);\n        point = p;\n        fake = f;\n      }\n      // Normalize `z` for both points, but return only real one\n      return Point.normalizeZ([point, fake])[0];\n    }\n\n    /**\n     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.\n     * Not using Strauss-Shamir trick: precomputation tables are faster.\n     * The trick could be useful if both P and Q are not G (not in our case).\n     * @returns non-zero affine point\n     */\n    multiplyAndAddUnsafe(Q: Point, a: bigint, b: bigint): Point | undefined {\n      const G = Point.BASE; // No Strauss-Shamir trick: we have 10% faster G precomputes\n      const mul = (\n        P: Point,\n        a: bigint // Select faster multiply() method\n      ) => (a === _0n || a === _1n || !P.equals(G) ? P.multiplyUnsafe(a) : P.multiply(a));\n      const sum = mul(this, a).add(mul(Q, b));\n      return sum.is0() ? undefined : sum;\n    }\n\n    // Converts Projective point to affine (x, y) coordinates.\n    // Can accept precomputed Z^-1 - for example, from invertBatch.\n    // (x, y, z)  (x=x/z, y=y/z)\n    toAffine(iz?: T): AffinePoint<T> {\n      const { px: x, py: y, pz: z } = this;\n      const is0 = this.is0();\n      // If invZ was 0, we return zero point. However we still want to execute\n      // all operations, so we replace invZ with a random number, 1.\n      if (iz == null) iz = is0 ? Fp.ONE : Fp.inv(z);\n      const ax = Fp.mul(x, iz);\n      const ay = Fp.mul(y, iz);\n      const zz = Fp.mul(z, iz);\n      if (is0) return { x: Fp.ZERO, y: Fp.ZERO };\n      if (!Fp.eql(zz, Fp.ONE)) throw new Error('invZ was invalid');\n      return { x: ax, y: ay };\n    }\n    isTorsionFree(): boolean {\n      const { h: cofactor, isTorsionFree } = CURVE;\n      if (cofactor === _1n) return true; // No subgroups, always torsion-free\n      if (isTorsionFree) return isTorsionFree(Point, this);\n      throw new Error('isTorsionFree() has not been declared for the elliptic curve');\n    }\n    clearCofactor(): Point {\n      const { h: cofactor, clearCofactor } = CURVE;\n      if (cofactor === _1n) return this; // Fast-path\n      if (clearCofactor) return clearCofactor(Point, this) as Point;\n      return this.multiplyUnsafe(CURVE.h);\n    }\n\n    toRawBytes(isCompressed = true): Uint8Array {\n      this.assertValidity();\n      return toBytes(Point, this, isCompressed);\n    }\n\n    toHex(isCompressed = true): string {\n      return ut.bytesToHex(this.toRawBytes(isCompressed));\n    }\n  }\n  const _bits = CURVE.nBitLength;\n  const wnaf = wNAF(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);\n  // Validate if generator point is on curve\n  return {\n    CURVE,\n    ProjectivePoint: Point as ProjConstructor<T>,\n    normPrivateKeyToScalar,\n    weierstrassEquation,\n    isWithinCurveOrder,\n  };\n}\n\n// Instance\nexport interface SignatureType {\n  readonly r: bigint;\n  readonly s: bigint;\n  readonly recovery?: number;\n  assertValidity(): void;\n  addRecoveryBit(recovery: number): RecoveredSignatureType;\n  hasHighS(): boolean;\n  normalizeS(): SignatureType;\n  recoverPublicKey(msgHash: Hex): ProjPointType<bigint>;\n  toCompactRawBytes(): Uint8Array;\n  toCompactHex(): string;\n  // DER-encoded\n  toDERRawBytes(isCompressed?: boolean): Uint8Array;\n  toDERHex(isCompressed?: boolean): string;\n}\nexport type RecoveredSignatureType = SignatureType & {\n  readonly recovery: number;\n};\n// Static methods\nexport type SignatureConstructor = {\n  new (r: bigint, s: bigint): SignatureType;\n  fromCompact(hex: Hex): SignatureType;\n  fromDER(hex: Hex): SignatureType;\n};\ntype SignatureLike = { r: bigint; s: bigint };\n\nexport type PubKey = Hex | ProjPointType<bigint>;\n\nexport type CurveType = BasicWCurve<bigint> & {\n  hash: CHash; // CHash not FHash because we need outputLen for DRBG\n  hmac: HmacFnSync;\n  randomBytes: (bytesLength?: number) => Uint8Array;\n  lowS?: boolean;\n  bits2int?: (bytes: Uint8Array) => bigint;\n  bits2int_modN?: (bytes: Uint8Array) => bigint;\n};\n\nfunction validateOpts(curve: CurveType) {\n  const opts = validateBasic(curve);\n  ut.validateObject(\n    opts,\n    {\n      hash: 'hash',\n      hmac: 'function',\n      randomBytes: 'function',\n    },\n    {\n      bits2int: 'function',\n      bits2int_modN: 'function',\n      lowS: 'boolean',\n    }\n  );\n  return Object.freeze({ lowS: true, ...opts } as const);\n}\n\nexport type CurveFn = {\n  CURVE: ReturnType<typeof validateOpts>;\n  getPublicKey: (privateKey: PrivKey, isCompressed?: boolean) => Uint8Array;\n  getSharedSecret: (privateA: PrivKey, publicB: Hex, isCompressed?: boolean) => Uint8Array;\n  sign: (msgHash: Hex, privKey: PrivKey, opts?: SignOpts) => RecoveredSignatureType;\n  verify: (signature: Hex | SignatureLike, msgHash: Hex, publicKey: Hex, opts?: VerOpts) => boolean;\n  ProjectivePoint: ProjConstructor<bigint>;\n  Signature: SignatureConstructor;\n  utils: {\n    normPrivateKeyToScalar: (key: PrivKey) => bigint;\n    isValidPrivateKey(privateKey: PrivKey): boolean;\n    randomPrivateKey: () => Uint8Array;\n    precompute: (windowSize?: number, point?: ProjPointType<bigint>) => ProjPointType<bigint>;\n  };\n};\n\nexport function weierstrass(curveDef: CurveType): CurveFn {\n  const CURVE = validateOpts(curveDef) as ReturnType<typeof validateOpts>;\n  const { Fp, n: CURVE_ORDER } = CURVE;\n  const compressedLen = Fp.BYTES + 1; // e.g. 33 for 32\n  const uncompressedLen = 2 * Fp.BYTES + 1; // e.g. 65 for 32\n\n  function isValidFieldElement(num: bigint): boolean {\n    return _0n < num && num < Fp.ORDER; // 0 is banned since it's not invertible FE\n  }\n  function modN(a: bigint) {\n    return mod.mod(a, CURVE_ORDER);\n  }\n  function invN(a: bigint) {\n    return mod.invert(a, CURVE_ORDER);\n  }\n\n  const {\n    ProjectivePoint: Point,\n    normPrivateKeyToScalar,\n    weierstrassEquation,\n    isWithinCurveOrder,\n  } = weierstrassPoints({\n    ...CURVE,\n    toBytes(_c, point, isCompressed: boolean): Uint8Array {\n      const a = point.toAffine();\n      const x = Fp.toBytes(a.x);\n      const cat = ut.concatBytes;\n      if (isCompressed) {\n        return cat(Uint8Array.from([point.hasEvenY() ? 0x02 : 0x03]), x);\n      } else {\n        return cat(Uint8Array.from([0x04]), x, Fp.toBytes(a.y));\n      }\n    },\n    fromBytes(bytes: Uint8Array) {\n      const len = bytes.length;\n      const head = bytes[0];\n      const tail = bytes.subarray(1);\n      // this.assertValidity() is done inside of fromHex\n      if (len === compressedLen && (head === 0x02 || head === 0x03)) {\n        const x = ut.bytesToNumberBE(tail);\n        if (!isValidFieldElement(x)) throw new Error('Point is not on curve');\n        const y2 = weierstrassEquation(x); // y = x + ax + b\n        let y = Fp.sqrt(y2); // y = y ^ (p+1)/4\n        const isYOdd = (y & _1n) === _1n;\n        // ECDSA\n        const isHeadOdd = (head & 1) === 1;\n        if (isHeadOdd !== isYOdd) y = Fp.neg(y);\n        return { x, y };\n      } else if (len === uncompressedLen && head === 0x04) {\n        const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n        const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n        return { x, y };\n      } else {\n        throw new Error(\n          `Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`\n        );\n      }\n    },\n  });\n  const numToNByteStr = (num: bigint): string =>\n    ut.bytesToHex(ut.numberToBytesBE(num, CURVE.nByteLength));\n\n  function isBiggerThanHalfOrder(number: bigint) {\n    const HALF = CURVE_ORDER >> _1n;\n    return number > HALF;\n  }\n\n  function normalizeS(s: bigint) {\n    return isBiggerThanHalfOrder(s) ? modN(-s) : s;\n  }\n  // slice bytes num\n  const slcNum = (b: Uint8Array, from: number, to: number) => ut.bytesToNumberBE(b.slice(from, to));\n\n  /**\n   * ECDSA signature with its (r, s) properties. Supports DER & compact representations.\n   */\n  class Signature implements SignatureType {\n    constructor(readonly r: bigint, readonly s: bigint, readonly recovery?: number) {\n      this.assertValidity();\n    }\n\n    // pair (bytes of r, bytes of s)\n    static fromCompact(hex: Hex) {\n      const l = CURVE.nByteLength;\n      hex = ensureBytes('compactSignature', hex, l * 2);\n      return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));\n    }\n\n    // DER encoded ECDSA signature\n    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script\n    static fromDER(hex: Hex) {\n      const { r, s } = DER.toSig(ensureBytes('DER', hex));\n      return new Signature(r, s);\n    }\n\n    assertValidity(): void {\n      // can use assertGE here\n      if (!isWithinCurveOrder(this.r)) throw new Error('r must be 0 < r < CURVE.n');\n      if (!isWithinCurveOrder(this.s)) throw new Error('s must be 0 < s < CURVE.n');\n    }\n\n    addRecoveryBit(recovery: number): RecoveredSignature {\n      return new Signature(this.r, this.s, recovery) as RecoveredSignature;\n    }\n\n    recoverPublicKey(msgHash: Hex): typeof Point.BASE {\n      const { r, s, recovery: rec } = this;\n      const h = bits2int_modN(ensureBytes('msgHash', msgHash)); // Truncate hash\n      if (rec == null || ![0, 1, 2, 3].includes(rec)) throw new Error('recovery id invalid');\n      const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;\n      if (radj >= Fp.ORDER) throw new Error('recovery id 2 or 3 invalid');\n      const prefix = (rec & 1) === 0 ? '02' : '03';\n      const R = Point.fromHex(prefix + numToNByteStr(radj));\n      const ir = invN(radj); // r^-1\n      const u1 = modN(-h * ir); // -hr^-1\n      const u2 = modN(s * ir); // sr^-1\n      const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2); // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1)\n      if (!Q) throw new Error('point at infinify'); // unsafe is fine: no priv data leaked\n      Q.assertValidity();\n      return Q;\n    }\n\n    // Signatures should be low-s, to prevent malleability.\n    hasHighS(): boolean {\n      return isBiggerThanHalfOrder(this.s);\n    }\n\n    normalizeS() {\n      return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;\n    }\n\n    // DER-encoded\n    toDERRawBytes() {\n      return ut.hexToBytes(this.toDERHex());\n    }\n    toDERHex() {\n      return DER.hexFromSig({ r: this.r, s: this.s });\n    }\n\n    // padded bytes of r, then padded bytes of s\n    toCompactRawBytes() {\n      return ut.hexToBytes(this.toCompactHex());\n    }\n    toCompactHex() {\n      return numToNByteStr(this.r) + numToNByteStr(this.s);\n    }\n  }\n  type RecoveredSignature = Signature & { recovery: number };\n\n  const utils = {\n    isValidPrivateKey(privateKey: PrivKey) {\n      try {\n        normPrivateKeyToScalar(privateKey);\n        return true;\n      } catch (error) {\n        return false;\n      }\n    },\n    normPrivateKeyToScalar: normPrivateKeyToScalar,\n\n    /**\n     * Produces cryptographically secure private key from random of size\n     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.\n     */\n    randomPrivateKey: (): Uint8Array => {\n      const length = mod.getMinHashLength(CURVE.n);\n      return mod.mapHashToField(CURVE.randomBytes(length), CURVE.n);\n    },\n\n    /**\n     * Creates precompute table for an arbitrary EC point. Makes point \"cached\".\n     * Allows to massively speed-up `point.multiply(scalar)`.\n     * @returns cached point\n     * @example\n     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));\n     * fast.multiply(privKey); // much faster ECDH now\n     */\n    precompute(windowSize = 8, point = Point.BASE): typeof Point.BASE {\n      point._setWindowSize(windowSize);\n      point.multiply(BigInt(3)); // 3 is arbitrary, just need any number here\n      return point;\n    },\n  };\n\n  /**\n   * Computes public key for a private key. Checks for validity of the private key.\n   * @param privateKey private key\n   * @param isCompressed whether to return compact (default), or full key\n   * @returns Public key, full when isCompressed=false; short when isCompressed=true\n   */\n  function getPublicKey(privateKey: PrivKey, isCompressed = true): Uint8Array {\n    return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);\n  }\n\n  /**\n   * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.\n   */\n  function isProbPub(item: PrivKey | PubKey): boolean {\n    const arr = item instanceof Uint8Array;\n    const str = typeof item === 'string';\n    const len = (arr || str) && (item as Hex).length;\n    if (arr) return len === compressedLen || len === uncompressedLen;\n    if (str) return len === 2 * compressedLen || len === 2 * uncompressedLen;\n    if (item instanceof Point) return true;\n    return false;\n  }\n\n  /**\n   * ECDH (Elliptic Curve Diffie Hellman).\n   * Computes shared public key from private key and public key.\n   * Checks: 1) private key validity 2) shared key is on-curve.\n   * Does NOT hash the result.\n   * @param privateA private key\n   * @param publicB different public key\n   * @param isCompressed whether to return compact (default), or full key\n   * @returns shared public key\n   */\n  function getSharedSecret(privateA: PrivKey, publicB: Hex, isCompressed = true): Uint8Array {\n    if (isProbPub(privateA)) throw new Error('first arg must be private key');\n    if (!isProbPub(publicB)) throw new Error('second arg must be public key');\n    const b = Point.fromHex(publicB); // check for being on-curve\n    return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);\n  }\n\n  // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.\n  // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.\n  // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.\n  // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors\n  const bits2int =\n    CURVE.bits2int ||\n    function (bytes: Uint8Array): bigint {\n      // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)\n      // for some cases, since bytes.length * 8 is not actual bitLength.\n      const num = ut.bytesToNumberBE(bytes); // check for == u8 done here\n      const delta = bytes.length * 8 - CURVE.nBitLength; // truncate to nBitLength leftmost bits\n      return delta > 0 ? num >> BigInt(delta) : num;\n    };\n  const bits2int_modN =\n    CURVE.bits2int_modN ||\n    function (bytes: Uint8Array): bigint {\n      return modN(bits2int(bytes)); // can't use bytesToNumberBE here\n    };\n  // NOTE: pads output with zero as per spec\n  const ORDER_MASK = ut.bitMask(CURVE.nBitLength);\n  /**\n   * Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`.\n   */\n  function int2octets(num: bigint): Uint8Array {\n    if (typeof num !== 'bigint') throw new Error('bigint expected');\n    if (!(_0n <= num && num < ORDER_MASK))\n      throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);\n    // works with order, can have different size than numToField!\n    return ut.numberToBytesBE(num, CURVE.nByteLength);\n  }\n\n  // Steps A, D of RFC6979 3.2\n  // Creates RFC6979 seed; converts msg/privKey to numbers.\n  // Used only in sign, not in verify.\n  // NOTE: we cannot assume here that msgHash has same amount of bytes as curve order, this will be wrong at least for P521.\n  // Also it can be bigger for P224 + SHA256\n  function prepSig(msgHash: Hex, privateKey: PrivKey, opts = defaultSigOpts) {\n    if (['recovered', 'canonical'].some((k) => k in opts))\n      throw new Error('sign() legacy options not supported');\n    const { hash, randomBytes } = CURVE;\n    let { lowS, prehash, extraEntropy: ent } = opts; // generates low-s sigs by default\n    if (lowS == null) lowS = true; // RFC6979 3.2: we skip step A, because we already provide hash\n    msgHash = ensureBytes('msgHash', msgHash);\n    if (prehash) msgHash = ensureBytes('prehashed msgHash', hash(msgHash));\n\n    // We can't later call bits2octets, since nested bits2int is broken for curves\n    // with nBitLength % 8 !== 0. Because of that, we unwrap it here as int2octets call.\n    // const bits2octets = (bits) => int2octets(bits2int_modN(bits))\n    const h1int = bits2int_modN(msgHash);\n    const d = normPrivateKeyToScalar(privateKey); // validate private key, convert to bigint\n    const seedArgs = [int2octets(d), int2octets(h1int)];\n    // extraEntropy. RFC6979 3.6: additional k' (optional).\n    if (ent != null) {\n      // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')\n      const e = ent === true ? randomBytes(Fp.BYTES) : ent; // generate random bytes OR pass as-is\n      seedArgs.push(ensureBytes('extraEntropy', e)); // check for being bytes\n    }\n    const seed = ut.concatBytes(...seedArgs); // Step D of RFC6979 3.2\n    const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!\n    // Converts signature params into point w r/s, checks result for validity.\n    function k2sig(kBytes: Uint8Array): RecoveredSignature | undefined {\n      // RFC 6979 Section 3.2, step 3: k = bits2int(T)\n      const k = bits2int(kBytes); // Cannot use fields methods, since it is group element\n      if (!isWithinCurveOrder(k)) return; // Important: all mod() calls here must be done over N\n      const ik = invN(k); // k^-1 mod n\n      const q = Point.BASE.multiply(k).toAffine(); // q = Gk\n      const r = modN(q.x); // r = q.x mod n\n      if (r === _0n) return;\n      // Can use scalar blinding b^-1(bm + bdr) where b  [1,q1] according to\n      // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:\n      // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT\n      const s = modN(ik * modN(m + r * d)); // Not using blinding here\n      if (s === _0n) return;\n      let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3, when q.x > n)\n      let normS = s;\n      if (lowS && isBiggerThanHalfOrder(s)) {\n        normS = normalizeS(s); // if lowS was passed, ensure s is always\n        recovery ^= 1; // // in the bottom half of N\n      }\n      return new Signature(r, normS, recovery) as RecoveredSignature; // use normS, not s\n    }\n    return { seed, k2sig };\n  }\n  const defaultSigOpts: SignOpts = { lowS: CURVE.lowS, prehash: false };\n  const defaultVerOpts: VerOpts = { lowS: CURVE.lowS, prehash: false };\n\n  /**\n   * Signs message hash with a private key.\n   * ```\n   * sign(m, d, k) where\n   *   (x, y) = G  k\n   *   r = x mod n\n   *   s = (m + dr)/k mod n\n   * ```\n   * @param msgHash NOT message. msg needs to be hashed to `msgHash`, or use `prehash`.\n   * @param privKey private key\n   * @param opts lowS for non-malleable sigs. extraEntropy for mixing randomness into k. prehash will hash first arg.\n   * @returns signature with recovery param\n   */\n  function sign(msgHash: Hex, privKey: PrivKey, opts = defaultSigOpts): RecoveredSignature {\n    const { seed, k2sig } = prepSig(msgHash, privKey, opts); // Steps A, D of RFC6979 3.2.\n    const C = CURVE;\n    const drbg = ut.createHmacDrbg<RecoveredSignature>(C.hash.outputLen, C.nByteLength, C.hmac);\n    return drbg(seed, k2sig); // Steps B, C, D, E, F, G\n  }\n\n  // Enable precomputes. Slows down first publicKey computation by 20ms.\n  Point.BASE._setWindowSize(8);\n  // utils.precompute(8, ProjectivePoint.BASE)\n\n  /**\n   * Verifies a signature against message hash and public key.\n   * Rejects lowS signatures by default: to override,\n   * specify option `{lowS: false}`. Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:\n   *\n   * ```\n   * verify(r, s, h, P) where\n   *   U1 = hs^-1 mod n\n   *   U2 = rs^-1 mod n\n   *   R = U1G - U2P\n   *   mod(R.x, n) == r\n   * ```\n   */\n  function verify(\n    signature: Hex | SignatureLike,\n    msgHash: Hex,\n    publicKey: Hex,\n    opts = defaultVerOpts\n  ): boolean {\n    const sg = signature;\n    msgHash = ensureBytes('msgHash', msgHash);\n    publicKey = ensureBytes('publicKey', publicKey);\n    if ('strict' in opts) throw new Error('options.strict was renamed to lowS');\n    const { lowS, prehash } = opts;\n\n    let _sig: Signature | undefined = undefined;\n    let P: ProjPointType<bigint>;\n    try {\n      if (typeof sg === 'string' || sg instanceof Uint8Array) {\n        // Signature can be represented in 2 ways: compact (2*nByteLength) & DER (variable-length).\n        // Since DER can also be 2*nByteLength bytes, we check for it first.\n        try {\n          _sig = Signature.fromDER(sg);\n        } catch (derError) {\n          if (!(derError instanceof DER.Err)) throw derError;\n          _sig = Signature.fromCompact(sg);\n        }\n      } else if (typeof sg === 'object' && typeof sg.r === 'bigint' && typeof sg.s === 'bigint') {\n        const { r, s } = sg;\n        _sig = new Signature(r, s);\n      } else {\n        throw new Error('PARSE');\n      }\n      P = Point.fromHex(publicKey);\n    } catch (error) {\n      if ((error as Error).message === 'PARSE')\n        throw new Error(`signature must be Signature instance, Uint8Array or hex string`);\n      return false;\n    }\n    if (lowS && _sig.hasHighS()) return false;\n    if (prehash) msgHash = CURVE.hash(msgHash);\n    const { r, s } = _sig;\n    const h = bits2int_modN(msgHash); // Cannot use fields methods, since it is group element\n    const is = invN(s); // s^-1\n    const u1 = modN(h * is); // u1 = hs^-1 mod n\n    const u2 = modN(r * is); // u2 = rs^-1 mod n\n    const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine(); // R = u1G + u2P\n    if (!R) return false;\n    const v = modN(R.x);\n    return v === r;\n  }\n  return {\n    CURVE,\n    getPublicKey,\n    getSharedSecret,\n    sign,\n    verify,\n    ProjectivePoint: Point,\n    Signature,\n    utils,\n  };\n}\n\n/**\n * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.\n * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.\n * b = True and y = sqrt(u / v) if (u / v) is square in F, and\n * b = False and y = sqrt(Z * (u / v)) otherwise.\n * @param Fp\n * @param Z\n * @returns\n */\nexport function SWUFpSqrtRatio<T>(Fp: mod.IField<T>, Z: T) {\n  // Generic implementation\n  const q = Fp.ORDER;\n  let l = _0n;\n  for (let o = q - _1n; o % _2n === _0n; o /= _2n) l += _1n;\n  const c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.\n  // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.\n  // 2n ** c1 == 2n << (c1-1)\n  const _2n_pow_c1_1 = _2n << (c1 - _1n - _1n);\n  const _2n_pow_c1 = _2n_pow_c1_1 * _2n;\n  const c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic\n  const c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic\n  const c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic\n  const c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic\n  const c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2\n  const c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)\n  let sqrtRatio = (u: T, v: T): { isValid: boolean; value: T } => {\n    let tv1 = c6; // 1. tv1 = c6\n    let tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4\n    let tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2\n    tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v\n    let tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3\n    tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3\n    tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2\n    tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v\n    tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u\n    let tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2\n    tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5\n    let isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1\n    tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7\n    tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1\n    tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)\n    tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)\n    // 17. for i in (c1, c1 - 1, ..., 2):\n    for (let i = c1; i > _1n; i--) {\n      let tv5 = i - _2n; // 18.    tv5 = i - 2\n      tv5 = _2n << (tv5 - _1n); // 19.    tv5 = 2^tv5\n      let tvv5 = Fp.pow(tv4, tv5); // 20.    tv5 = tv4^tv5\n      const e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1\n      tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1\n      tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1\n      tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1\n      tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)\n      tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)\n    }\n    return { isValid: isQR, value: tv3 };\n  };\n  if (Fp.ORDER % _4n === _3n) {\n    // sqrt_ratio_3mod4(u, v)\n    const c1 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic\n    const c2 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)\n    sqrtRatio = (u: T, v: T) => {\n      let tv1 = Fp.sqr(v); // 1. tv1 = v^2\n      const tv2 = Fp.mul(u, v); // 2. tv2 = u * v\n      tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2\n      let y1 = Fp.pow(tv1, c1); // 4. y1 = tv1^c1\n      y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2\n      const y2 = Fp.mul(y1, c2); // 6. y2 = y1 * c2\n      const tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v\n      const isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u\n      let y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)\n      return { isValid: isQR, value: y }; // 11. return (isQR, y) isQR ? y : y*c2\n    };\n  }\n  // No curves uses that\n  // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8\n  return sqrtRatio;\n}\n/**\n * Simplified Shallue-van de Woestijne-Ulas Method\n * https://www.rfc-editor.org/rfc/rfc9380#section-6.6.2\n */\nexport function mapToCurveSimpleSWU<T>(\n  Fp: mod.IField<T>,\n  opts: {\n    A: T;\n    B: T;\n    Z: T;\n  }\n) {\n  mod.validateField(Fp);\n  if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z))\n    throw new Error('mapToCurveSimpleSWU: invalid opts');\n  const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);\n  if (!Fp.isOdd) throw new Error('Fp.isOdd is not implemented!');\n  // Input: u, an element of F.\n  // Output: (x, y), a point on E.\n  return (u: T): { x: T; y: T } => {\n    // prettier-ignore\n    let tv1, tv2, tv3, tv4, tv5, tv6, x, y;\n    tv1 = Fp.sqr(u); // 1.  tv1 = u^2\n    tv1 = Fp.mul(tv1, opts.Z); // 2.  tv1 = Z * tv1\n    tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2\n    tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1\n    tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1\n    tv3 = Fp.mul(tv3, opts.B); // 6.  tv3 = B * tv3\n    tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)\n    tv4 = Fp.mul(tv4, opts.A); // 8.  tv4 = A * tv4\n    tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2\n    tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2\n    tv5 = Fp.mul(tv6, opts.A); // 11. tv5 = A * tv6\n    tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5\n    tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3\n    tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4\n    tv5 = Fp.mul(tv6, opts.B); // 15. tv5 = B * tv6\n    tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5\n    x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3\n    const { isValid, value } = sqrtRatio(tv2, tv6); // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)\n    y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1\n    y = Fp.mul(y, value); // 20.   y = y * y1\n    x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)\n    y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)\n    const e1 = Fp.isOdd!(u) === Fp.isOdd!(y); // 23.  e1 = sgn0(u) == sgn0(y)\n    y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)\n    x = Fp.div(x, tv4); // 25.   x = x / tv4\n    return { x, y };\n  };\n}\n","/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { hmac } from '@noble/hashes/hmac';\nimport { concatBytes, randomBytes } from '@noble/hashes/utils';\nimport { weierstrass, CurveType } from './abstract/weierstrass.js';\nimport { CHash } from './abstract/utils.js';\n\n// connects noble-curves to noble-hashes\nexport function getHash(hash: CHash) {\n  return {\n    hash,\n    hmac: (key: Uint8Array, ...msgs: Uint8Array[]) => hmac(hash, key, concatBytes(...msgs)),\n    randomBytes,\n  };\n}\n// Same API as @noble/hashes, with ability to create curve with custom hash\ntype CurveDef = Readonly<Omit<CurveType, 'hash' | 'hmac' | 'randomBytes'>>;\nexport function createCurve(curveDef: CurveDef, defHash: CHash) {\n  const create = (hash: CHash) => weierstrass({ ...curveDef, ...getHash(hash) });\n  return Object.freeze({ ...create(defHash), create });\n}\n","/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { sha256 } from '@noble/hashes/sha256';\nimport { randomBytes } from '@noble/hashes/utils';\nimport { Field, mod, pow2 } from './abstract/modular.js';\nimport { ProjPointType as PointType, mapToCurveSimpleSWU } from './abstract/weierstrass.js';\nimport type { Hex, PrivKey } from './abstract/utils.js';\nimport { bytesToNumberBE, concatBytes, ensureBytes, numberToBytesBE } from './abstract/utils.js';\nimport { createHasher, isogenyMap } from './abstract/hash-to-curve.js';\nimport { createCurve } from './_shortw_utils.js';\n\nconst secp256k1P = BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f');\nconst secp256k1N = BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141');\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst divNearest = (a: bigint, b: bigint) => (a + b / _2n) / b;\n\n/**\n * n = n^((p+1)/4) for fields p = 3 mod 4. We unwrap the loop and multiply bit-by-bit.\n * (P+1n/4n).toString(2) would produce bits [223x 1, 0, 22x 1, 4x 0, 11, 00]\n */\nfunction sqrtMod(y: bigint): bigint {\n  const P = secp256k1P;\n  // prettier-ignore\n  const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);\n  // prettier-ignore\n  const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);\n  const b2 = (y * y * y) % P; // x^3, 11\n  const b3 = (b2 * b2 * y) % P; // x^7\n  const b6 = (pow2(b3, _3n, P) * b3) % P;\n  const b9 = (pow2(b6, _3n, P) * b3) % P;\n  const b11 = (pow2(b9, _2n, P) * b2) % P;\n  const b22 = (pow2(b11, _11n, P) * b11) % P;\n  const b44 = (pow2(b22, _22n, P) * b22) % P;\n  const b88 = (pow2(b44, _44n, P) * b44) % P;\n  const b176 = (pow2(b88, _88n, P) * b88) % P;\n  const b220 = (pow2(b176, _44n, P) * b44) % P;\n  const b223 = (pow2(b220, _3n, P) * b3) % P;\n  const t1 = (pow2(b223, _23n, P) * b22) % P;\n  const t2 = (pow2(t1, _6n, P) * b2) % P;\n  const root = pow2(t2, _2n, P);\n  if (!Fp.eql(Fp.sqr(root), y)) throw new Error('Cannot find square root');\n  return root;\n}\n\nconst Fp = Field(secp256k1P, undefined, undefined, { sqrt: sqrtMod });\n\nexport const secp256k1 = createCurve(\n  {\n    a: BigInt(0), // equation params: a, b\n    b: BigInt(7), // Seem to be rigid: bitcointalk.org/index.php?topic=289795.msg3183975#msg3183975\n    Fp, // Field's prime: 2n**256n - 2n**32n - 2n**9n - 2n**8n - 2n**7n - 2n**6n - 2n**4n - 1n\n    n: secp256k1N, // Curve order, total count of valid points in the field\n    // Base point (x, y) aka generator point\n    Gx: BigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240'),\n    Gy: BigInt('32670510020758816978083085130507043184471273380659243275938904335757337482424'),\n    h: BigInt(1), // Cofactor\n    lowS: true, // Allow only low-S signatures by default in sign() and verify()\n    /**\n     * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.\n     * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.\n     * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.\n     * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066\n     */\n    endo: {\n      beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),\n      splitScalar: (k: bigint) => {\n        const n = secp256k1N;\n        const a1 = BigInt('0x3086d221a7d46bcde86c90e49284eb15');\n        const b1 = -_1n * BigInt('0xe4437ed6010e88286f547fa90abfe4c3');\n        const a2 = BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8');\n        const b2 = a1;\n        const POW_2_128 = BigInt('0x100000000000000000000000000000000'); // (2n**128n).toString(16)\n\n        const c1 = divNearest(b2 * k, n);\n        const c2 = divNearest(-b1 * k, n);\n        let k1 = mod(k - c1 * a1 - c2 * a2, n);\n        let k2 = mod(-c1 * b1 - c2 * b2, n);\n        const k1neg = k1 > POW_2_128;\n        const k2neg = k2 > POW_2_128;\n        if (k1neg) k1 = n - k1;\n        if (k2neg) k2 = n - k2;\n        if (k1 > POW_2_128 || k2 > POW_2_128) {\n          throw new Error('splitScalar: Endomorphism failed, k=' + k);\n        }\n        return { k1neg, k1, k2neg, k2 };\n      },\n    },\n  },\n  sha256\n);\n\n// Schnorr signatures are superior to ECDSA from above. Below is Schnorr-specific BIP0340 code.\n// https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\nconst _0n = BigInt(0);\nconst fe = (x: bigint) => typeof x === 'bigint' && _0n < x && x < secp256k1P;\nconst ge = (x: bigint) => typeof x === 'bigint' && _0n < x && x < secp256k1N;\n/** An object mapping tags to their tagged hash prefix of [SHA256(tag) | SHA256(tag)] */\nconst TAGGED_HASH_PREFIXES: { [tag: string]: Uint8Array } = {};\nfunction taggedHash(tag: string, ...messages: Uint8Array[]): Uint8Array {\n  let tagP = TAGGED_HASH_PREFIXES[tag];\n  if (tagP === undefined) {\n    const tagH = sha256(Uint8Array.from(tag, (c) => c.charCodeAt(0)));\n    tagP = concatBytes(tagH, tagH);\n    TAGGED_HASH_PREFIXES[tag] = tagP;\n  }\n  return sha256(concatBytes(tagP, ...messages));\n}\n\n// ECDSA compact points are 33-byte. Schnorr is 32: we strip first byte 0x02 or 0x03\nconst pointToBytes = (point: PointType<bigint>) => point.toRawBytes(true).slice(1);\nconst numTo32b = (n: bigint) => numberToBytesBE(n, 32);\nconst modP = (x: bigint) => mod(x, secp256k1P);\nconst modN = (x: bigint) => mod(x, secp256k1N);\nconst Point = secp256k1.ProjectivePoint;\nconst GmulAdd = (Q: PointType<bigint>, a: bigint, b: bigint) =>\n  Point.BASE.multiplyAndAddUnsafe(Q, a, b);\n\n// Calculate point, scalar and bytes\nfunction schnorrGetExtPubKey(priv: PrivKey) {\n  let d_ = secp256k1.utils.normPrivateKeyToScalar(priv); // same method executed in fromPrivateKey\n  let p = Point.fromPrivateKey(d_); // P = d'G; 0 < d' < n check is done inside\n  const scalar = p.hasEvenY() ? d_ : modN(-d_);\n  return { scalar: scalar, bytes: pointToBytes(p) };\n}\n/**\n * lift_x from BIP340. Convert 32-byte x coordinate to elliptic curve point.\n * @returns valid point checked for being on-curve\n */\nfunction lift_x(x: bigint): PointType<bigint> {\n  if (!fe(x)) throw new Error('bad x: need 0 < x < p'); // Fail if x  p.\n  const xx = modP(x * x);\n  const c = modP(xx * x + BigInt(7)); // Let c = x + 7 mod p.\n  let y = sqrtMod(c); // Let y = c^(p+1)/4 mod p.\n  if (y % _2n !== _0n) y = modP(-y); // Return the unique point P such that x(P) = x and\n  const p = new Point(x, y, _1n); // y(P) = y if y mod 2 = 0 or y(P) = p-y otherwise.\n  p.assertValidity();\n  return p;\n}\n/**\n * Create tagged hash, convert it to bigint, reduce modulo-n.\n */\nfunction challenge(...args: Uint8Array[]): bigint {\n  return modN(bytesToNumberBE(taggedHash('BIP0340/challenge', ...args)));\n}\n\n/**\n * Schnorr public key is just `x` coordinate of Point as per BIP340.\n */\nfunction schnorrGetPublicKey(privateKey: Hex): Uint8Array {\n  return schnorrGetExtPubKey(privateKey).bytes; // d'=int(sk). Fail if d'=0 or d'n. Ret bytes(d'G)\n}\n\n/**\n * Creates Schnorr signature as per BIP340. Verifies itself before returning anything.\n * auxRand is optional and is not the sole source of k generation: bad CSPRNG won't be dangerous.\n */\nfunction schnorrSign(\n  message: Hex,\n  privateKey: PrivKey,\n  auxRand: Hex = randomBytes(32)\n): Uint8Array {\n  const m = ensureBytes('message', message);\n  const { bytes: px, scalar: d } = schnorrGetExtPubKey(privateKey); // checks for isWithinCurveOrder\n  const a = ensureBytes('auxRand', auxRand, 32); // Auxiliary random data a: a 32-byte array\n  const t = numTo32b(d ^ bytesToNumberBE(taggedHash('BIP0340/aux', a))); // Let t be the byte-wise xor of bytes(d) and hash/aux(a)\n  const rand = taggedHash('BIP0340/nonce', t, px, m); // Let rand = hash/nonce(t || bytes(P) || m)\n  const k_ = modN(bytesToNumberBE(rand)); // Let k' = int(rand) mod n\n  if (k_ === _0n) throw new Error('sign failed: k is zero'); // Fail if k' = 0.\n  const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_); // Let R = k'G.\n  const e = challenge(rx, px, m); // Let e = int(hash/challenge(bytes(R) || bytes(P) || m)) mod n.\n  const sig = new Uint8Array(64); // Let sig = bytes(R) || bytes((k + ed) mod n).\n  sig.set(rx, 0);\n  sig.set(numTo32b(modN(k + e * d)), 32);\n  // If Verify(bytes(P), m, sig) (see below) returns failure, abort\n  if (!schnorrVerify(sig, m, px)) throw new Error('sign: Invalid signature produced');\n  return sig;\n}\n\n/**\n * Verifies Schnorr signature.\n * Will swallow errors & return false except for initial type validation of arguments.\n */\nfunction schnorrVerify(signature: Hex, message: Hex, publicKey: Hex): boolean {\n  const sig = ensureBytes('signature', signature, 64);\n  const m = ensureBytes('message', message);\n  const pub = ensureBytes('publicKey', publicKey, 32);\n  try {\n    const P = lift_x(bytesToNumberBE(pub)); // P = lift_x(int(pk)); fail if that fails\n    const r = bytesToNumberBE(sig.subarray(0, 32)); // Let r = int(sig[0:32]); fail if r  p.\n    if (!fe(r)) return false;\n    const s = bytesToNumberBE(sig.subarray(32, 64)); // Let s = int(sig[32:64]); fail if s  n.\n    if (!ge(s)) return false;\n    const e = challenge(numTo32b(r), pointToBytes(P), m); // int(challenge(bytes(r)||bytes(P)||m))%n\n    const R = GmulAdd(P, s, modN(-e)); // R = sG - eP\n    if (!R || !R.hasEvenY() || R.toAffine().x !== r) return false; // -eP == (n-e)P\n    return true; // Fail if is_infinite(R) / not has_even_y(R) / x(R)  r.\n  } catch (error) {\n    return false;\n  }\n}\n\nexport const schnorr = /* @__PURE__ */ (() => ({\n  getPublicKey: schnorrGetPublicKey,\n  sign: schnorrSign,\n  verify: schnorrVerify,\n  utils: {\n    randomPrivateKey: secp256k1.utils.randomPrivateKey,\n    lift_x,\n    pointToBytes,\n    numberToBytesBE,\n    bytesToNumberBE,\n    taggedHash,\n    mod,\n  },\n}))();\n\nconst isoMap = /* @__PURE__ */ (() =>\n  isogenyMap(\n    Fp,\n    [\n      // xNum\n      [\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7',\n        '0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581',\n        '0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262',\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c',\n      ],\n      // xDen\n      [\n        '0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b',\n        '0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14',\n        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n      ],\n      // yNum\n      [\n        '0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c',\n        '0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3',\n        '0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931',\n        '0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84',\n      ],\n      // yDen\n      [\n        '0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b',\n        '0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573',\n        '0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f',\n        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n      ],\n    ].map((i) => i.map((j) => BigInt(j))) as [bigint[], bigint[], bigint[], bigint[]]\n  ))();\nconst mapSWU = /* @__PURE__ */ (() =>\n  mapToCurveSimpleSWU(Fp, {\n    A: BigInt('0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533'),\n    B: BigInt('1771'),\n    Z: Fp.create(BigInt('-11')),\n  }))();\nconst htf = /* @__PURE__ */ (() =>\n  createHasher(\n    secp256k1.ProjectivePoint,\n    (scalars: bigint[]) => {\n      const { x, y } = mapSWU(Fp.create(scalars[0]));\n      return isoMap(x, y);\n    },\n    {\n      DST: 'secp256k1_XMD:SHA-256_SSWU_RO_',\n      encodeDST: 'secp256k1_XMD:SHA-256_SSWU_NU_',\n      p: Fp.ORDER,\n      m: 1,\n      k: 128,\n      expand: 'xmd',\n      hash: sha256,\n    }\n  ))();\nexport const hashToCurve = /* @__PURE__ */ (() => htf.hashToCurve)();\nexport const encodeToCurve = /* @__PURE__ */ (() => htf.encodeToCurve)();\n","import { getVersion } from './utils.js'\n\ntype BaseErrorParameters = {\n  docsPath?: string\n  docsSlug?: string\n  metaMessages?: string[]\n} & (\n  | {\n      cause?: never\n      details?: string\n    }\n  | {\n      cause: BaseError | Error\n      details?: never\n    }\n)\n\nexport type BaseErrorType = BaseError & { name: 'ViemError' }\nexport class BaseError extends Error {\n  details: string\n  docsPath?: string\n  metaMessages?: string[]\n  shortMessage: string\n\n  override name = 'ViemError'\n  version = getVersion()\n\n  constructor(shortMessage: string, args: BaseErrorParameters = {}) {\n    super()\n\n    const details =\n      args.cause instanceof BaseError\n        ? args.cause.details\n        : args.cause?.message\n          ? args.cause.message\n          : args.details!\n    const docsPath =\n      args.cause instanceof BaseError\n        ? args.cause.docsPath || args.docsPath\n        : args.docsPath\n\n    this.message = [\n      shortMessage || 'An error occurred.',\n      '',\n      ...(args.metaMessages ? [...args.metaMessages, ''] : []),\n      ...(docsPath\n        ? [\n            `Docs: https://viem.sh${docsPath}.html${\n              args.docsSlug ? `#${args.docsSlug}` : ''\n            }`,\n          ]\n        : []),\n      ...(details ? [`Details: ${details}`] : []),\n      `Version: ${this.version}`,\n    ].join('\\n')\n\n    if (args.cause) this.cause = args.cause\n    this.details = details\n    this.docsPath = docsPath\n    this.metaMessages = args.metaMessages\n    this.shortMessage = shortMessage\n  }\n\n  walk(): Error\n  walk(fn: (err: unknown) => boolean): Error | null\n  walk(fn?: any): any {\n    return walk(this, fn)\n  }\n}\n\nfunction walk(err: unknown, fn?: (err: unknown) => boolean): unknown {\n  if (fn?.(err)) return err\n  if (err && typeof err === 'object' && 'cause' in err)\n    return walk(err.cause, fn)\n  return fn ? null : err\n}\n","import type { Address } from 'abitype'\n\nimport { version } from './version.js'\n\nexport type ErrorType<name extends string = 'Error'> = Error & { name: name }\n\nexport const getContractAddress = (address: Address) => address\nexport const getUrl = (url: string) => url\nexport const getVersion = () => `viem@${version}`\n","export const version = '1.21.3'\n","import type { ByteArray, Hex } from '../types/misc.js'\n\nimport { BaseError } from './base.js'\n\nexport type DataLengthTooLongErrorType = DataLengthTooLongError & {\n  name: 'DataLengthTooLongError'\n}\n/** @deprecated */\nexport class DataLengthTooLongError extends BaseError {\n  override name = 'DataLengthTooLongError'\n  constructor({ consumed, length }: { consumed: number; length: number }) {\n    super(\n      `Consumed bytes (${consumed}) is shorter than data length (${\n        length - 1\n      }).`,\n    )\n  }\n}\n\nexport type DataLengthTooShortErrorType = DataLengthTooShortError & {\n  name: 'DataLengthTooShortError'\n}\n/** @deprecated */\nexport class DataLengthTooShortError extends BaseError {\n  override name = 'DataLengthTooShortError'\n  constructor({ length, dataLength }: { length: number; dataLength: number }) {\n    super(\n      `Data length (${dataLength - 1}) is shorter than consumed bytes length (${\n        length - 1\n      }).`,\n    )\n  }\n}\n\nexport type IntegerOutOfRangeErrorType = IntegerOutOfRangeError & {\n  name: 'IntegerOutOfRangeError'\n}\nexport class IntegerOutOfRangeError extends BaseError {\n  override name = 'IntegerOutOfRangeError'\n  constructor({\n    max,\n    min,\n    signed,\n    size,\n    value,\n  }: {\n    max?: string\n    min: string\n    signed?: boolean\n    size?: number\n    value: string\n  }) {\n    super(\n      `Number \"${value}\" is not in safe ${\n        size ? `${size * 8}-bit ${signed ? 'signed' : 'unsigned'} ` : ''\n      }integer range ${max ? `(${min} to ${max})` : `(above ${min})`}`,\n    )\n  }\n}\n\nexport type InvalidBytesBooleanErrorType = InvalidBytesBooleanError & {\n  name: 'InvalidBytesBooleanError'\n}\nexport class InvalidBytesBooleanError extends BaseError {\n  override name = 'InvalidBytesBooleanError'\n  constructor(bytes: ByteArray) {\n    super(\n      `Bytes value \"${bytes}\" is not a valid boolean. The bytes array must contain a single byte of either a 0 or 1 value.`,\n    )\n  }\n}\n\nexport type InvalidHexBooleanErrorType = InvalidHexBooleanError & {\n  name: 'InvalidHexBooleanError'\n}\nexport class InvalidHexBooleanError extends BaseError {\n  override name = 'InvalidHexBooleanError'\n  constructor(hex: Hex) {\n    super(\n      `Hex value \"${hex}\" is not a valid boolean. The hex value must be \"0x0\" (false) or \"0x1\" (true).`,\n    )\n  }\n}\n\nexport type InvalidHexValueErrorType = InvalidHexValueError & {\n  name: 'InvalidHexValueError'\n}\nexport class InvalidHexValueError extends BaseError {\n  override name = 'InvalidHexValueError'\n  constructor(value: Hex) {\n    super(\n      `Hex value \"${value}\" is an odd length (${value.length}). It must be an even length.`,\n    )\n  }\n}\n\nexport type OffsetOutOfBoundsErrorType = OffsetOutOfBoundsError & {\n  name: 'OffsetOutOfBoundsError'\n}\n/** @deprecated */\nexport class OffsetOutOfBoundsError extends BaseError {\n  override name = 'OffsetOutOfBoundsError' as const\n  constructor({ nextOffset, offset }: { nextOffset: number; offset: number }) {\n    super(\n      `Next offset (${nextOffset}) is greater than previous offset + consumed bytes (${offset})`,\n    )\n  }\n}\n\nexport type SizeOverflowErrorType = SizeOverflowError & {\n  name: 'SizeOverflowError'\n}\nexport class SizeOverflowError extends BaseError {\n  override name = 'SizeOverflowError' as const\n  constructor({ givenSize, maxSize }: { givenSize: number; maxSize: number }) {\n    super(\n      `Size cannot exceed ${maxSize} bytes. Given size: ${givenSize} bytes.`,\n    )\n  }\n}\n","import { BaseError } from './base.js'\n\nexport type SliceOffsetOutOfBoundsErrorType = SliceOffsetOutOfBoundsError & {\n  name: 'SliceOffsetOutOfBoundsError'\n}\nexport class SliceOffsetOutOfBoundsError extends BaseError {\n  override name = 'SliceOffsetOutOfBoundsError'\n  constructor({\n    offset,\n    position,\n    size,\n  }: { offset: number; position: 'start' | 'end'; size: number }) {\n    super(\n      `Slice ${\n        position === 'start' ? 'starting' : 'ending'\n      } at offset \"${offset}\" is out-of-bounds (size: ${size}).`,\n    )\n  }\n}\n\nexport type SizeExceedsPaddingSizeErrorType = SizeExceedsPaddingSizeError & {\n  name: 'SizeExceedsPaddingSizeError'\n}\nexport class SizeExceedsPaddingSizeError extends BaseError {\n  override name = 'SizeExceedsPaddingSizeError'\n  constructor({\n    size,\n    targetSize,\n    type,\n  }: {\n    size: number\n    targetSize: number\n    type: 'hex' | 'bytes'\n  }) {\n    super(\n      `${type.charAt(0).toUpperCase()}${type\n        .slice(1)\n        .toLowerCase()} size (${size}) exceeds padding size (${targetSize}).`,\n    )\n  }\n}\n","import {\n  SizeExceedsPaddingSizeError,\n  type SizeExceedsPaddingSizeErrorType,\n} from '../../errors/data.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\n\ntype PadOptions = {\n  dir?: 'left' | 'right'\n  size?: number | null\n}\nexport type PadReturnType<TValue extends ByteArray | Hex> = TValue extends Hex\n  ? Hex\n  : ByteArray\n\nexport type PadErrorType = PadHexErrorType | PadBytesErrorType | ErrorType\n\nexport function pad<TValue extends ByteArray | Hex>(\n  hexOrBytes: TValue,\n  { dir, size = 32 }: PadOptions = {},\n): PadReturnType<TValue> {\n  if (typeof hexOrBytes === 'string')\n    return padHex(hexOrBytes, { dir, size }) as PadReturnType<TValue>\n  return padBytes(hexOrBytes, { dir, size }) as PadReturnType<TValue>\n}\n\nexport type PadHexErrorType = SizeExceedsPaddingSizeErrorType | ErrorType\n\nexport function padHex(hex_: Hex, { dir, size = 32 }: PadOptions = {}) {\n  if (size === null) return hex_\n  const hex = hex_.replace('0x', '')\n  if (hex.length > size * 2)\n    throw new SizeExceedsPaddingSizeError({\n      size: Math.ceil(hex.length / 2),\n      targetSize: size,\n      type: 'hex',\n    })\n\n  return `0x${hex[dir === 'right' ? 'padEnd' : 'padStart'](\n    size * 2,\n    '0',\n  )}` as Hex\n}\n\nexport type PadBytesErrorType = SizeExceedsPaddingSizeErrorType | ErrorType\n\nexport function padBytes(\n  bytes: ByteArray,\n  { dir, size = 32 }: PadOptions = {},\n) {\n  if (size === null) return bytes\n  if (bytes.length > size)\n    throw new SizeExceedsPaddingSizeError({\n      size: bytes.length,\n      targetSize: size,\n      type: 'bytes',\n    })\n  const paddedBytes = new Uint8Array(size)\n  for (let i = 0; i < size; i++) {\n    const padEnd = dir === 'right'\n    paddedBytes[padEnd ? i : size - i - 1] =\n      bytes[padEnd ? i : bytes.length - i - 1]\n  }\n  return paddedBytes\n}\n","import type { ErrorType } from '../../errors/utils.js'\nimport type { Hex } from '../../types/misc.js'\n\nexport type IsHexErrorType = ErrorType\n\nexport function isHex(\n  value: unknown,\n  { strict = true }: { strict?: boolean } = {},\n): value is Hex {\n  if (!value) return false\n  if (typeof value !== 'string') return false\n  return strict ? /^0x[0-9a-fA-F]*$/.test(value) : value.startsWith('0x')\n}\n","import type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\n\nimport { type IsHexErrorType, isHex } from './isHex.js'\n\nexport type SizeErrorType = IsHexErrorType | ErrorType\n\n/**\n * @description Retrieves the size of the value (in bytes).\n *\n * @param value The value (hex or byte array) to retrieve the size of.\n * @returns The size of the value (in bytes).\n */\nexport function size(value: Hex | ByteArray) {\n  if (isHex(value, { strict: false })) return Math.ceil((value.length - 2) / 2)\n  return value.length\n}\n","import {\n  InvalidHexBooleanError,\n  type InvalidHexBooleanErrorType,\n  SizeOverflowError,\n  type SizeOverflowErrorType,\n} from '../../errors/encoding.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { type SizeErrorType, size as size_ } from '../data/size.js'\nimport { type TrimErrorType, trim } from '../data/trim.js'\n\nimport { type HexToBytesErrorType, hexToBytes } from './toBytes.js'\n\nexport type AssertSizeErrorType =\n  | SizeOverflowErrorType\n  | SizeErrorType\n  | ErrorType\n\nexport function assertSize(\n  hexOrBytes: Hex | ByteArray,\n  { size }: { size: number },\n): void {\n  if (size_(hexOrBytes) > size)\n    throw new SizeOverflowError({\n      givenSize: size_(hexOrBytes),\n      maxSize: size,\n    })\n}\n\nexport type FromHexParameters<\n  TTo extends 'string' | 'bigint' | 'number' | 'bytes' | 'boolean',\n> =\n  | TTo\n  | {\n      /** Size (in bytes) of the hex value. */\n      size?: number\n      /** Type to convert to. */\n      to: TTo\n    }\n\nexport type FromHexReturnType<TTo> = TTo extends 'string'\n  ? string\n  : TTo extends 'bigint'\n    ? bigint\n    : TTo extends 'number'\n      ? number\n      : TTo extends 'bytes'\n        ? ByteArray\n        : TTo extends 'boolean'\n          ? boolean\n          : never\n\nexport type FromHexErrorType =\n  | HexToNumberErrorType\n  | HexToBigIntErrorType\n  | HexToBoolErrorType\n  | HexToStringErrorType\n  | HexToBytesErrorType\n  | ErrorType\n\n/**\n * Decodes a hex string into a string, number, bigint, boolean, or byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/fromHex.html\n * - Example: https://viem.sh/docs/utilities/fromHex.html#usage\n *\n * @param hex Hex string to decode.\n * @param toOrOpts Type to convert to or options.\n * @returns Decoded value.\n *\n * @example\n * import { fromHex } from 'viem'\n * const data = fromHex('0x1a4', 'number')\n * // 420\n *\n * @example\n * import { fromHex } from 'viem'\n * const data = fromHex('0x48656c6c6f20576f726c6421', 'string')\n * // 'Hello world'\n *\n * @example\n * import { fromHex } from 'viem'\n * const data = fromHex('0x48656c6c6f20576f726c64210000000000000000000000000000000000000000', {\n *   size: 32,\n *   to: 'string'\n * })\n * // 'Hello world'\n */\nexport function fromHex<\n  TTo extends 'string' | 'bigint' | 'number' | 'bytes' | 'boolean',\n>(hex: Hex, toOrOpts: FromHexParameters<TTo>): FromHexReturnType<TTo> {\n  const opts = typeof toOrOpts === 'string' ? { to: toOrOpts } : toOrOpts\n  const to = opts.to\n\n  if (to === 'number') return hexToNumber(hex, opts) as FromHexReturnType<TTo>\n  if (to === 'bigint') return hexToBigInt(hex, opts) as FromHexReturnType<TTo>\n  if (to === 'string') return hexToString(hex, opts) as FromHexReturnType<TTo>\n  if (to === 'boolean') return hexToBool(hex, opts) as FromHexReturnType<TTo>\n  return hexToBytes(hex, opts) as FromHexReturnType<TTo>\n}\n\nexport type HexToBigIntOpts = {\n  /** Whether or not the number of a signed representation. */\n  signed?: boolean\n  /** Size (in bytes) of the hex value. */\n  size?: number\n}\n\nexport type HexToBigIntErrorType = AssertSizeErrorType | ErrorType\n\n/**\n * Decodes a hex value into a bigint.\n *\n * - Docs: https://viem.sh/docs/utilities/fromHex.html#hextobigint\n *\n * @param hex Hex value to decode.\n * @param opts Options.\n * @returns BigInt value.\n *\n * @example\n * import { hexToBigInt } from 'viem'\n * const data = hexToBigInt('0x1a4', { signed: true })\n * // 420n\n *\n * @example\n * import { hexToBigInt } from 'viem'\n * const data = hexToBigInt('0x00000000000000000000000000000000000000000000000000000000000001a4', { size: 32 })\n * // 420n\n */\nexport function hexToBigInt(hex: Hex, opts: HexToBigIntOpts = {}): bigint {\n  const { signed } = opts\n\n  if (opts.size) assertSize(hex, { size: opts.size })\n\n  const value = BigInt(hex)\n  if (!signed) return value\n\n  const size = (hex.length - 2) / 2\n  const max = (1n << (BigInt(size) * 8n - 1n)) - 1n\n  if (value <= max) return value\n\n  return value - BigInt(`0x${'f'.padStart(size * 2, 'f')}`) - 1n\n}\n\nexport type HexToBoolOpts = {\n  /** Size (in bytes) of the hex value. */\n  size?: number\n}\n\nexport type HexToBoolErrorType =\n  | AssertSizeErrorType\n  | InvalidHexBooleanErrorType\n  | TrimErrorType\n  | ErrorType\n\n/**\n * Decodes a hex value into a boolean.\n *\n * - Docs: https://viem.sh/docs/utilities/fromHex.html#hextobool\n *\n * @param hex Hex value to decode.\n * @param opts Options.\n * @returns Boolean value.\n *\n * @example\n * import { hexToBool } from 'viem'\n * const data = hexToBool('0x01')\n * // true\n *\n * @example\n * import { hexToBool } from 'viem'\n * const data = hexToBool('0x0000000000000000000000000000000000000000000000000000000000000001', { size: 32 })\n * // true\n */\nexport function hexToBool(hex_: Hex, opts: HexToBoolOpts = {}): boolean {\n  let hex = hex_\n  if (opts.size) {\n    assertSize(hex, { size: opts.size })\n    hex = trim(hex)\n  }\n  if (trim(hex) === '0x00') return false\n  if (trim(hex) === '0x01') return true\n  throw new InvalidHexBooleanError(hex)\n}\n\nexport type HexToNumberOpts = HexToBigIntOpts\n\nexport type HexToNumberErrorType = HexToBigIntErrorType | ErrorType\n\n/**\n * Decodes a hex string into a number.\n *\n * - Docs: https://viem.sh/docs/utilities/fromHex.html#hextonumber\n *\n * @param hex Hex value to decode.\n * @param opts Options.\n * @returns Number value.\n *\n * @example\n * import { hexToNumber } from 'viem'\n * const data = hexToNumber('0x1a4')\n * // 420\n *\n * @example\n * import { hexToNumber } from 'viem'\n * const data = hexToBigInt('0x00000000000000000000000000000000000000000000000000000000000001a4', { size: 32 })\n * // 420\n */\nexport function hexToNumber(hex: Hex, opts: HexToNumberOpts = {}): number {\n  return Number(hexToBigInt(hex, opts))\n}\n\nexport type HexToStringOpts = {\n  /** Size (in bytes) of the hex value. */\n  size?: number\n}\n\nexport type HexToStringErrorType =\n  | AssertSizeErrorType\n  | HexToBytesErrorType\n  | TrimErrorType\n  | ErrorType\n\n/**\n * Decodes a hex value into a UTF-8 string.\n *\n * - Docs: https://viem.sh/docs/utilities/fromHex.html#hextostring\n *\n * @param hex Hex value to decode.\n * @param opts Options.\n * @returns String value.\n *\n * @example\n * import { hexToString } from 'viem'\n * const data = hexToString('0x48656c6c6f20576f726c6421')\n * // 'Hello world!'\n *\n * @example\n * import { hexToString } from 'viem'\n * const data = hexToString('0x48656c6c6f20576f726c64210000000000000000000000000000000000000000', {\n *  size: 32,\n * })\n * // 'Hello world'\n */\nexport function hexToString(hex: Hex, opts: HexToStringOpts = {}): string {\n  let bytes = hexToBytes(hex)\n  if (opts.size) {\n    assertSize(bytes, { size: opts.size })\n    bytes = trim(bytes, { dir: 'right' })\n  }\n  return new TextDecoder().decode(bytes)\n}\n","import {\n  IntegerOutOfRangeError,\n  type IntegerOutOfRangeErrorType,\n} from '../../errors/encoding.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { type PadErrorType, pad } from '../data/pad.js'\n\nimport { type AssertSizeErrorType, assertSize } from './fromHex.js'\n\nconst hexes = /*#__PURE__*/ Array.from({ length: 256 }, (_v, i) =>\n  i.toString(16).padStart(2, '0'),\n)\n\nexport type ToHexParameters = {\n  /** The size (in bytes) of the output hex value. */\n  size?: number\n}\n\nexport type ToHexErrorType =\n  | BoolToHexErrorType\n  | BytesToHexErrorType\n  | NumberToHexErrorType\n  | StringToHexErrorType\n  | ErrorType\n\n/**\n * Encodes a string, number, bigint, or ByteArray into a hex string\n *\n * - Docs: https://viem.sh/docs/utilities/toHex.html\n * - Example: https://viem.sh/docs/utilities/toHex.html#usage\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Hex value.\n *\n * @example\n * import { toHex } from 'viem'\n * const data = toHex('Hello world')\n * // '0x48656c6c6f20776f726c6421'\n *\n * @example\n * import { toHex } from 'viem'\n * const data = toHex(420)\n * // '0x1a4'\n *\n * @example\n * import { toHex } from 'viem'\n * const data = toHex('Hello world', { size: 32 })\n * // '0x48656c6c6f20776f726c64210000000000000000000000000000000000000000'\n */\nexport function toHex(\n  value: string | number | bigint | boolean | ByteArray,\n  opts: ToHexParameters = {},\n): Hex {\n  if (typeof value === 'number' || typeof value === 'bigint')\n    return numberToHex(value, opts)\n  if (typeof value === 'string') {\n    return stringToHex(value, opts)\n  }\n  if (typeof value === 'boolean') return boolToHex(value, opts)\n  return bytesToHex(value, opts)\n}\n\nexport type BoolToHexOpts = {\n  /** The size (in bytes) of the output hex value. */\n  size?: number\n}\n\nexport type BoolToHexErrorType = AssertSizeErrorType | PadErrorType | ErrorType\n\n/**\n * Encodes a boolean into a hex string\n *\n * - Docs: https://viem.sh/docs/utilities/toHex.html#booltohex\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Hex value.\n *\n * @example\n * import { boolToHex } from 'viem'\n * const data = boolToHex(true)\n * // '0x1'\n *\n * @example\n * import { boolToHex } from 'viem'\n * const data = boolToHex(false)\n * // '0x0'\n *\n * @example\n * import { boolToHex } from 'viem'\n * const data = boolToHex(true, { size: 32 })\n * // '0x0000000000000000000000000000000000000000000000000000000000000001'\n */\nexport function boolToHex(value: boolean, opts: BoolToHexOpts = {}): Hex {\n  const hex: Hex = `0x${Number(value)}`\n  if (typeof opts.size === 'number') {\n    assertSize(hex, { size: opts.size })\n    return pad(hex, { size: opts.size })\n  }\n  return hex\n}\n\nexport type BytesToHexOpts = {\n  /** The size (in bytes) of the output hex value. */\n  size?: number\n}\n\nexport type BytesToHexErrorType = AssertSizeErrorType | PadErrorType | ErrorType\n\n/**\n * Encodes a bytes array into a hex string\n *\n * - Docs: https://viem.sh/docs/utilities/toHex.html#bytestohex\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Hex value.\n *\n * @example\n * import { bytesToHex } from 'viem'\n * const data = bytesToHex(Uint8Array.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])\n * // '0x48656c6c6f20576f726c6421'\n *\n * @example\n * import { bytesToHex } from 'viem'\n * const data = bytesToHex(Uint8Array.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]), { size: 32 })\n * // '0x48656c6c6f20576f726c64210000000000000000000000000000000000000000'\n */\nexport function bytesToHex(value: ByteArray, opts: BytesToHexOpts = {}): Hex {\n  let string = ''\n  for (let i = 0; i < value.length; i++) {\n    string += hexes[value[i]]\n  }\n  const hex = `0x${string}` as const\n\n  if (typeof opts.size === 'number') {\n    assertSize(hex, { size: opts.size })\n    return pad(hex, { dir: 'right', size: opts.size })\n  }\n  return hex\n}\n\nexport type NumberToHexOpts =\n  | {\n      /** Whether or not the number of a signed representation. */\n      signed?: boolean\n      /** The size (in bytes) of the output hex value. */\n      size: number\n    }\n  | {\n      signed?: never\n      /** The size (in bytes) of the output hex value. */\n      size?: number\n    }\n\nexport type NumberToHexErrorType =\n  | IntegerOutOfRangeErrorType\n  | PadErrorType\n  | ErrorType\n\n/**\n * Encodes a number or bigint into a hex string\n *\n * - Docs: https://viem.sh/docs/utilities/toHex.html#numbertohex\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Hex value.\n *\n * @example\n * import { numberToHex } from 'viem'\n * const data = numberToHex(420)\n * // '0x1a4'\n *\n * @example\n * import { numberToHex } from 'viem'\n * const data = numberToHex(420, { size: 32 })\n * // '0x00000000000000000000000000000000000000000000000000000000000001a4'\n */\nexport function numberToHex(\n  value_: number | bigint,\n  opts: NumberToHexOpts = {},\n): Hex {\n  const { signed, size } = opts\n\n  const value = BigInt(value_)\n\n  let maxValue\n  if (size) {\n    if (signed) maxValue = (1n << (BigInt(size) * 8n - 1n)) - 1n\n    else maxValue = 2n ** (BigInt(size) * 8n) - 1n\n  } else if (typeof value_ === 'number') {\n    maxValue = BigInt(Number.MAX_SAFE_INTEGER)\n  }\n\n  const minValue = typeof maxValue === 'bigint' && signed ? -maxValue - 1n : 0\n\n  if ((maxValue && value > maxValue) || value < minValue) {\n    const suffix = typeof value_ === 'bigint' ? 'n' : ''\n    throw new IntegerOutOfRangeError({\n      max: maxValue ? `${maxValue}${suffix}` : undefined,\n      min: `${minValue}${suffix}`,\n      signed,\n      size,\n      value: `${value_}${suffix}`,\n    })\n  }\n\n  const hex = `0x${(signed && value < 0\n    ? (1n << BigInt(size * 8)) + BigInt(value)\n    : value\n  ).toString(16)}` as Hex\n  if (size) return pad(hex, { size }) as Hex\n  return hex\n}\n\nexport type StringToHexOpts = {\n  /** The size (in bytes) of the output hex value. */\n  size?: number\n}\n\nexport type StringToHexErrorType = BytesToHexErrorType | ErrorType\n\nconst encoder = /*#__PURE__*/ new TextEncoder()\n\n/**\n * Encodes a UTF-8 string into a hex string\n *\n * - Docs: https://viem.sh/docs/utilities/toHex.html#stringtohex\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Hex value.\n *\n * @example\n * import { stringToHex } from 'viem'\n * const data = stringToHex('Hello World!')\n * // '0x48656c6c6f20576f726c6421'\n *\n * @example\n * import { stringToHex } from 'viem'\n * const data = stringToHex('Hello World!', { size: 32 })\n * // '0x48656c6c6f20576f726c64210000000000000000000000000000000000000000'\n */\nexport function stringToHex(value_: string, opts: StringToHexOpts = {}): Hex {\n  const value = encoder.encode(value_)\n  return bytesToHex(value, opts)\n}\n","import { BaseError } from './base.js'\n\nexport type InvalidAddressErrorType = InvalidAddressError & {\n  name: 'InvalidAddressError'\n}\nexport class InvalidAddressError extends BaseError {\n  override name = 'InvalidAddressError'\n  constructor({ address }: { address: string }) {\n    super(`Address \"${address}\" is invalid.`)\n  }\n}\n","import type { Address } from 'abitype'\nimport type { ErrorType } from '../../errors/utils.js'\n\nconst addressRegex = /^0x[a-fA-F0-9]{40}$/\n\nexport type IsAddressErrorType = ErrorType\n\nexport function isAddress(address: string): address is Address {\n  return addressRegex.test(address)\n}\n","import { BaseError } from '../../errors/base.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { type IsHexErrorType, isHex } from '../data/isHex.js'\nimport { type PadErrorType, pad } from '../data/pad.js'\n\nimport { type AssertSizeErrorType, assertSize } from './fromHex.js'\nimport {\n  type NumberToHexErrorType,\n  type NumberToHexOpts,\n  numberToHex,\n} from './toHex.js'\n\nconst encoder = /*#__PURE__*/ new TextEncoder()\n\nexport type ToBytesParameters = {\n  /** Size of the output bytes. */\n  size?: number\n}\n\nexport type ToBytesErrorType =\n  | NumberToBytesErrorType\n  | BoolToBytesErrorType\n  | HexToBytesErrorType\n  | StringToBytesErrorType\n  | IsHexErrorType\n  | ErrorType\n\n/**\n * Encodes a UTF-8 string, hex value, bigint, number or boolean to a byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/toBytes.html\n * - Example: https://viem.sh/docs/utilities/toBytes.html#usage\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Byte array value.\n *\n * @example\n * import { toBytes } from 'viem'\n * const data = toBytes('Hello world')\n * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])\n *\n * @example\n * import { toBytes } from 'viem'\n * const data = toBytes(420)\n * // Uint8Array([1, 164])\n *\n * @example\n * import { toBytes } from 'viem'\n * const data = toBytes(420, { size: 4 })\n * // Uint8Array([0, 0, 1, 164])\n */\nexport function toBytes(\n  value: string | bigint | number | boolean | Hex,\n  opts: ToBytesParameters = {},\n): ByteArray {\n  if (typeof value === 'number' || typeof value === 'bigint')\n    return numberToBytes(value, opts)\n  if (typeof value === 'boolean') return boolToBytes(value, opts)\n  if (isHex(value)) return hexToBytes(value, opts)\n  return stringToBytes(value, opts)\n}\n\nexport type BoolToBytesOpts = {\n  /** Size of the output bytes. */\n  size?: number\n}\n\nexport type BoolToBytesErrorType =\n  | AssertSizeErrorType\n  | PadErrorType\n  | ErrorType\n\n/**\n * Encodes a boolean into a byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/toBytes.html#booltobytes\n *\n * @param value Boolean value to encode.\n * @param opts Options.\n * @returns Byte array value.\n *\n * @example\n * import { boolToBytes } from 'viem'\n * const data = boolToBytes(true)\n * // Uint8Array([1])\n *\n * @example\n * import { boolToBytes } from 'viem'\n * const data = boolToBytes(true, { size: 32 })\n * // Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1])\n */\nexport function boolToBytes(value: boolean, opts: BoolToBytesOpts = {}) {\n  const bytes = new Uint8Array(1)\n  bytes[0] = Number(value)\n  if (typeof opts.size === 'number') {\n    assertSize(bytes, { size: opts.size })\n    return pad(bytes, { size: opts.size })\n  }\n  return bytes\n}\n\n// We use very optimized technique to convert hex string to byte array\nconst charCodeMap = {\n  zero: 48,\n  nine: 57,\n  A: 65,\n  F: 70,\n  a: 97,\n  f: 102,\n} as const\n\nfunction charCodeToBase16(char: number) {\n  if (char >= charCodeMap.zero && char <= charCodeMap.nine)\n    return char - charCodeMap.zero\n  if (char >= charCodeMap.A && char <= charCodeMap.F)\n    return char - (charCodeMap.A - 10)\n  if (char >= charCodeMap.a && char <= charCodeMap.f)\n    return char - (charCodeMap.a - 10)\n  return undefined\n}\n\nexport type HexToBytesOpts = {\n  /** Size of the output bytes. */\n  size?: number\n}\n\nexport type HexToBytesErrorType = AssertSizeErrorType | PadErrorType | ErrorType\n\n/**\n * Encodes a hex string into a byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/toBytes.html#hextobytes\n *\n * @param hex Hex string to encode.\n * @param opts Options.\n * @returns Byte array value.\n *\n * @example\n * import { hexToBytes } from 'viem'\n * const data = hexToBytes('0x48656c6c6f20776f726c6421')\n * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])\n *\n * @example\n * import { hexToBytes } from 'viem'\n * const data = hexToBytes('0x48656c6c6f20776f726c6421', { size: 32 })\n * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n */\nexport function hexToBytes(hex_: Hex, opts: HexToBytesOpts = {}): ByteArray {\n  let hex = hex_\n  if (opts.size) {\n    assertSize(hex, { size: opts.size })\n    hex = pad(hex, { dir: 'right', size: opts.size })\n  }\n\n  let hexString = hex.slice(2) as string\n  if (hexString.length % 2) hexString = `0${hexString}`\n\n  const length = hexString.length / 2\n  const bytes = new Uint8Array(length)\n  for (let index = 0, j = 0; index < length; index++) {\n    const nibbleLeft = charCodeToBase16(hexString.charCodeAt(j++))\n    const nibbleRight = charCodeToBase16(hexString.charCodeAt(j++))\n    if (nibbleLeft === undefined || nibbleRight === undefined) {\n      throw new BaseError(\n        `Invalid byte sequence (\"${hexString[j - 2]}${\n          hexString[j - 1]\n        }\" in \"${hexString}\").`,\n      )\n    }\n    bytes[index] = nibbleLeft * 16 + nibbleRight\n  }\n  return bytes\n}\n\nexport type NumberToBytesErrorType =\n  | NumberToHexErrorType\n  | HexToBytesErrorType\n  | ErrorType\n\n/**\n * Encodes a number into a byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/toBytes.html#numbertobytes\n *\n * @param value Number to encode.\n * @param opts Options.\n * @returns Byte array value.\n *\n * @example\n * import { numberToBytes } from 'viem'\n * const data = numberToBytes(420)\n * // Uint8Array([1, 164])\n *\n * @example\n * import { numberToBytes } from 'viem'\n * const data = numberToBytes(420, { size: 4 })\n * // Uint8Array([0, 0, 1, 164])\n */\nexport function numberToBytes(value: bigint | number, opts?: NumberToHexOpts) {\n  const hex = numberToHex(value, opts)\n  return hexToBytes(hex)\n}\n\nexport type StringToBytesOpts = {\n  /** Size of the output bytes. */\n  size?: number\n}\n\nexport type StringToBytesErrorType =\n  | AssertSizeErrorType\n  | PadErrorType\n  | ErrorType\n\n/**\n * Encodes a UTF-8 string into a byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/toBytes.html#stringtobytes\n *\n * @param value String to encode.\n * @param opts Options.\n * @returns Byte array value.\n *\n * @example\n * import { stringToBytes } from 'viem'\n * const data = stringToBytes('Hello world!')\n * // Uint8Array([72, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100, 33])\n *\n * @example\n * import { stringToBytes } from 'viem'\n * const data = stringToBytes('Hello world!', { size: 32 })\n * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n */\nexport function stringToBytes(\n  value: string,\n  opts: StringToBytesOpts = {},\n): ByteArray {\n  const bytes = encoder.encode(value)\n  if (typeof opts.size === 'number') {\n    assertSize(bytes, { size: opts.size })\n    return pad(bytes, { dir: 'right', size: opts.size })\n  }\n  return bytes\n}\n","const U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\n\n// We are not using BigUint64Array, because they are extremely slow as per 2022\nfunction fromBig(n: bigint, le = false) {\n  if (le) return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n  return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\n\nfunction split(lst: bigint[], le = false) {\n  let Ah = new Uint32Array(lst.length);\n  let Al = new Uint32Array(lst.length);\n  for (let i = 0; i < lst.length; i++) {\n    const { h, l } = fromBig(lst[i], le);\n    [Ah[i], Al[i]] = [h, l];\n  }\n  return [Ah, Al];\n}\n\nconst toBig = (h: number, l: number) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h: number, _l: number, s: number) => h >>> s;\nconst shrSL = (h: number, l: number, s: number) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h: number, l: number, s: number) => (h >>> s) | (l << (32 - s));\nconst rotrSL = (h: number, l: number, s: number) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h: number, l: number, s: number) => (h << (64 - s)) | (l >>> (s - 32));\nconst rotrBL = (h: number, l: number, s: number) => (h >>> (s - 32)) | (l << (64 - s));\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h: number, l: number) => l;\nconst rotr32L = (h: number, _l: number) => h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h: number, l: number, s: number) => (h << s) | (l >>> (32 - s));\nconst rotlSL = (h: number, l: number, s: number) => (l << s) | (h >>> (32 - s));\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h: number, l: number, s: number) => (l << (s - 32)) | (h >>> (64 - s));\nconst rotlBL = (h: number, l: number, s: number) => (h << (s - 32)) | (l >>> (64 - s));\n\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(Ah: number, Al: number, Bh: number, Bl: number) {\n  const l = (Al >>> 0) + (Bl >>> 0);\n  return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\n// Addition with more than 2 elements\nconst add3L = (Al: number, Bl: number, Cl: number) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low: number, Ah: number, Bh: number, Ch: number) =>\n  (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nconst add4L = (Al: number, Bl: number, Cl: number, Dl: number) =>\n  (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low: number, Ah: number, Bh: number, Ch: number, Dh: number) =>\n  (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nconst add5L = (Al: number, Bl: number, Cl: number, Dl: number, El: number) =>\n  (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low: number, Ah: number, Bh: number, Ch: number, Dh: number, Eh: number) =>\n  (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\n\n// prettier-ignore\nexport {\n  fromBig, split, toBig,\n  shrSH, shrSL,\n  rotrSH, rotrSL, rotrBH, rotrBL,\n  rotr32H, rotr32L,\n  rotlSH, rotlSL, rotlBH, rotlBL,\n  add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\n// prettier-ignore\nconst u64 = {\n  fromBig, split, toBig,\n  shrSH, shrSL,\n  rotrSH, rotrSL, rotrBH, rotrBL,\n  rotr32H, rotr32L,\n  rotlSH, rotlSL, rotlBH, rotlBL,\n  add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\nexport default u64;\n","import { bytes, exists, number, output } from './_assert.js';\nimport { rotlBH, rotlBL, rotlSH, rotlSL, split } from './_u64.js';\nimport {\n  Hash,\n  u32,\n  Input,\n  toBytes,\n  wrapConstructor,\n  wrapXOFConstructorWithOpts,\n  HashXOF,\n} from './utils.js';\n\n// SHA3 (keccak) is based on a new design: basically, the internal state is bigger than output size.\n// It's called a sponge function.\n\n// Various per round constants calculations\nconst [SHA3_PI, SHA3_ROTL, _SHA3_IOTA]: [number[], number[], bigint[]] = [[], [], []];\nconst _0n = /* @__PURE__ */ BigInt(0);\nconst _1n = /* @__PURE__ */ BigInt(1);\nconst _2n = /* @__PURE__ */ BigInt(2);\nconst _7n = /* @__PURE__ */ BigInt(7);\nconst _256n = /* @__PURE__ */ BigInt(256);\nconst _0x71n = /* @__PURE__ */ BigInt(0x71);\nfor (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {\n  // Pi\n  [x, y] = [y, (2 * x + 3 * y) % 5];\n  SHA3_PI.push(2 * (5 * y + x));\n  // Rotational\n  SHA3_ROTL.push((((round + 1) * (round + 2)) / 2) % 64);\n  // Iota\n  let t = _0n;\n  for (let j = 0; j < 7; j++) {\n    R = ((R << _1n) ^ ((R >> _7n) * _0x71n)) % _256n;\n    if (R & _2n) t ^= _1n << ((_1n << /* @__PURE__ */ BigInt(j)) - _1n);\n  }\n  _SHA3_IOTA.push(t);\n}\nconst [SHA3_IOTA_H, SHA3_IOTA_L] = /* @__PURE__ */ split(_SHA3_IOTA, true);\n\n// Left rotation (without 0, 32, 64)\nconst rotlH = (h: number, l: number, s: number) => (s > 32 ? rotlBH(h, l, s) : rotlSH(h, l, s));\nconst rotlL = (h: number, l: number, s: number) => (s > 32 ? rotlBL(h, l, s) : rotlSL(h, l, s));\n\n// Same as keccakf1600, but allows to skip some rounds\nexport function keccakP(s: Uint32Array, rounds: number = 24) {\n  const B = new Uint32Array(5 * 2);\n  // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)\n  for (let round = 24 - rounds; round < 24; round++) {\n    // Theta \n    for (let x = 0; x < 10; x++) B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];\n    for (let x = 0; x < 10; x += 2) {\n      const idx1 = (x + 8) % 10;\n      const idx0 = (x + 2) % 10;\n      const B0 = B[idx0];\n      const B1 = B[idx0 + 1];\n      const Th = rotlH(B0, B1, 1) ^ B[idx1];\n      const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];\n      for (let y = 0; y < 50; y += 10) {\n        s[x + y] ^= Th;\n        s[x + y + 1] ^= Tl;\n      }\n    }\n    // Rho () and Pi ()\n    let curH = s[2];\n    let curL = s[3];\n    for (let t = 0; t < 24; t++) {\n      const shift = SHA3_ROTL[t];\n      const Th = rotlH(curH, curL, shift);\n      const Tl = rotlL(curH, curL, shift);\n      const PI = SHA3_PI[t];\n      curH = s[PI];\n      curL = s[PI + 1];\n      s[PI] = Th;\n      s[PI + 1] = Tl;\n    }\n    // Chi ()\n    for (let y = 0; y < 50; y += 10) {\n      for (let x = 0; x < 10; x++) B[x] = s[y + x];\n      for (let x = 0; x < 10; x++) s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];\n    }\n    // Iota ()\n    s[0] ^= SHA3_IOTA_H[round];\n    s[1] ^= SHA3_IOTA_L[round];\n  }\n  B.fill(0);\n}\n\nexport class Keccak extends Hash<Keccak> implements HashXOF<Keccak> {\n  protected state: Uint8Array;\n  protected pos = 0;\n  protected posOut = 0;\n  protected finished = false;\n  protected state32: Uint32Array;\n  protected destroyed = false;\n  // NOTE: we accept arguments in bytes instead of bits here.\n  constructor(\n    public blockLen: number,\n    public suffix: number,\n    public outputLen: number,\n    protected enableXOF = false,\n    protected rounds: number = 24\n  ) {\n    super();\n    // Can be passed from user as dkLen\n    number(outputLen);\n    // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes\n    if (0 >= this.blockLen || this.blockLen >= 200)\n      throw new Error('Sha3 supports only keccak-f1600 function');\n    this.state = new Uint8Array(200);\n    this.state32 = u32(this.state);\n  }\n  protected keccak() {\n    keccakP(this.state32, this.rounds);\n    this.posOut = 0;\n    this.pos = 0;\n  }\n  update(data: Input) {\n    exists(this);\n    const { blockLen, state } = this;\n    data = toBytes(data);\n    const len = data.length;\n    for (let pos = 0; pos < len; ) {\n      const take = Math.min(blockLen - this.pos, len - pos);\n      for (let i = 0; i < take; i++) state[this.pos++] ^= data[pos++];\n      if (this.pos === blockLen) this.keccak();\n    }\n    return this;\n  }\n  protected finish() {\n    if (this.finished) return;\n    this.finished = true;\n    const { state, suffix, pos, blockLen } = this;\n    // Do the padding\n    state[pos] ^= suffix;\n    if ((suffix & 0x80) !== 0 && pos === blockLen - 1) this.keccak();\n    state[blockLen - 1] ^= 0x80;\n    this.keccak();\n  }\n  protected writeInto(out: Uint8Array): Uint8Array {\n    exists(this, false);\n    bytes(out);\n    this.finish();\n    const bufferOut = this.state;\n    const { blockLen } = this;\n    for (let pos = 0, len = out.length; pos < len; ) {\n      if (this.posOut >= blockLen) this.keccak();\n      const take = Math.min(blockLen - this.posOut, len - pos);\n      out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);\n      this.posOut += take;\n      pos += take;\n    }\n    return out;\n  }\n  xofInto(out: Uint8Array): Uint8Array {\n    // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF\n    if (!this.enableXOF) throw new Error('XOF is not possible for this instance');\n    return this.writeInto(out);\n  }\n  xof(bytes: number): Uint8Array {\n    number(bytes);\n    return this.xofInto(new Uint8Array(bytes));\n  }\n  digestInto(out: Uint8Array) {\n    output(out, this);\n    if (this.finished) throw new Error('digest() was already called');\n    this.writeInto(out);\n    this.destroy();\n    return out;\n  }\n  digest() {\n    return this.digestInto(new Uint8Array(this.outputLen));\n  }\n  destroy() {\n    this.destroyed = true;\n    this.state.fill(0);\n  }\n  _cloneInto(to?: Keccak): Keccak {\n    const { blockLen, suffix, outputLen, rounds, enableXOF } = this;\n    to ||= new Keccak(blockLen, suffix, outputLen, enableXOF, rounds);\n    to.state32.set(this.state32);\n    to.pos = this.pos;\n    to.posOut = this.posOut;\n    to.finished = this.finished;\n    to.rounds = rounds;\n    // Suffix can change in cSHAKE\n    to.suffix = suffix;\n    to.outputLen = outputLen;\n    to.enableXOF = enableXOF;\n    to.destroyed = this.destroyed;\n    return to;\n  }\n}\n\nconst gen = (suffix: number, blockLen: number, outputLen: number) =>\n  wrapConstructor(() => new Keccak(blockLen, suffix, outputLen));\n\nexport const sha3_224 = /* @__PURE__ */ gen(0x06, 144, 224 / 8);\n/**\n * SHA3-256 hash function\n * @param message - that would be hashed\n */\nexport const sha3_256 = /* @__PURE__ */ gen(0x06, 136, 256 / 8);\nexport const sha3_384 = /* @__PURE__ */ gen(0x06, 104, 384 / 8);\nexport const sha3_512 = /* @__PURE__ */ gen(0x06, 72, 512 / 8);\nexport const keccak_224 = /* @__PURE__ */ gen(0x01, 144, 224 / 8);\n/**\n * keccak-256 hash function. Different from SHA3-256.\n * @param message - that would be hashed\n */\nexport const keccak_256 = /* @__PURE__ */ gen(0x01, 136, 256 / 8);\nexport const keccak_384 = /* @__PURE__ */ gen(0x01, 104, 384 / 8);\nexport const keccak_512 = /* @__PURE__ */ gen(0x01, 72, 512 / 8);\n\nexport type ShakeOpts = { dkLen?: number };\n\nconst genShake = (suffix: number, blockLen: number, outputLen: number) =>\n  wrapXOFConstructorWithOpts<HashXOF<Keccak>, ShakeOpts>(\n    (opts: ShakeOpts = {}) =>\n      new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true)\n  );\n\nexport const shake128 = /* @__PURE__ */ genShake(0x1f, 168, 128 / 8);\nexport const shake256 = /* @__PURE__ */ genShake(0x1f, 136, 256 / 8);\n","import { keccak_256 } from '@noble/hashes/sha3'\n\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { type IsHexErrorType, isHex } from '../data/isHex.js'\nimport { type ToBytesErrorType, toBytes } from '../encoding/toBytes.js'\nimport { type ToHexErrorType, toHex } from '../encoding/toHex.js'\n\ntype To = 'hex' | 'bytes'\n\nexport type Keccak256Hash<TTo extends To> =\n  | (TTo extends 'bytes' ? ByteArray : never)\n  | (TTo extends 'hex' ? Hex : never)\n\nexport type Keccak256ErrorType =\n  | IsHexErrorType\n  | ToBytesErrorType\n  | ToHexErrorType\n  | ErrorType\n\nexport function keccak256<TTo extends To = 'hex'>(\n  value: Hex | ByteArray,\n  to_?: TTo,\n): Keccak256Hash<TTo> {\n  const to = to_ || 'hex'\n  const bytes = keccak_256(\n    isHex(value, { strict: false }) ? toBytes(value) : value,\n  )\n  if (to === 'bytes') return bytes as Keccak256Hash<TTo>\n  return toHex(bytes) as Keccak256Hash<TTo>\n}\n","import type { Address } from 'abitype'\n\nimport { InvalidAddressError } from '../../errors/address.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport {\n  type StringToBytesErrorType,\n  stringToBytes,\n} from '../encoding/toBytes.js'\nimport { type Keccak256ErrorType, keccak256 } from '../hash/keccak256.js'\nimport { type IsAddressErrorType, isAddress } from './isAddress.js'\n\nexport type ChecksumAddressErrorType =\n  | Keccak256ErrorType\n  | StringToBytesErrorType\n  | ErrorType\n\nexport function checksumAddress(address_: Address, chainId?: number): Address {\n  const hexAddress = chainId\n    ? `${chainId}${address_.toLowerCase()}`\n    : address_.substring(2).toLowerCase()\n  const hash = keccak256(stringToBytes(hexAddress), 'bytes')\n\n  const address = (\n    chainId ? hexAddress.substring(`${chainId}0x`.length) : hexAddress\n  ).split('')\n  for (let i = 0; i < 40; i += 2) {\n    if (hash[i >> 1] >> 4 >= 8 && address[i]) {\n      address[i] = address[i].toUpperCase()\n    }\n    if ((hash[i >> 1] & 0x0f) >= 8 && address[i + 1]) {\n      address[i + 1] = address[i + 1].toUpperCase()\n    }\n  }\n\n  return `0x${address.join('')}`\n}\n\nexport type GetAddressErrorType =\n  | ChecksumAddressErrorType\n  | IsAddressErrorType\n  | ErrorType\n\nexport function getAddress(address: string, chainId?: number): Address {\n  if (!isAddress(address)) throw new InvalidAddressError({ address })\n  return checksumAddress(address, chainId)\n}\n","import type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\n\nexport type ConcatReturnType<TValue extends Hex | ByteArray> =\n  TValue extends Hex ? Hex : ByteArray\n\nexport type ConcatErrorType =\n  | ConcatBytesErrorType\n  | ConcatHexErrorType\n  | ErrorType\n\nexport function concat<TValue extends Hex | ByteArray>(\n  values: readonly TValue[],\n): ConcatReturnType<TValue> {\n  if (typeof values[0] === 'string')\n    return concatHex(values as readonly Hex[]) as ConcatReturnType<TValue>\n  return concatBytes(values as readonly ByteArray[]) as ConcatReturnType<TValue>\n}\n\nexport type ConcatBytesErrorType = ErrorType\n\nexport function concatBytes(values: readonly ByteArray[]): ByteArray {\n  let length = 0\n  for (const arr of values) {\n    length += arr.length\n  }\n  const result = new Uint8Array(length)\n  let offset = 0\n  for (const arr of values) {\n    result.set(arr, offset)\n    offset += arr.length\n  }\n  return result\n}\n\nexport type ConcatHexErrorType = ErrorType\n\nexport function concatHex(values: readonly Hex[]): Hex {\n  return `0x${(values as Hex[]).reduce(\n    (acc, x) => acc + x.replace('0x', ''),\n    '',\n  )}`\n}\n","import { presignMessagePrefix } from '../../constants/strings.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex, SignableMessage } from '../../types/misc.js'\nimport { type ConcatErrorType, concat } from '../data/concat.js'\nimport {\n  type StringToBytesErrorType,\n  type ToBytesErrorType,\n  stringToBytes,\n  toBytes,\n} from '../encoding/toBytes.js'\nimport { type Keccak256ErrorType, keccak256 } from '../hash/keccak256.js'\n\ntype To = 'hex' | 'bytes'\n\nexport type HashMessage<TTo extends To> =\n  | (TTo extends 'bytes' ? ByteArray : never)\n  | (TTo extends 'hex' ? Hex : never)\n\nexport type HashMessageErrorType =\n  | ConcatErrorType\n  | Keccak256ErrorType\n  | StringToBytesErrorType\n  | ToBytesErrorType\n  | ErrorType\n\nexport function hashMessage<TTo extends To = 'hex'>(\n  message: SignableMessage,\n  to_?: TTo,\n): HashMessage<TTo> {\n  const messageBytes = (() => {\n    if (typeof message === 'string') return stringToBytes(message)\n    if (message.raw instanceof Uint8Array) return message.raw\n    return toBytes(message.raw)\n  })()\n  const prefixBytes = stringToBytes(\n    `${presignMessagePrefix}${messageBytes.length}`,\n  )\n  return keccak256(concat([prefixBytes, messageBytes]), to_)\n}\n","export const presignMessagePrefix = '\\x19Ethereum Signed Message:\\n'\n","import { secp256k1 } from '@noble/curves/secp256k1'\n\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Hex, Signature } from '../../types/misc.js'\nimport {\n  type HexToBigIntErrorType,\n  hexToBigInt,\n} from '../../utils/encoding/fromHex.js'\nimport { type ToHexErrorType, toHex } from '../../utils/encoding/toHex.js'\n\nexport type SignatureToHexErrorType =\n  | HexToBigIntErrorType\n  | ToHexErrorType\n  | ErrorType\n\n/**\n * @description Converts a signature into hex format.\n *\n * @param signature The signature to convert.\n * @returns The signature in hex format.\n *\n * @example\n * signatureToHex({\n *   r: '0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf',\n *   s: '0x4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db8',\n *   v: 28n\n * })\n * // \"0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db81c\"\n */\nexport function signatureToHex({ r, s, v }: Signature): Hex {\n  return `0x${new secp256k1.Signature(\n    hexToBigInt(r),\n    hexToBigInt(s),\n  ).toCompactHex()}${toHex(v).slice(2)}`\n}\n","import { secp256k1 } from '@noble/curves/secp256k1'\n\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Hex, Signature } from '../../types/misc.js'\nimport { type ToHexErrorType, toHex } from '../../utils/encoding/toHex.js'\n\nexport type SignParameters = {\n  hash: Hex\n  privateKey: Hex\n}\n\nexport type SignReturnType = Signature\n\nexport type SignErrorType = ToHexErrorType | ErrorType\n\n/**\n * @description Signs a hash with a given private key.\n *\n * @param hash The hash to sign.\n * @param privateKey The private key to sign with.\n *\n * @returns The signature.\n */\nexport async function sign({\n  hash,\n  privateKey,\n}: SignParameters): Promise<SignReturnType> {\n  const { r, s, recovery } = secp256k1.sign(hash.slice(2), privateKey.slice(2))\n  return {\n    r: toHex(r),\n    s: toHex(s),\n    v: recovery ? 28n : 27n,\n  }\n}\n","export const etherUnits = {\n  gwei: 9,\n  wei: 18,\n}\nexport const gweiUnits = {\n  ether: -9,\n  wei: 9,\n}\nexport const weiUnits = {\n  ether: -18,\n  gwei: -9,\n}\n","import type { ErrorType } from '../../errors/utils.js'\n\nexport type FormatUnitsErrorType = ErrorType\n\n/**\n *  Divides a number by a given exponent of base 10 (10exponent), and formats it into a string representation of the number..\n *\n * - Docs: https://viem.sh/docs/utilities/formatUnits.html\n *\n * @example\n * import { formatUnits } from 'viem'\n *\n * formatUnits(420000000000n, 9)\n * // '420'\n */\nexport function formatUnits(value: bigint, decimals: number) {\n  let display = value.toString()\n\n  const negative = display.startsWith('-')\n  if (negative) display = display.slice(1)\n\n  display = display.padStart(decimals, '0')\n\n  let [integer, fraction] = [\n    display.slice(0, display.length - decimals),\n    display.slice(display.length - decimals),\n  ]\n  fraction = fraction.replace(/(0+)$/, '')\n  return `${negative ? '-' : ''}${integer || '0'}${\n    fraction ? `.${fraction}` : ''\n  }`\n}\n","import { gweiUnits } from '../../constants/unit.js'\n\nimport { type FormatUnitsErrorType, formatUnits } from './formatUnits.js'\n\nexport type FormatGweiErrorType = FormatUnitsErrorType\n\n/**\n * Converts numerical wei to a string representation of gwei.\n *\n * - Docs: https://viem.sh/docs/utilities/formatGwei.html\n *\n * @example\n * import { formatGwei } from 'viem'\n *\n * formatGwei(1000000000n)\n * // '1'\n */\nexport function formatGwei(wei: bigint, unit: 'wei' = 'wei') {\n  return formatUnits(wei, gweiUnits[unit])\n}\n","import type { Account } from '../accounts/types.js'\nimport type { SendTransactionParameters } from '../actions/wallet/sendTransaction.js'\nimport type { BlockTag } from '../types/block.js'\nimport type { Chain } from '../types/chain.js'\nimport type { Hash, Hex } from '../types/misc.js'\nimport type { TransactionType } from '../types/transaction.js'\nimport { formatEther } from '../utils/unit/formatEther.js'\nimport { formatGwei } from '../utils/unit/formatGwei.js'\n\nimport { BaseError } from './base.js'\n\nexport function prettyPrint(\n  args: Record<string, bigint | number | string | undefined | false | unknown>,\n) {\n  const entries = Object.entries(args)\n    .map(([key, value]) => {\n      if (value === undefined || value === false) return null\n      return [key, value]\n    })\n    .filter(Boolean) as [string, string][]\n  const maxLength = entries.reduce((acc, [key]) => Math.max(acc, key.length), 0)\n  return entries\n    .map(([key, value]) => `  ${`${key}:`.padEnd(maxLength + 1)}  ${value}`)\n    .join('\\n')\n}\n\nexport type FeeConflictErrorType = FeeConflictError & {\n  name: 'FeeConflictError'\n}\nexport class FeeConflictError extends BaseError {\n  override name = 'FeeConflictError'\n  constructor() {\n    super(\n      [\n        'Cannot specify both a `gasPrice` and a `maxFeePerGas`/`maxPriorityFeePerGas`.',\n        'Use `maxFeePerGas`/`maxPriorityFeePerGas` for EIP-1559 compatible networks, and `gasPrice` for others.',\n      ].join('\\n'),\n    )\n  }\n}\n\nexport type InvalidLegacyVErrorType = InvalidLegacyVError & {\n  name: 'InvalidLegacyVError'\n}\nexport class InvalidLegacyVError extends BaseError {\n  override name = 'InvalidLegacyVError'\n\n  constructor({ v }: { v: bigint }) {\n    super(`Invalid \\`v\\` value \"${v}\". Expected 27 or 28.`)\n  }\n}\n\nexport type InvalidSerializableTransactionErrorType =\n  InvalidSerializableTransactionError & {\n    name: 'InvalidSerializableTransactionError'\n  }\nexport class InvalidSerializableTransactionError extends BaseError {\n  override name = 'InvalidSerializableTransactionError'\n\n  constructor({ transaction }: { transaction: Record<string, unknown> }) {\n    super('Cannot infer a transaction type from provided transaction.', {\n      metaMessages: [\n        'Provided Transaction:',\n        '{',\n        prettyPrint(transaction),\n        '}',\n        '',\n        'To infer the type, either provide:',\n        '- a `type` to the Transaction, or',\n        '- an EIP-1559 Transaction with `maxFeePerGas`, or',\n        '- an EIP-2930 Transaction with `gasPrice` & `accessList`, or',\n        '- a Legacy Transaction with `gasPrice`',\n      ],\n    })\n  }\n}\n\nexport type InvalidSerializedTransactionTypeErrorType =\n  InvalidSerializedTransactionTypeError & {\n    name: 'InvalidSerializedTransactionTypeError'\n  }\nexport class InvalidSerializedTransactionTypeError extends BaseError {\n  override name = 'InvalidSerializedTransactionType'\n\n  serializedType: Hex\n\n  constructor({ serializedType }: { serializedType: Hex }) {\n    super(`Serialized transaction type \"${serializedType}\" is invalid.`)\n\n    this.serializedType = serializedType\n  }\n}\n\nexport type InvalidSerializedTransactionErrorType =\n  InvalidSerializedTransactionError & {\n    name: 'InvalidSerializedTransactionError'\n  }\nexport class InvalidSerializedTransactionError extends BaseError {\n  override name = 'InvalidSerializedTransactionError'\n\n  serializedTransaction: Hex\n  type: TransactionType\n\n  constructor({\n    attributes,\n    serializedTransaction,\n    type,\n  }: {\n    attributes: Record<string, unknown>\n    serializedTransaction: Hex\n    type: TransactionType\n  }) {\n    const missing = Object.entries(attributes)\n      .map(([key, value]) => (typeof value === 'undefined' ? key : undefined))\n      .filter(Boolean)\n    super(`Invalid serialized transaction of type \"${type}\" was provided.`, {\n      metaMessages: [\n        `Serialized Transaction: \"${serializedTransaction}\"`,\n        missing.length > 0 ? `Missing Attributes: ${missing.join(', ')}` : '',\n      ].filter(Boolean),\n    })\n\n    this.serializedTransaction = serializedTransaction\n    this.type = type\n  }\n}\n\nexport type InvalidStorageKeySizeErrorType = InvalidStorageKeySizeError & {\n  name: 'InvalidStorageKeySizeError'\n}\nexport class InvalidStorageKeySizeError extends BaseError {\n  override name = 'InvalidStorageKeySizeError'\n\n  constructor({ storageKey }: { storageKey: Hex }) {\n    super(\n      `Size for storage key \"${storageKey}\" is invalid. Expected 32 bytes. Got ${Math.floor(\n        (storageKey.length - 2) / 2,\n      )} bytes.`,\n    )\n  }\n}\n\nexport type TransactionExecutionErrorType = TransactionExecutionError & {\n  name: 'TransactionExecutionError'\n}\nexport class TransactionExecutionError extends BaseError {\n  override cause: BaseError\n\n  override name = 'TransactionExecutionError'\n\n  constructor(\n    cause: BaseError,\n    {\n      account,\n      docsPath,\n      chain,\n      data,\n      gas,\n      gasPrice,\n      maxFeePerGas,\n      maxPriorityFeePerGas,\n      nonce,\n      to,\n      value,\n    }: Omit<SendTransactionParameters, 'account' | 'chain'> & {\n      account: Account\n      chain?: Chain\n      docsPath?: string\n    },\n  ) {\n    const prettyArgs = prettyPrint({\n      chain: chain && `${chain?.name} (id: ${chain?.id})`,\n      from: account?.address,\n      to,\n      value:\n        typeof value !== 'undefined' &&\n        `${formatEther(value)} ${chain?.nativeCurrency?.symbol || 'ETH'}`,\n      data,\n      gas,\n      gasPrice:\n        typeof gasPrice !== 'undefined' && `${formatGwei(gasPrice)} gwei`,\n      maxFeePerGas:\n        typeof maxFeePerGas !== 'undefined' &&\n        `${formatGwei(maxFeePerGas)} gwei`,\n      maxPriorityFeePerGas:\n        typeof maxPriorityFeePerGas !== 'undefined' &&\n        `${formatGwei(maxPriorityFeePerGas)} gwei`,\n      nonce,\n    })\n\n    super(cause.shortMessage, {\n      cause,\n      docsPath,\n      metaMessages: [\n        ...(cause.metaMessages ? [...cause.metaMessages, ' '] : []),\n        'Request Arguments:',\n        prettyArgs,\n      ].filter(Boolean) as string[],\n    })\n    this.cause = cause\n  }\n}\n\nexport type TransactionNotFoundErrorType = TransactionNotFoundError & {\n  name: 'TransactionNotFoundError'\n}\nexport class TransactionNotFoundError extends BaseError {\n  override name = 'TransactionNotFoundError'\n  constructor({\n    blockHash,\n    blockNumber,\n    blockTag,\n    hash,\n    index,\n  }: {\n    blockHash?: Hash\n    blockNumber?: bigint\n    blockTag?: BlockTag\n    hash?: Hash\n    index?: number\n  }) {\n    let identifier = 'Transaction'\n    if (blockTag && index !== undefined)\n      identifier = `Transaction at block time \"${blockTag}\" at index \"${index}\"`\n    if (blockHash && index !== undefined)\n      identifier = `Transaction at block hash \"${blockHash}\" at index \"${index}\"`\n    if (blockNumber && index !== undefined)\n      identifier = `Transaction at block number \"${blockNumber}\" at index \"${index}\"`\n    if (hash) identifier = `Transaction with hash \"${hash}\"`\n    super(`${identifier} could not be found.`)\n  }\n}\n\nexport type TransactionReceiptNotFoundErrorType =\n  TransactionReceiptNotFoundError & {\n    name: 'TransactionReceiptNotFoundError'\n  }\nexport class TransactionReceiptNotFoundError extends BaseError {\n  override name = 'TransactionReceiptNotFoundError'\n  constructor({ hash }: { hash: Hash }) {\n    super(\n      `Transaction receipt with hash \"${hash}\" could not be found. The Transaction may not be processed on a block yet.`,\n    )\n  }\n}\n\nexport type WaitForTransactionReceiptTimeoutErrorType =\n  WaitForTransactionReceiptTimeoutError & {\n    name: 'WaitForTransactionReceiptTimeoutError'\n  }\nexport class WaitForTransactionReceiptTimeoutError extends BaseError {\n  override name = 'WaitForTransactionReceiptTimeoutError'\n  constructor({ hash }: { hash: Hash }) {\n    super(\n      `Timed out while waiting for transaction with hash \"${hash}\" to be confirmed.`,\n    )\n  }\n}\n","import type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\n\ntype TrimOptions = {\n  dir?: 'left' | 'right'\n}\nexport type TrimReturnType<TValue extends ByteArray | Hex> = TValue extends Hex\n  ? Hex\n  : ByteArray\n\nexport type TrimErrorType = ErrorType\n\nexport function trim<TValue extends ByteArray | Hex>(\n  hexOrBytes: TValue,\n  { dir = 'left' }: TrimOptions = {},\n): TrimReturnType<TValue> {\n  let data: any =\n    typeof hexOrBytes === 'string' ? hexOrBytes.replace('0x', '') : hexOrBytes\n\n  let sliceLength = 0\n  for (let i = 0; i < data.length - 1; i++) {\n    if (data[dir === 'left' ? i : data.length - i - 1].toString() === '0')\n      sliceLength++\n    else break\n  }\n  data =\n    dir === 'left'\n      ? data.slice(sliceLength)\n      : data.slice(0, data.length - sliceLength)\n\n  if (typeof hexOrBytes === 'string') {\n    if (data.length === 1 && dir === 'right') data = `${data}0`\n    return `0x${\n      data.length % 2 === 1 ? `0${data}` : data\n    }` as TrimReturnType<TValue>\n  }\n  return data as TrimReturnType<TValue>\n}\n","import { BaseError } from './base.js'\n\nexport type NegativeOffsetErrorType = NegativeOffsetError & {\n  name: 'NegativeOffsetError'\n}\nexport class NegativeOffsetError extends BaseError {\n  override name = 'NegativeOffsetError'\n  constructor({ offset }: { offset: number }) {\n    super(`Offset \\`${offset}\\` cannot be negative.`)\n  }\n}\n\nexport type PositionOutOfBoundsErrorType = PositionOutOfBoundsError & {\n  name: 'PositionOutOfBoundsError'\n}\nexport class PositionOutOfBoundsError extends BaseError {\n  override name = 'PositionOutOfBoundsError'\n  constructor({ length, position }: { length: number; position: number }) {\n    super(\n      `Position \\`${position}\\` is out of bounds (\\`0 < position < ${length}\\`).`,\n    )\n  }\n}\n","import {\n  NegativeOffsetError,\n  PositionOutOfBoundsError,\n} from '../errors/cursor.js'\nimport type { ErrorType } from '../errors/utils.js'\nimport type { ByteArray } from '../types/misc.js'\n\nexport type Cursor = {\n  bytes: ByteArray\n  dataView: DataView\n  position: number\n  assertPosition(position: number): void\n  decrementPosition(offset: number): void\n  incrementPosition(offset: number): void\n  inspectByte(position?: number): ByteArray[number]\n  inspectBytes(length: number, position?: number): ByteArray\n  inspectUint8(position?: number): number\n  inspectUint16(position?: number): number\n  inspectUint24(position?: number): number\n  inspectUint32(position?: number): number\n  pushByte(byte: ByteArray[number]): void\n  pushBytes(bytes: ByteArray): void\n  pushUint8(value: number): void\n  pushUint16(value: number): void\n  pushUint24(value: number): void\n  pushUint32(value: number): void\n  readByte(): ByteArray[number]\n  readBytes(length: number): ByteArray\n  readUint8(): number\n  readUint16(): number\n  readUint24(): number\n  readUint32(): number\n  setPosition(position: number): void\n}\n\nexport type CreateCursorErrorType = ErrorType\n\nexport type CursorErrorType =\n  | CursorAssertPositionErrorType\n  | CursorDecrementPositionErrorType\n  | CursorIncrementPositionErrorType\n  | ErrorType\n\nexport type CursorAssertPositionErrorType = PositionOutOfBoundsError | ErrorType\n\nexport type CursorDecrementPositionErrorType = NegativeOffsetError | ErrorType\n\nexport type CursorIncrementPositionErrorType = NegativeOffsetError | ErrorType\n\nconst staticCursor: Cursor = {\n  bytes: new Uint8Array(),\n  dataView: new DataView(new ArrayBuffer(0)),\n  position: 0,\n  assertPosition(position) {\n    if (position < 0 || position > this.bytes.length - 1)\n      throw new PositionOutOfBoundsError({\n        length: this.bytes.length,\n        position,\n      })\n  },\n  decrementPosition(offset) {\n    if (offset < 0) throw new NegativeOffsetError({ offset })\n    const position = this.position - offset\n    this.assertPosition(position)\n    this.position = position\n  },\n  incrementPosition(offset) {\n    if (offset < 0) throw new NegativeOffsetError({ offset })\n    const position = this.position + offset\n    this.assertPosition(position)\n    this.position = position\n  },\n  inspectByte(position_) {\n    const position = position_ ?? this.position\n    this.assertPosition(position)\n    return this.bytes[position]\n  },\n  inspectBytes(length, position_) {\n    const position = position_ ?? this.position\n    this.assertPosition(position + length - 1)\n    return this.bytes.subarray(position, position + length)\n  },\n  inspectUint8(position_) {\n    const position = position_ ?? this.position\n    this.assertPosition(position)\n    return this.bytes[position]\n  },\n  inspectUint16(position_) {\n    const position = position_ ?? this.position\n    this.assertPosition(position + 1)\n    return this.dataView.getUint16(position)\n  },\n  inspectUint24(position_) {\n    const position = position_ ?? this.position\n    this.assertPosition(position + 2)\n    return (\n      (this.dataView.getUint16(position) << 8) +\n      this.dataView.getUint8(position + 2)\n    )\n  },\n  inspectUint32(position_) {\n    const position = position_ ?? this.position\n    this.assertPosition(position + 3)\n    return this.dataView.getUint32(position)\n  },\n  pushByte(byte: ByteArray[number]) {\n    this.assertPosition(this.position)\n    this.bytes[this.position] = byte\n    this.position++\n  },\n  pushBytes(bytes: ByteArray) {\n    this.assertPosition(this.position + bytes.length - 1)\n    this.bytes.set(bytes, this.position)\n    this.position += bytes.length\n  },\n  pushUint8(value: number) {\n    this.assertPosition(this.position)\n    this.bytes[this.position] = value\n    this.position++\n  },\n  pushUint16(value: number) {\n    this.assertPosition(this.position + 1)\n    this.dataView.setUint16(this.position, value)\n    this.position += 2\n  },\n  pushUint24(value: number) {\n    this.assertPosition(this.position + 2)\n    this.dataView.setUint16(this.position, value >> 8)\n    this.dataView.setUint8(this.position + 2, value & ~4294967040)\n    this.position += 3\n  },\n  pushUint32(value: number) {\n    this.assertPosition(this.position + 3)\n    this.dataView.setUint32(this.position, value)\n    this.position += 4\n  },\n  readByte() {\n    const value = this.inspectByte()\n    this.position++\n    return value\n  },\n  readBytes(length) {\n    const value = this.inspectBytes(length)\n    this.position += length\n    return value\n  },\n  readUint8() {\n    const value = this.inspectUint8()\n    this.position += 1\n    return value\n  },\n  readUint16() {\n    const value = this.inspectUint16()\n    this.position += 2\n    return value\n  },\n  readUint24() {\n    const value = this.inspectUint24()\n    this.position += 3\n    return value\n  },\n  readUint32() {\n    const value = this.inspectUint32()\n    this.position += 4\n    return value\n  },\n  setPosition(position) {\n    this.assertPosition(position)\n    this.position = position\n  },\n}\n\nexport function createCursor(bytes: ByteArray): Cursor {\n  const cursor = Object.create(staticCursor)\n  cursor.bytes = bytes\n  cursor.dataView = new DataView(\n    bytes.buffer,\n    bytes.byteOffset,\n    bytes.byteLength,\n  )\n  return cursor\n}\n","import type { ErrorType } from '../../errors/utils.js'\nimport { BaseError } from '../../index.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport {\n  type CreateCursorErrorType,\n  type Cursor,\n  createCursor,\n} from '../cursor.js'\n\nimport { type HexToBytesErrorType, hexToBytes } from './toBytes.js'\nimport { type BytesToHexErrorType, bytesToHex } from './toHex.js'\n\nexport type RecursiveArray<T> = T | RecursiveArray<T>[]\n\ntype To = 'hex' | 'bytes'\n\ntype Encodable = {\n  length: number\n  encode(cursor: Cursor): void\n}\n\nexport type ToRlpReturnType<to extends To> =\n  | (to extends 'bytes' ? ByteArray : never)\n  | (to extends 'hex' ? Hex : never)\n\nexport type ToRlpErrorType =\n  | CreateCursorErrorType\n  | BytesToHexErrorType\n  | HexToBytesErrorType\n  | ErrorType\n\nexport function toRlp<to extends To = 'hex'>(\n  bytes: RecursiveArray<ByteArray> | RecursiveArray<Hex>,\n  to: to | To | undefined = 'hex',\n): ToRlpReturnType<to> {\n  const encodable = getEncodable(bytes)\n  const cursor = createCursor(new Uint8Array(encodable.length))\n  encodable.encode(cursor)\n\n  if (to === 'hex') return bytesToHex(cursor.bytes) as ToRlpReturnType<to>\n  return cursor.bytes as ToRlpReturnType<to>\n}\n\nexport type BytesToRlpErrorType = ToRlpErrorType | ErrorType\n\nexport function bytesToRlp<to extends To = 'bytes'>(\n  bytes: RecursiveArray<ByteArray>,\n  to: to | To | undefined = 'bytes',\n): ToRlpReturnType<to> {\n  return toRlp(bytes, to)\n}\n\nexport type HexToRlpErrorType = ToRlpErrorType | ErrorType\n\nexport function hexToRlp<to extends To = 'hex'>(\n  hex: RecursiveArray<Hex>,\n  to: to | To | undefined = 'hex',\n): ToRlpReturnType<to> {\n  return toRlp(hex, to)\n}\n\nfunction getEncodable(\n  bytes: RecursiveArray<ByteArray> | RecursiveArray<Hex>,\n): Encodable {\n  if (Array.isArray(bytes))\n    return getEncodableList(bytes.map((x) => getEncodable(x)))\n  return getEncodableBytes(bytes)\n}\n\nfunction getEncodableList(list: Encodable[]): Encodable {\n  const bodyLength = list.reduce((acc, x) => acc + x.length, 0)\n\n  const sizeOfBodyLength = getSizeOfLength(bodyLength)\n  const length = (() => {\n    if (bodyLength <= 55) return 1 + bodyLength\n    return 1 + sizeOfBodyLength + bodyLength\n  })()\n\n  return {\n    length,\n    encode(cursor: Cursor) {\n      if (bodyLength <= 55) {\n        cursor.pushByte(0xc0 + bodyLength)\n      } else {\n        cursor.pushByte(0xc0 + 55 + sizeOfBodyLength)\n        if (sizeOfBodyLength === 1) cursor.pushUint8(bodyLength)\n        else if (sizeOfBodyLength === 2) cursor.pushUint16(bodyLength)\n        else if (sizeOfBodyLength === 3) cursor.pushUint24(bodyLength)\n        else cursor.pushUint32(bodyLength)\n      }\n      for (const { encode } of list) {\n        encode(cursor)\n      }\n    },\n  }\n}\n\nfunction getEncodableBytes(bytesOrHex: ByteArray | Hex): Encodable {\n  const bytes =\n    typeof bytesOrHex === 'string' ? hexToBytes(bytesOrHex) : bytesOrHex\n\n  const sizeOfBytesLength = getSizeOfLength(bytes.length)\n  const length = (() => {\n    if (bytes.length === 1 && bytes[0] < 0x80) return 1\n    if (bytes.length <= 55) return 1 + bytes.length\n    return 1 + sizeOfBytesLength + bytes.length\n  })()\n\n  return {\n    length,\n    encode(cursor: Cursor) {\n      if (bytes.length === 1 && bytes[0] < 0x80) {\n        cursor.pushBytes(bytes)\n      } else if (bytes.length <= 55) {\n        cursor.pushByte(0x80 + bytes.length)\n        cursor.pushBytes(bytes)\n      } else {\n        cursor.pushByte(0x80 + 55 + sizeOfBytesLength)\n        if (sizeOfBytesLength === 1) cursor.pushUint8(bytes.length)\n        else if (sizeOfBytesLength === 2) cursor.pushUint16(bytes.length)\n        else if (sizeOfBytesLength === 3) cursor.pushUint24(bytes.length)\n        else cursor.pushUint32(bytes.length)\n        cursor.pushBytes(bytes)\n      }\n    },\n  }\n}\n\nfunction getSizeOfLength(length: number) {\n  if (length < 2 ** 8) return 1\n  if (length < 2 ** 16) return 2\n  if (length < 2 ** 24) return 3\n  if (length < 2 ** 32) return 4\n  throw new BaseError('Length is too large.')\n}\n","import type { Chain } from '../types/chain.js'\n\nimport { BaseError } from './base.js'\n\nexport type ChainDoesNotSupportContractErrorType =\n  ChainDoesNotSupportContract & {\n    name: 'ChainDoesNotSupportContract'\n  }\nexport class ChainDoesNotSupportContract extends BaseError {\n  override name = 'ChainDoesNotSupportContract'\n  constructor({\n    blockNumber,\n    chain,\n    contract,\n  }: {\n    blockNumber?: bigint\n    chain: Chain\n    contract: { name: string; blockCreated?: number }\n  }) {\n    super(\n      `Chain \"${chain.name}\" does not support contract \"${contract.name}\".`,\n      {\n        metaMessages: [\n          'This could be due to any of the following:',\n          ...(blockNumber &&\n          contract.blockCreated &&\n          contract.blockCreated > blockNumber\n            ? [\n                `- The contract \"${contract.name}\" was not deployed until block ${contract.blockCreated} (current block ${blockNumber}).`,\n              ]\n            : [\n                `- The chain does not have the contract \"${contract.name}\" configured.`,\n              ]),\n        ],\n      },\n    )\n  }\n}\n\nexport type ChainMismatchErrorType = ChainMismatchError & {\n  name: 'ChainMismatchError'\n}\nexport class ChainMismatchError extends BaseError {\n  override name = 'ChainMismatchError'\n\n  constructor({\n    chain,\n    currentChainId,\n  }: {\n    chain: Chain\n    currentChainId: number\n  }) {\n    super(\n      `The current chain of the wallet (id: ${currentChainId}) does not match the target chain for the transaction (id: ${chain.id}  ${chain.name}).`,\n      {\n        metaMessages: [\n          `Current Chain ID:  ${currentChainId}`,\n          `Expected Chain ID: ${chain.id}  ${chain.name}`,\n        ],\n      },\n    )\n  }\n}\n\nexport type ChainNotFoundErrorType = ChainNotFoundError & {\n  name: 'ChainNotFoundError'\n}\nexport class ChainNotFoundError extends BaseError {\n  override name = 'ChainNotFoundError'\n\n  constructor() {\n    super(\n      [\n        'No chain was provided to the request.',\n        'Please provide a chain with the `chain` argument on the Action, or by supplying a `chain` to WalletClient.',\n      ].join('\\n'),\n    )\n  }\n}\n\nexport type ClientChainNotConfiguredErrorType =\n  ClientChainNotConfiguredError & {\n    name: 'ClientChainNotConfiguredError'\n  }\nexport class ClientChainNotConfiguredError extends BaseError {\n  override name = 'ClientChainNotConfiguredError'\n\n  constructor() {\n    super('No chain was provided to the Client.')\n  }\n}\n\nexport type InvalidChainIdErrorType = InvalidChainIdError & {\n  name: 'InvalidChainIdError'\n}\nexport class InvalidChainIdError extends BaseError {\n  override name = 'InvalidChainIdError'\n\n  constructor({ chainId }: { chainId: number }) {\n    super(`Chain ID \"${chainId}\" is invalid.`)\n  }\n}\n","import { formatGwei } from '../utils/unit/formatGwei.js'\n\nimport { BaseError } from './base.js'\n\n/**\n * geth:    https://github.com/ethereum/go-ethereum/blob/master/core/error.go\n *          https://github.com/ethereum/go-ethereum/blob/master/core/types/transaction.go#L34-L41\n *\n * erigon:  https://github.com/ledgerwatch/erigon/blob/master/core/error.go\n *          https://github.com/ledgerwatch/erigon/blob/master/core/types/transaction.go#L41-L46\n *\n * anvil:   https://github.com/foundry-rs/foundry/blob/master/anvil/src/eth/error.rs#L108\n */\nexport type ExecutionRevertedErrorType = ExecutionRevertedError & {\n  code: 3\n  name: 'ExecutionRevertedError'\n}\nexport class ExecutionRevertedError extends BaseError {\n  static code = 3\n  static nodeMessage = /execution reverted/\n\n  override name = 'ExecutionRevertedError'\n\n  constructor({\n    cause,\n    message,\n  }: { cause?: BaseError; message?: string } = {}) {\n    const reason = message\n      ?.replace('execution reverted: ', '')\n      ?.replace('execution reverted', '')\n    super(\n      `Execution reverted ${\n        reason ? `with reason: ${reason}` : 'for an unknown reason'\n      }.`,\n      {\n        cause,\n      },\n    )\n  }\n}\n\nexport type FeeCapTooHighErrorType = FeeCapTooHighError & {\n  name: 'FeeCapTooHighError'\n}\nexport class FeeCapTooHighError extends BaseError {\n  static nodeMessage =\n    /max fee per gas higher than 2\\^256-1|fee cap higher than 2\\^256-1/\n  override name = 'FeeCapTooHigh'\n  constructor({\n    cause,\n    maxFeePerGas,\n  }: { cause?: BaseError; maxFeePerGas?: bigint } = {}) {\n    super(\n      `The fee cap (\\`maxFeePerGas\\`${\n        maxFeePerGas ? ` = ${formatGwei(maxFeePerGas)} gwei` : ''\n      }) cannot be higher than the maximum allowed value (2^256-1).`,\n      {\n        cause,\n      },\n    )\n  }\n}\n\nexport type FeeCapTooLowErrorType = FeeCapTooLowError & {\n  name: 'FeeCapTooLowError'\n}\nexport class FeeCapTooLowError extends BaseError {\n  static nodeMessage =\n    /max fee per gas less than block base fee|fee cap less than block base fee|transaction is outdated/\n  override name = 'FeeCapTooLow'\n  constructor({\n    cause,\n    maxFeePerGas,\n  }: { cause?: BaseError; maxFeePerGas?: bigint } = {}) {\n    super(\n      `The fee cap (\\`maxFeePerGas\\`${\n        maxFeePerGas ? ` = ${formatGwei(maxFeePerGas)}` : ''\n      } gwei) cannot be lower than the block base fee.`,\n      {\n        cause,\n      },\n    )\n  }\n}\n\nexport type NonceTooHighErrorType = NonceTooHighError & {\n  name: 'NonceTooHighError'\n}\nexport class NonceTooHighError extends BaseError {\n  static nodeMessage = /nonce too high/\n  override name = 'NonceTooHighError'\n  constructor({ cause, nonce }: { cause?: BaseError; nonce?: number } = {}) {\n    super(\n      `Nonce provided for the transaction ${\n        nonce ? `(${nonce}) ` : ''\n      }is higher than the next one expected.`,\n      { cause },\n    )\n  }\n}\n\nexport type NonceTooLowErrorType = NonceTooLowError & {\n  name: 'NonceTooLowError'\n}\nexport class NonceTooLowError extends BaseError {\n  static nodeMessage =\n    /nonce too low|transaction already imported|already known/\n  override name = 'NonceTooLowError'\n  constructor({ cause, nonce }: { cause?: BaseError; nonce?: number } = {}) {\n    super(\n      [\n        `Nonce provided for the transaction ${\n          nonce ? `(${nonce}) ` : ''\n        }is lower than the current nonce of the account.`,\n        'Try increasing the nonce or find the latest nonce with `getTransactionCount`.',\n      ].join('\\n'),\n      { cause },\n    )\n  }\n}\n\nexport type NonceMaxValueErrorType = NonceMaxValueError & {\n  name: 'NonceMaxValueError'\n}\nexport class NonceMaxValueError extends BaseError {\n  static nodeMessage = /nonce has max value/\n  override name = 'NonceMaxValueError'\n  constructor({ cause, nonce }: { cause?: BaseError; nonce?: number } = {}) {\n    super(\n      `Nonce provided for the transaction ${\n        nonce ? `(${nonce}) ` : ''\n      }exceeds the maximum allowed nonce.`,\n      { cause },\n    )\n  }\n}\n\nexport type InsufficientFundsErrorType = InsufficientFundsError & {\n  name: 'InsufficientFundsError'\n}\nexport class InsufficientFundsError extends BaseError {\n  static nodeMessage = /insufficient funds/\n  override name = 'InsufficientFundsError'\n  constructor({ cause }: { cause?: BaseError } = {}) {\n    super(\n      [\n        'The total cost (gas * gas fee + value) of executing this transaction exceeds the balance of the account.',\n      ].join('\\n'),\n      {\n        cause,\n        metaMessages: [\n          'This error could arise when the account does not have enough funds to:',\n          ' - pay for the total gas fee,',\n          ' - pay for the value to send.',\n          ' ',\n          'The cost of the transaction is calculated as `gas * gas fee + value`, where:',\n          ' - `gas` is the amount of gas needed for transaction to execute,',\n          ' - `gas fee` is the gas fee,',\n          ' - `value` is the amount of ether to send to the recipient.',\n        ],\n      },\n    )\n  }\n}\n\nexport type IntrinsicGasTooHighErrorType = IntrinsicGasTooHighError & {\n  name: 'IntrinsicGasTooHighError'\n}\nexport class IntrinsicGasTooHighError extends BaseError {\n  static nodeMessage = /intrinsic gas too high|gas limit reached/\n  override name = 'IntrinsicGasTooHighError'\n  constructor({ cause, gas }: { cause?: BaseError; gas?: bigint } = {}) {\n    super(\n      `The amount of gas ${\n        gas ? `(${gas}) ` : ''\n      }provided for the transaction exceeds the limit allowed for the block.`,\n      {\n        cause,\n      },\n    )\n  }\n}\n\nexport type IntrinsicGasTooLowErrorType = IntrinsicGasTooLowError & {\n  name: 'IntrinsicGasTooLowError'\n}\nexport class IntrinsicGasTooLowError extends BaseError {\n  static nodeMessage = /intrinsic gas too low/\n  override name = 'IntrinsicGasTooLowError'\n  constructor({ cause, gas }: { cause?: BaseError; gas?: bigint } = {}) {\n    super(\n      `The amount of gas ${\n        gas ? `(${gas}) ` : ''\n      }provided for the transaction is too low.`,\n      {\n        cause,\n      },\n    )\n  }\n}\n\nexport type TransactionTypeNotSupportedErrorType =\n  TransactionTypeNotSupportedError & {\n    name: 'TransactionTypeNotSupportedError'\n  }\nexport class TransactionTypeNotSupportedError extends BaseError {\n  static nodeMessage = /transaction type not valid/\n  override name = 'TransactionTypeNotSupportedError'\n  constructor({ cause }: { cause?: BaseError }) {\n    super('The transaction type is not supported for this chain.', {\n      cause,\n    })\n  }\n}\n\nexport type TipAboveFeeCapErrorType = TipAboveFeeCapError & {\n  name: 'TipAboveFeeCapError'\n}\nexport class TipAboveFeeCapError extends BaseError {\n  static nodeMessage =\n    /max priority fee per gas higher than max fee per gas|tip higher than fee cap/\n  override name = 'TipAboveFeeCapError'\n  constructor({\n    cause,\n    maxPriorityFeePerGas,\n    maxFeePerGas,\n  }: {\n    cause?: BaseError\n    maxPriorityFeePerGas?: bigint\n    maxFeePerGas?: bigint\n  } = {}) {\n    super(\n      [\n        `The provided tip (\\`maxPriorityFeePerGas\\`${\n          maxPriorityFeePerGas\n            ? ` = ${formatGwei(maxPriorityFeePerGas)} gwei`\n            : ''\n        }) cannot be higher than the fee cap (\\`maxFeePerGas\\`${\n          maxFeePerGas ? ` = ${formatGwei(maxFeePerGas)} gwei` : ''\n        }).`,\n      ].join('\\n'),\n      {\n        cause,\n      },\n    )\n  }\n}\n\nexport type UnknownNodeErrorType = UnknownNodeError & {\n  name: 'UnknownNodeError'\n}\nexport class UnknownNodeError extends BaseError {\n  override name = 'UnknownNodeError'\n\n  constructor({ cause }: { cause?: BaseError }) {\n    super(`An error occurred while executing: ${cause?.shortMessage}`, {\n      cause,\n    })\n  }\n}\n","import {\n  InvalidAddressError,\n  type InvalidAddressErrorType,\n} from '../../errors/address.js'\nimport {\n  InvalidStorageKeySizeError,\n  type InvalidStorageKeySizeErrorType,\n} from '../../errors/transaction.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { AccessList } from '../../types/transaction.js'\nimport { type IsAddressErrorType, isAddress } from '../address/isAddress.js'\nimport { type RecursiveArray } from '../encoding/toRlp.js'\n\nexport type SerializeAccessListErrorType =\n  | InvalidStorageKeySizeErrorType\n  | InvalidAddressErrorType\n  | IsAddressErrorType\n  | ErrorType\n\n/*\n * Serialize an  EIP-2930 access list\n * @remarks\n * Use to create a transaction serializer with support for EIP-2930 access lists\n *\n * @param accessList - Array of objects of address and arrays of Storage Keys\n * @throws InvalidAddressError, InvalidStorageKeySizeError\n * @returns Array of hex strings\n */\nexport function serializeAccessList(\n  accessList?: AccessList,\n): RecursiveArray<Hex> {\n  if (!accessList || accessList.length === 0) return []\n\n  const serializedAccessList: RecursiveArray<Hex> = []\n  for (let i = 0; i < accessList.length; i++) {\n    const { address, storageKeys } = accessList[i]\n\n    for (let j = 0; j < storageKeys.length; j++) {\n      if (storageKeys[j].length - 2 !== 64) {\n        throw new InvalidStorageKeySizeError({ storageKey: storageKeys[j] })\n      }\n    }\n\n    if (!isAddress(address)) {\n      throw new InvalidAddressError({ address })\n    }\n\n    serializedAccessList.push([address, storageKeys])\n  }\n  return serializedAccessList\n}\n","import {\n  InvalidLegacyVError,\n  type InvalidLegacyVErrorType,\n} from '../../errors/transaction.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Signature } from '../../types/misc.js'\nimport type {\n  TransactionSerializable,\n  TransactionSerializableEIP1559,\n  TransactionSerializableEIP2930,\n  TransactionSerializableLegacy,\n  TransactionSerialized,\n  TransactionSerializedEIP1559,\n  TransactionSerializedEIP2930,\n  TransactionSerializedLegacy,\n  TransactionType,\n} from '../../types/transaction.js'\nimport { type ConcatHexErrorType, concatHex } from '../data/concat.js'\nimport { trim } from '../data/trim.js'\nimport { type ToHexErrorType, toHex } from '../encoding/toHex.js'\nimport { type ToRlpErrorType, toRlp } from '../encoding/toRlp.js'\n\nimport {\n  type AssertTransactionEIP1559ErrorType,\n  type AssertTransactionEIP2930ErrorType,\n  type AssertTransactionLegacyErrorType,\n  assertTransactionEIP1559,\n  assertTransactionEIP2930,\n  assertTransactionLegacy,\n} from './assertTransaction.js'\nimport {\n  type GetTransactionType,\n  type GetTransationTypeErrorType,\n  getTransactionType,\n} from './getTransactionType.js'\nimport {\n  type SerializeAccessListErrorType,\n  serializeAccessList,\n} from './serializeAccessList.js'\n\nexport type SerializedTransactionReturnType<\n  TTransactionSerializable extends\n    TransactionSerializable = TransactionSerializable,\n  TTransactionType extends\n    TransactionType = GetTransactionType<TTransactionSerializable>,\n> = TransactionSerialized<TTransactionType>\n\nexport type SerializeTransactionFn<\n  TTransactionSerializable extends\n    TransactionSerializable = TransactionSerializable,\n> = typeof serializeTransaction<TTransactionSerializable>\n\nexport type SerializeTransactionErrorType =\n  | GetTransationTypeErrorType\n  | SerializeTransactionEIP1559ErrorType\n  | SerializeTransactionEIP2930ErrorType\n  | SerializeTransactionLegacyErrorType\n  | ErrorType\n\nexport function serializeTransaction<\n  TTransactionSerializable extends TransactionSerializable,\n>(\n  transaction: TTransactionSerializable,\n  signature?: Signature,\n): SerializedTransactionReturnType<TTransactionSerializable> {\n  const type = getTransactionType(transaction) as GetTransactionType\n\n  if (type === 'eip1559')\n    return serializeTransactionEIP1559(\n      transaction as TransactionSerializableEIP1559,\n      signature,\n    ) as SerializedTransactionReturnType<TTransactionSerializable>\n\n  if (type === 'eip2930')\n    return serializeTransactionEIP2930(\n      transaction as TransactionSerializableEIP2930,\n      signature,\n    ) as SerializedTransactionReturnType<TTransactionSerializable>\n\n  return serializeTransactionLegacy(\n    transaction as TransactionSerializableLegacy,\n    signature,\n  ) as SerializedTransactionReturnType<TTransactionSerializable>\n}\n\ntype SerializeTransactionEIP1559ErrorType =\n  | AssertTransactionEIP1559ErrorType\n  | ConcatHexErrorType\n  | InvalidLegacyVErrorType\n  | ToHexErrorType\n  | ToRlpErrorType\n  | SerializeAccessListErrorType\n  | ErrorType\n\nfunction serializeTransactionEIP1559(\n  transaction: TransactionSerializableEIP1559,\n  signature?: Signature,\n): TransactionSerializedEIP1559 {\n  const {\n    chainId,\n    gas,\n    nonce,\n    to,\n    value,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    accessList,\n    data,\n  } = transaction\n\n  assertTransactionEIP1559(transaction)\n\n  const serializedAccessList = serializeAccessList(accessList)\n\n  const serializedTransaction = [\n    toHex(chainId),\n    nonce ? toHex(nonce) : '0x',\n    maxPriorityFeePerGas ? toHex(maxPriorityFeePerGas) : '0x',\n    maxFeePerGas ? toHex(maxFeePerGas) : '0x',\n    gas ? toHex(gas) : '0x',\n    to ?? '0x',\n    value ? toHex(value) : '0x',\n    data ?? '0x',\n    serializedAccessList,\n  ]\n\n  if (signature) {\n    const yParity = (() => {\n      if (signature.v === 0n) return '0x'\n      if (signature.v === 1n) return toHex(1)\n\n      return signature.v === 27n ? '0x' : toHex(1)\n    })()\n    serializedTransaction.push(yParity, trim(signature.r), trim(signature.s))\n  }\n\n  return concatHex([\n    '0x02',\n    toRlp(serializedTransaction),\n  ]) as TransactionSerializedEIP1559\n}\n\ntype SerializeTransactionEIP2930ErrorType =\n  | AssertTransactionEIP2930ErrorType\n  | ConcatHexErrorType\n  | InvalidLegacyVErrorType\n  | ToHexErrorType\n  | ToRlpErrorType\n  | SerializeAccessListErrorType\n  | ErrorType\n\nfunction serializeTransactionEIP2930(\n  transaction: TransactionSerializableEIP2930,\n  signature?: Signature,\n): TransactionSerializedEIP2930 {\n  const { chainId, gas, data, nonce, to, value, accessList, gasPrice } =\n    transaction\n\n  assertTransactionEIP2930(transaction)\n\n  const serializedAccessList = serializeAccessList(accessList)\n\n  const serializedTransaction = [\n    toHex(chainId),\n    nonce ? toHex(nonce) : '0x',\n    gasPrice ? toHex(gasPrice) : '0x',\n    gas ? toHex(gas) : '0x',\n    to ?? '0x',\n    value ? toHex(value) : '0x',\n    data ?? '0x',\n    serializedAccessList,\n  ]\n\n  if (signature) {\n    const yParity = (() => {\n      if (signature.v === 0n) return '0x'\n      if (signature.v === 1n) return toHex(1)\n\n      return signature.v === 27n ? '0x' : toHex(1)\n    })()\n    serializedTransaction.push(yParity, trim(signature.r), trim(signature.s))\n  }\n\n  return concatHex([\n    '0x01',\n    toRlp(serializedTransaction),\n  ]) as TransactionSerializedEIP2930\n}\n\ntype SerializeTransactionLegacyErrorType =\n  | AssertTransactionLegacyErrorType\n  | InvalidLegacyVErrorType\n  | ToHexErrorType\n  | ToRlpErrorType\n  | ErrorType\n\nfunction serializeTransactionLegacy(\n  transaction: TransactionSerializableLegacy,\n  signature?: Signature,\n): TransactionSerializedLegacy {\n  const { chainId = 0, gas, data, nonce, to, value, gasPrice } = transaction\n\n  assertTransactionLegacy(transaction)\n\n  let serializedTransaction = [\n    nonce ? toHex(nonce) : '0x',\n    gasPrice ? toHex(gasPrice) : '0x',\n    gas ? toHex(gas) : '0x',\n    to ?? '0x',\n    value ? toHex(value) : '0x',\n    data ?? '0x',\n  ]\n\n  if (signature) {\n    const v = (() => {\n      // EIP-155 (explicit chainId)\n      if (chainId > 0)\n        return BigInt(chainId * 2) + BigInt(35n + signature.v - 27n)\n\n      // EIP-155 (inferred chainId)\n      if (signature.v >= 35n) {\n        const inferredChainId = (signature.v - 35n) / 2n\n        if (inferredChainId > 0) return signature.v\n        return 27n + (signature.v === 35n ? 0n : 1n)\n      }\n\n      // Pre-EIP-155 (no chainId)\n      const v = 27n + (signature.v === 27n ? 0n : 1n)\n      if (signature.v !== v) throw new InvalidLegacyVError({ v: signature.v })\n      return v\n    })()\n\n    serializedTransaction = [\n      ...serializedTransaction,\n      toHex(v),\n      signature.r,\n      signature.s,\n    ]\n  } else if (chainId > 0) {\n    serializedTransaction = [\n      ...serializedTransaction,\n      toHex(chainId),\n      '0x',\n      '0x',\n    ]\n  }\n\n  return toRlp(serializedTransaction)\n}\n","import {\n  InvalidSerializableTransactionError,\n  type InvalidSerializableTransactionErrorType,\n} from '../../errors/transaction.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type {\n  TransactionSerializable,\n  TransactionSerializableEIP1559,\n  TransactionSerializableEIP2930,\n  TransactionSerializableGeneric,\n  TransactionSerializableLegacy,\n} from '../../types/transaction.js'\n\nexport type GetTransactionType<\n  TTransactionSerializable extends\n    TransactionSerializable = TransactionSerializable,\n> =\n  | (TTransactionSerializable extends TransactionSerializableLegacy\n      ? 'legacy'\n      : never)\n  | (TTransactionSerializable extends TransactionSerializableEIP1559\n      ? 'eip1559'\n      : never)\n  | (TTransactionSerializable extends TransactionSerializableEIP2930\n      ? 'eip2930'\n      : never)\n  | (TTransactionSerializable extends TransactionSerializableGeneric\n      ? TTransactionSerializable['type']\n      : never)\n\nexport type GetTransationTypeErrorType =\n  | InvalidSerializableTransactionErrorType\n  | ErrorType\n\nexport function getTransactionType<\n  TTransactionSerializable extends TransactionSerializable,\n>(\n  transaction: TTransactionSerializable,\n): GetTransactionType<TTransactionSerializable> {\n  if (transaction.type)\n    return transaction.type as GetTransactionType<TTransactionSerializable>\n\n  if (\n    typeof transaction.maxFeePerGas !== 'undefined' ||\n    typeof transaction.maxPriorityFeePerGas !== 'undefined'\n  )\n    return 'eip1559' as GetTransactionType<TTransactionSerializable>\n\n  if (typeof transaction.gasPrice !== 'undefined') {\n    if (typeof transaction.accessList !== 'undefined')\n      return 'eip2930' as GetTransactionType<TTransactionSerializable>\n    return 'legacy' as GetTransactionType<TTransactionSerializable>\n  }\n\n  throw new InvalidSerializableTransactionError({ transaction })\n}\n","import {\n  InvalidAddressError,\n  type InvalidAddressErrorType,\n} from '../../errors/address.js'\nimport { BaseError, type BaseErrorType } from '../../errors/base.js'\nimport {\n  InvalidChainIdError,\n  type InvalidChainIdErrorType,\n} from '../../errors/chain.js'\nimport {\n  FeeCapTooHighError,\n  type FeeCapTooHighErrorType,\n  TipAboveFeeCapError,\n  type TipAboveFeeCapErrorType,\n} from '../../errors/node.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type {\n  TransactionSerializableEIP1559,\n  TransactionSerializableEIP2930,\n  TransactionSerializableLegacy,\n} from '../../types/transaction.js'\nimport { type IsAddressErrorType, isAddress } from '../address/isAddress.js'\n\nexport type AssertTransactionEIP1559ErrorType =\n  | BaseErrorType\n  | IsAddressErrorType\n  | InvalidAddressErrorType\n  | InvalidChainIdErrorType\n  | FeeCapTooHighErrorType\n  | TipAboveFeeCapErrorType\n  | ErrorType\n\nexport function assertTransactionEIP1559(\n  transaction: TransactionSerializableEIP1559,\n) {\n  const { chainId, maxPriorityFeePerGas, gasPrice, maxFeePerGas, to } =\n    transaction\n  if (chainId <= 0) throw new InvalidChainIdError({ chainId })\n  if (to && !isAddress(to)) throw new InvalidAddressError({ address: to })\n  if (gasPrice)\n    throw new BaseError(\n      '`gasPrice` is not a valid EIP-1559 Transaction attribute.',\n    )\n  if (maxFeePerGas && maxFeePerGas > 2n ** 256n - 1n)\n    throw new FeeCapTooHighError({ maxFeePerGas })\n  if (\n    maxPriorityFeePerGas &&\n    maxFeePerGas &&\n    maxPriorityFeePerGas > maxFeePerGas\n  )\n    throw new TipAboveFeeCapError({ maxFeePerGas, maxPriorityFeePerGas })\n}\n\nexport type AssertTransactionEIP2930ErrorType =\n  | BaseErrorType\n  | IsAddressErrorType\n  | InvalidAddressErrorType\n  | InvalidChainIdErrorType\n  | FeeCapTooHighErrorType\n  | ErrorType\n\nexport function assertTransactionEIP2930(\n  transaction: TransactionSerializableEIP2930,\n) {\n  const { chainId, maxPriorityFeePerGas, gasPrice, maxFeePerGas, to } =\n    transaction\n  if (chainId <= 0) throw new InvalidChainIdError({ chainId })\n  if (to && !isAddress(to)) throw new InvalidAddressError({ address: to })\n  if (maxPriorityFeePerGas || maxFeePerGas)\n    throw new BaseError(\n      '`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid EIP-2930 Transaction attribute.',\n    )\n  if (gasPrice && gasPrice > 2n ** 256n - 1n)\n    throw new FeeCapTooHighError({ maxFeePerGas: gasPrice })\n}\n\nexport type AssertTransactionLegacyErrorType =\n  | BaseErrorType\n  | IsAddressErrorType\n  | InvalidAddressErrorType\n  | InvalidChainIdErrorType\n  | FeeCapTooHighErrorType\n  | ErrorType\n\nexport function assertTransactionLegacy(\n  transaction: TransactionSerializableLegacy,\n) {\n  const {\n    chainId,\n    maxPriorityFeePerGas,\n    gasPrice,\n    maxFeePerGas,\n    to,\n    accessList,\n  } = transaction\n  if (to && !isAddress(to)) throw new InvalidAddressError({ address: to })\n  if (typeof chainId !== 'undefined' && chainId <= 0)\n    throw new InvalidChainIdError({ chainId })\n  if (maxPriorityFeePerGas || maxFeePerGas)\n    throw new BaseError(\n      '`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid Legacy Transaction attribute.',\n    )\n  if (gasPrice && gasPrice > 2n ** 256n - 1n)\n    throw new FeeCapTooHighError({ maxFeePerGas: gasPrice })\n  if (accessList)\n    throw new BaseError(\n      '`accessList` is not a valid Legacy Transaction attribute.',\n    )\n}\n","import type { Abi, AbiEvent, AbiParameter } from 'abitype'\n\nimport type { Hex } from '../types/misc.js'\nimport { formatAbiItem, formatAbiParams } from '../utils/abi/formatAbiItem.js'\nimport { size } from '../utils/data/size.js'\n\nimport { BaseError } from './base.js'\n\nexport type AbiConstructorNotFoundErrorType = AbiConstructorNotFoundError & {\n  name: 'AbiConstructorNotFoundError'\n}\nexport class AbiConstructorNotFoundError extends BaseError {\n  override name = 'AbiConstructorNotFoundError'\n  constructor({ docsPath }: { docsPath: string }) {\n    super(\n      [\n        'A constructor was not found on the ABI.',\n        'Make sure you are using the correct ABI and that the constructor exists on it.',\n      ].join('\\n'),\n      {\n        docsPath,\n      },\n    )\n  }\n}\n\nexport type AbiConstructorParamsNotFoundErrorType =\n  AbiConstructorParamsNotFoundError & {\n    name: 'AbiConstructorParamsNotFoundError'\n  }\n\nexport class AbiConstructorParamsNotFoundError extends BaseError {\n  override name = 'AbiConstructorParamsNotFoundError'\n  constructor({ docsPath }: { docsPath: string }) {\n    super(\n      [\n        'Constructor arguments were provided (`args`), but a constructor parameters (`inputs`) were not found on the ABI.',\n        'Make sure you are using the correct ABI, and that the `inputs` attribute on the constructor exists.',\n      ].join('\\n'),\n      {\n        docsPath,\n      },\n    )\n  }\n}\n\nexport type AbiDecodingDataSizeInvalidErrorType =\n  AbiDecodingDataSizeInvalidError & {\n    name: 'AbiDecodingDataSizeInvalidError'\n  }\nexport class AbiDecodingDataSizeInvalidError extends BaseError {\n  override name = 'AbiDecodingDataSizeInvalidError'\n  constructor({ data, size }: { data: Hex; size: number }) {\n    super(\n      [\n        `Data size of ${size} bytes is invalid.`,\n        'Size must be in increments of 32 bytes (size % 32 === 0).',\n      ].join('\\n'),\n      { metaMessages: [`Data: ${data} (${size} bytes)`] },\n    )\n  }\n}\n\nexport type AbiDecodingDataSizeTooSmallErrorType =\n  AbiDecodingDataSizeTooSmallError & {\n    name: 'AbiDecodingDataSizeTooSmallError'\n  }\nexport class AbiDecodingDataSizeTooSmallError extends BaseError {\n  override name = 'AbiDecodingDataSizeTooSmallError'\n\n  data: Hex\n  params: readonly AbiParameter[]\n  size: number\n\n  constructor({\n    data,\n    params,\n    size,\n  }: { data: Hex; params: readonly AbiParameter[]; size: number }) {\n    super(\n      [`Data size of ${size} bytes is too small for given parameters.`].join(\n        '\\n',\n      ),\n      {\n        metaMessages: [\n          `Params: (${formatAbiParams(params, { includeName: true })})`,\n          `Data:   ${data} (${size} bytes)`,\n        ],\n      },\n    )\n\n    this.data = data\n    this.params = params\n    this.size = size\n  }\n}\n\nexport type AbiDecodingZeroDataErrorType = AbiDecodingZeroDataError & {\n  name: 'AbiDecodingZeroDataError'\n}\nexport class AbiDecodingZeroDataError extends BaseError {\n  override name = 'AbiDecodingZeroDataError'\n  constructor() {\n    super('Cannot decode zero data (\"0x\") with ABI parameters.')\n  }\n}\n\nexport type AbiEncodingArrayLengthMismatchErrorType =\n  AbiEncodingArrayLengthMismatchError & {\n    name: 'AbiEncodingArrayLengthMismatchError'\n  }\nexport class AbiEncodingArrayLengthMismatchError extends BaseError {\n  override name = 'AbiEncodingArrayLengthMismatchError'\n  constructor({\n    expectedLength,\n    givenLength,\n    type,\n  }: { expectedLength: number; givenLength: number; type: string }) {\n    super(\n      [\n        `ABI encoding array length mismatch for type ${type}.`,\n        `Expected length: ${expectedLength}`,\n        `Given length: ${givenLength}`,\n      ].join('\\n'),\n    )\n  }\n}\n\nexport type AbiEncodingBytesSizeMismatchErrorType =\n  AbiEncodingBytesSizeMismatchError & {\n    name: 'AbiEncodingBytesSizeMismatchError'\n  }\nexport class AbiEncodingBytesSizeMismatchError extends BaseError {\n  override name = 'AbiEncodingBytesSizeMismatchError'\n  constructor({ expectedSize, value }: { expectedSize: number; value: Hex }) {\n    super(\n      `Size of bytes \"${value}\" (bytes${size(\n        value,\n      )}) does not match expected size (bytes${expectedSize}).`,\n    )\n  }\n}\n\nexport type AbiEncodingLengthMismatchErrorType =\n  AbiEncodingLengthMismatchError & {\n    name: 'AbiEncodingLengthMismatchError'\n  }\nexport class AbiEncodingLengthMismatchError extends BaseError {\n  override name = 'AbiEncodingLengthMismatchError'\n  constructor({\n    expectedLength,\n    givenLength,\n  }: { expectedLength: number; givenLength: number }) {\n    super(\n      [\n        'ABI encoding params/values length mismatch.',\n        `Expected length (params): ${expectedLength}`,\n        `Given length (values): ${givenLength}`,\n      ].join('\\n'),\n    )\n  }\n}\n\nexport type AbiErrorInputsNotFoundErrorType = AbiErrorInputsNotFoundError & {\n  name: 'AbiErrorInputsNotFoundError'\n}\nexport class AbiErrorInputsNotFoundError extends BaseError {\n  override name = 'AbiErrorInputsNotFoundError'\n  constructor(errorName: string, { docsPath }: { docsPath: string }) {\n    super(\n      [\n        `Arguments (\\`args\\`) were provided to \"${errorName}\", but \"${errorName}\" on the ABI does not contain any parameters (\\`inputs\\`).`,\n        'Cannot encode error result without knowing what the parameter types are.',\n        'Make sure you are using the correct ABI and that the inputs exist on it.',\n      ].join('\\n'),\n      {\n        docsPath,\n      },\n    )\n  }\n}\n\nexport type AbiErrorNotFoundErrorType = AbiErrorNotFoundError & {\n  name: 'AbiErrorNotFoundError'\n}\nexport class AbiErrorNotFoundError extends BaseError {\n  override name = 'AbiErrorNotFoundError'\n  constructor(errorName?: string, { docsPath }: { docsPath?: string } = {}) {\n    super(\n      [\n        `Error ${errorName ? `\"${errorName}\" ` : ''}not found on ABI.`,\n        'Make sure you are using the correct ABI and that the error exists on it.',\n      ].join('\\n'),\n      {\n        docsPath,\n      },\n    )\n  }\n}\n\nexport type AbiErrorSignatureNotFoundErrorType =\n  AbiErrorSignatureNotFoundError & {\n    name: 'AbiErrorSignatureNotFoundError'\n  }\nexport class AbiErrorSignatureNotFoundError extends BaseError {\n  override name = 'AbiErrorSignatureNotFoundError'\n\n  signature: Hex\n\n  constructor(signature: Hex, { docsPath }: { docsPath: string }) {\n    super(\n      [\n        `Encoded error signature \"${signature}\" not found on ABI.`,\n        'Make sure you are using the correct ABI and that the error exists on it.',\n        `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${signature}.`,\n      ].join('\\n'),\n      {\n        docsPath,\n      },\n    )\n    this.signature = signature\n  }\n}\n\nexport type AbiEventSignatureEmptyTopicsErrorType =\n  AbiEventSignatureEmptyTopicsError & {\n    name: 'AbiEventSignatureEmptyTopicsError'\n  }\nexport class AbiEventSignatureEmptyTopicsError extends BaseError {\n  override name = 'AbiEventSignatureEmptyTopicsError'\n  constructor({ docsPath }: { docsPath: string }) {\n    super('Cannot extract event signature from empty topics.', {\n      docsPath,\n    })\n  }\n}\n\nexport type AbiEventSignatureNotFoundErrorType =\n  AbiEventSignatureNotFoundError & {\n    name: 'AbiEventSignatureNotFoundError'\n  }\nexport class AbiEventSignatureNotFoundError extends BaseError {\n  override name = 'AbiEventSignatureNotFoundError'\n  constructor(signature: Hex, { docsPath }: { docsPath: string }) {\n    super(\n      [\n        `Encoded event signature \"${signature}\" not found on ABI.`,\n        'Make sure you are using the correct ABI and that the event exists on it.',\n        `You can look up the signature here: https://openchain.xyz/signatures?query=${signature}.`,\n      ].join('\\n'),\n      {\n        docsPath,\n      },\n    )\n  }\n}\n\nexport type AbiEventNotFoundErrorType = AbiEventNotFoundError & {\n  name: 'AbiEventNotFoundError'\n}\nexport class AbiEventNotFoundError extends BaseError {\n  override name = 'AbiEventNotFoundError'\n  constructor(eventName?: string, { docsPath }: { docsPath?: string } = {}) {\n    super(\n      [\n        `Event ${eventName ? `\"${eventName}\" ` : ''}not found on ABI.`,\n        'Make sure you are using the correct ABI and that the event exists on it.',\n      ].join('\\n'),\n      {\n        docsPath,\n      },\n    )\n  }\n}\n\nexport type AbiFunctionNotFoundErrorType = AbiFunctionNotFoundError & {\n  name: 'AbiFunctionNotFoundError'\n}\nexport class AbiFunctionNotFoundError extends BaseError {\n  override name = 'AbiFunctionNotFoundError'\n  constructor(functionName?: string, { docsPath }: { docsPath?: string } = {}) {\n    super(\n      [\n        `Function ${functionName ? `\"${functionName}\" ` : ''}not found on ABI.`,\n        'Make sure you are using the correct ABI and that the function exists on it.',\n      ].join('\\n'),\n      {\n        docsPath,\n      },\n    )\n  }\n}\n\nexport type AbiFunctionOutputsNotFoundErrorType =\n  AbiFunctionOutputsNotFoundError & {\n    name: 'AbiFunctionOutputsNotFoundError'\n  }\nexport class AbiFunctionOutputsNotFoundError extends BaseError {\n  override name = 'AbiFunctionOutputsNotFoundError'\n  constructor(functionName: string, { docsPath }: { docsPath: string }) {\n    super(\n      [\n        `Function \"${functionName}\" does not contain any \\`outputs\\` on ABI.`,\n        'Cannot decode function result without knowing what the parameter types are.',\n        'Make sure you are using the correct ABI and that the function exists on it.',\n      ].join('\\n'),\n      {\n        docsPath,\n      },\n    )\n  }\n}\n\nexport type AbiFunctionSignatureNotFoundErrorType =\n  AbiFunctionSignatureNotFoundError & {\n    name: 'AbiFunctionSignatureNotFoundError'\n  }\nexport class AbiFunctionSignatureNotFoundError extends BaseError {\n  override name = 'AbiFunctionSignatureNotFoundError'\n  constructor(signature: Hex, { docsPath }: { docsPath: string }) {\n    super(\n      [\n        `Encoded function signature \"${signature}\" not found on ABI.`,\n        'Make sure you are using the correct ABI and that the function exists on it.',\n        `You can look up the signature here: https://openchain.xyz/signatures?query=${signature}.`,\n      ].join('\\n'),\n      {\n        docsPath,\n      },\n    )\n  }\n}\n\nexport type AbiItemAmbiguityErrorType = AbiItemAmbiguityError & {\n  name: 'AbiItemAmbiguityError'\n}\nexport class AbiItemAmbiguityError extends BaseError {\n  override name = 'AbiItemAmbiguityError'\n  constructor(\n    x: { abiItem: Abi[number]; type: string },\n    y: { abiItem: Abi[number]; type: string },\n  ) {\n    super('Found ambiguous types in overloaded ABI items.', {\n      metaMessages: [\n        `\\`${x.type}\\` in \\`${formatAbiItem(x.abiItem)}\\`, and`,\n        `\\`${y.type}\\` in \\`${formatAbiItem(y.abiItem)}\\``,\n        '',\n        'These types encode differently and cannot be distinguished at runtime.',\n        'Remove one of the ambiguous items in the ABI.',\n      ],\n    })\n  }\n}\n\nexport type BytesSizeMismatchErrorType = BytesSizeMismatchError & {\n  name: 'BytesSizeMismatchError'\n}\nexport class BytesSizeMismatchError extends BaseError {\n  override name = 'BytesSizeMismatchError'\n  constructor({\n    expectedSize,\n    givenSize,\n  }: { expectedSize: number; givenSize: number }) {\n    super(`Expected bytes${expectedSize}, got bytes${givenSize}.`)\n  }\n}\n\nexport type DecodeLogDataMismatchErrorType = DecodeLogDataMismatch & {\n  name: 'DecodeLogDataMismatch'\n}\nexport class DecodeLogDataMismatch extends BaseError {\n  override name = 'DecodeLogDataMismatch'\n\n  abiItem: AbiEvent\n  data: Hex\n  params: readonly AbiParameter[]\n  size: number\n\n  constructor({\n    abiItem,\n    data,\n    params,\n    size,\n  }: {\n    abiItem: AbiEvent\n    data: Hex\n    params: readonly AbiParameter[]\n    size: number\n  }) {\n    super(\n      [\n        `Data size of ${size} bytes is too small for non-indexed event parameters.`,\n      ].join('\\n'),\n      {\n        metaMessages: [\n          `Params: (${formatAbiParams(params, { includeName: true })})`,\n          `Data:   ${data} (${size} bytes)`,\n        ],\n      },\n    )\n\n    this.abiItem = abiItem\n    this.data = data\n    this.params = params\n    this.size = size\n  }\n}\n\nexport type DecodeLogTopicsMismatchErrorType = DecodeLogTopicsMismatch & {\n  name: 'DecodeLogTopicsMismatch'\n}\nexport class DecodeLogTopicsMismatch extends BaseError {\n  override name = 'DecodeLogTopicsMismatch'\n\n  abiItem: AbiEvent\n\n  constructor({\n    abiItem,\n    param,\n  }: {\n    abiItem: AbiEvent\n    param: AbiParameter & { indexed: boolean }\n  }) {\n    super(\n      [\n        `Expected a topic for indexed event parameter${\n          param.name ? ` \"${param.name}\"` : ''\n        } on event \"${formatAbiItem(abiItem, { includeName: true })}\".`,\n      ].join('\\n'),\n    )\n\n    this.abiItem = abiItem\n  }\n}\n\nexport type InvalidAbiEncodingTypeErrorType = InvalidAbiEncodingTypeError & {\n  name: 'InvalidAbiEncodingTypeError'\n}\nexport class InvalidAbiEncodingTypeError extends BaseError {\n  override name = 'InvalidAbiEncodingType'\n  constructor(type: string, { docsPath }: { docsPath: string }) {\n    super(\n      [\n        `Type \"${type}\" is not a valid encoding type.`,\n        'Please provide a valid ABI type.',\n      ].join('\\n'),\n      { docsPath },\n    )\n  }\n}\n\nexport type InvalidAbiDecodingTypeErrorType = InvalidAbiDecodingTypeError & {\n  name: 'InvalidAbiDecodingTypeError'\n}\nexport class InvalidAbiDecodingTypeError extends BaseError {\n  override name = 'InvalidAbiDecodingType'\n  constructor(type: string, { docsPath }: { docsPath: string }) {\n    super(\n      [\n        `Type \"${type}\" is not a valid decoding type.`,\n        'Please provide a valid ABI type.',\n      ].join('\\n'),\n      { docsPath },\n    )\n  }\n}\n\nexport type InvalidArrayErrorType = InvalidArrayError & {\n  name: 'InvalidArrayError'\n}\nexport class InvalidArrayError extends BaseError {\n  override name = 'InvalidArrayError'\n  constructor(value: unknown) {\n    super([`Value \"${value}\" is not a valid array.`].join('\\n'))\n  }\n}\n\nexport type InvalidDefinitionTypeErrorType = InvalidDefinitionTypeError & {\n  name: 'InvalidDefinitionTypeError'\n}\nexport class InvalidDefinitionTypeError extends BaseError {\n  override name = 'InvalidDefinitionTypeError'\n  constructor(type: string) {\n    super(\n      [\n        `\"${type}\" is not a valid definition type.`,\n        'Valid types: \"function\", \"event\", \"error\"',\n      ].join('\\n'),\n    )\n  }\n}\n\nexport type UnsupportedPackedAbiTypeErrorType = UnsupportedPackedAbiType & {\n  name: 'UnsupportedPackedAbiType'\n}\nexport class UnsupportedPackedAbiType extends BaseError {\n  override name = 'UnsupportedPackedAbiType'\n  constructor(type: unknown) {\n    super(`Type \"${type}\" is not supported for packed encoding.`)\n  }\n}\n","import {\n  SliceOffsetOutOfBoundsError,\n  type SliceOffsetOutOfBoundsErrorType,\n} from '../../errors/data.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\n\nimport { type IsHexErrorType, isHex } from './isHex.js'\nimport { type SizeErrorType, size } from './size.js'\n\nexport type SliceReturnType<TValue extends ByteArray | Hex> = TValue extends Hex\n  ? Hex\n  : ByteArray\n\nexport type SliceErrorType =\n  | IsHexErrorType\n  | SliceBytesErrorType\n  | SliceHexErrorType\n  | ErrorType\n\n/**\n * @description Returns a section of the hex or byte array given a start/end bytes offset.\n *\n * @param value The hex or byte array to slice.\n * @param start The start offset (in bytes).\n * @param end The end offset (in bytes).\n */\nexport function slice<TValue extends ByteArray | Hex>(\n  value: TValue,\n  start?: number,\n  end?: number,\n  { strict }: { strict?: boolean } = {},\n): SliceReturnType<TValue> {\n  if (isHex(value, { strict: false }))\n    return sliceHex(value as Hex, start, end, {\n      strict,\n    }) as SliceReturnType<TValue>\n  return sliceBytes(value as ByteArray, start, end, {\n    strict,\n  }) as SliceReturnType<TValue>\n}\n\nexport type AssertStartOffsetErrorType =\n  | SliceOffsetOutOfBoundsErrorType\n  | SizeErrorType\n  | ErrorType\n\nfunction assertStartOffset(value: Hex | ByteArray, start?: number) {\n  if (typeof start === 'number' && start > 0 && start > size(value) - 1)\n    throw new SliceOffsetOutOfBoundsError({\n      offset: start,\n      position: 'start',\n      size: size(value),\n    })\n}\n\nexport type AssertEndOffsetErrorType =\n  | SliceOffsetOutOfBoundsErrorType\n  | SizeErrorType\n  | ErrorType\n\nfunction assertEndOffset(value: Hex | ByteArray, start?: number, end?: number) {\n  if (\n    typeof start === 'number' &&\n    typeof end === 'number' &&\n    size(value) !== end - start\n  ) {\n    throw new SliceOffsetOutOfBoundsError({\n      offset: end,\n      position: 'end',\n      size: size(value),\n    })\n  }\n}\n\nexport type SliceBytesErrorType =\n  | AssertStartOffsetErrorType\n  | AssertEndOffsetErrorType\n  | ErrorType\n\n/**\n * @description Returns a section of the byte array given a start/end bytes offset.\n *\n * @param value The byte array to slice.\n * @param start The start offset (in bytes).\n * @param end The end offset (in bytes).\n */\nexport function sliceBytes(\n  value_: ByteArray,\n  start?: number,\n  end?: number,\n  { strict }: { strict?: boolean } = {},\n): ByteArray {\n  assertStartOffset(value_, start)\n  const value = value_.slice(start, end)\n  if (strict) assertEndOffset(value, start, end)\n  return value\n}\n\nexport type SliceHexErrorType =\n  | AssertStartOffsetErrorType\n  | AssertEndOffsetErrorType\n  | ErrorType\n\n/**\n * @description Returns a section of the hex value given a start/end bytes offset.\n *\n * @param value The hex value to slice.\n * @param start The start offset (in bytes).\n * @param end The end offset (in bytes).\n */\nexport function sliceHex(\n  value_: Hex,\n  start?: number,\n  end?: number,\n  { strict }: { strict?: boolean } = {},\n): Hex {\n  assertStartOffset(value_, start)\n  const value = `0x${value_\n    .replace('0x', '')\n    .slice((start ?? 0) * 2, (end ?? value_.length) * 2)}` as const\n  if (strict) assertEndOffset(value, start, end)\n  return value\n}\n","import type {\n  AbiParameter,\n  AbiParameterToPrimitiveType,\n  AbiParametersToPrimitiveTypes,\n} from 'abitype'\n\nimport {\n  AbiEncodingArrayLengthMismatchError,\n  type AbiEncodingArrayLengthMismatchErrorType,\n  AbiEncodingBytesSizeMismatchError,\n  type AbiEncodingBytesSizeMismatchErrorType,\n  AbiEncodingLengthMismatchError,\n  type AbiEncodingLengthMismatchErrorType,\n  InvalidAbiEncodingTypeError,\n  type InvalidAbiEncodingTypeErrorType,\n  InvalidArrayError,\n  type InvalidArrayErrorType,\n} from '../../errors/abi.js'\nimport {\n  InvalidAddressError,\n  type InvalidAddressErrorType,\n} from '../../errors/address.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Hex } from '../../types/misc.js'\nimport { type IsAddressErrorType, isAddress } from '../address/isAddress.js'\nimport { type ConcatErrorType, concat } from '../data/concat.js'\nimport { type PadHexErrorType, padHex } from '../data/pad.js'\nimport { type SizeErrorType, size } from '../data/size.js'\nimport { type SliceErrorType, slice } from '../data/slice.js'\nimport {\n  type BoolToHexErrorType,\n  type NumberToHexErrorType,\n  type StringToHexErrorType,\n  boolToHex,\n  numberToHex,\n  stringToHex,\n} from '../encoding/toHex.js'\n\nexport type EncodeAbiParametersReturnType = Hex\n\nexport type EncodeAbiParametersErrorType =\n  | AbiEncodingLengthMismatchErrorType\n  | PrepareParamsErrorType\n  | EncodeParamsErrorType\n  | ErrorType\n\n/**\n * @description Encodes a list of primitive values into an ABI-encoded hex value.\n */\nexport function encodeAbiParameters<\n  const TParams extends readonly AbiParameter[] | readonly unknown[],\n>(\n  params: TParams,\n  values: TParams extends readonly AbiParameter[]\n    ? AbiParametersToPrimitiveTypes<TParams>\n    : never,\n): EncodeAbiParametersReturnType {\n  if (params.length !== values.length)\n    throw new AbiEncodingLengthMismatchError({\n      expectedLength: params.length as number,\n      givenLength: values.length,\n    })\n  // Prepare the parameters to determine dynamic types to encode.\n  const preparedParams = prepareParams({\n    params: params as readonly AbiParameter[],\n    values,\n  })\n  const data = encodeParams(preparedParams)\n  if (data.length === 0) return '0x'\n  return data\n}\n\n/////////////////////////////////////////////////////////////////\n\ntype PreparedParam = { dynamic: boolean; encoded: Hex }\n\ntype TupleAbiParameter = AbiParameter & { components: readonly AbiParameter[] }\ntype Tuple = AbiParameterToPrimitiveType<TupleAbiParameter>\n\nexport type PrepareParamsErrorType = ErrorType\n\nfunction prepareParams<const TParams extends readonly AbiParameter[]>({\n  params,\n  values,\n}: {\n  params: TParams\n  values: AbiParametersToPrimitiveTypes<TParams>\n}) {\n  const preparedParams: PreparedParam[] = []\n  for (let i = 0; i < params.length; i++) {\n    preparedParams.push(prepareParam({ param: params[i], value: values[i] }))\n  }\n  return preparedParams\n}\n\nexport type PrepareParamErrorType =\n  | GetArrayComponentsErrorType\n  | InvalidAbiEncodingTypeErrorType\n  | ErrorType\n\nfunction prepareParam<const TParam extends AbiParameter>({\n  param,\n  value,\n}: {\n  param: TParam\n  value: AbiParameterToPrimitiveType<TParam>\n}): PreparedParam {\n  const arrayComponents = getArrayComponents(param.type)\n  if (arrayComponents) {\n    const [length, type] = arrayComponents\n    return encodeArray(value, { length, param: { ...param, type } })\n  }\n  if (param.type === 'tuple') {\n    return encodeTuple(value as unknown as Tuple, {\n      param: param as TupleAbiParameter,\n    })\n  }\n  if (param.type === 'address') {\n    return encodeAddress(value as unknown as Hex)\n  }\n  if (param.type === 'bool') {\n    return encodeBool(value as unknown as boolean)\n  }\n  if (param.type.startsWith('uint') || param.type.startsWith('int')) {\n    const signed = param.type.startsWith('int')\n    return encodeNumber(value as unknown as number, { signed })\n  }\n  if (param.type.startsWith('bytes')) {\n    return encodeBytes(value as unknown as Hex, { param })\n  }\n  if (param.type === 'string') {\n    return encodeString(value as unknown as string)\n  }\n  throw new InvalidAbiEncodingTypeError(param.type, {\n    docsPath: '/docs/contract/encodeAbiParameters',\n  })\n}\n\n/////////////////////////////////////////////////////////////////\n\nexport type EncodeParamsErrorType =\n  | NumberToHexErrorType\n  | SizeErrorType\n  | ErrorType\n\nfunction encodeParams(preparedParams: PreparedParam[]): Hex {\n  // 1. Compute the size of the static part of the parameters.\n  let staticSize = 0\n  for (let i = 0; i < preparedParams.length; i++) {\n    const { dynamic, encoded } = preparedParams[i]\n    if (dynamic) staticSize += 32\n    else staticSize += size(encoded)\n  }\n\n  // 2. Split the parameters into static and dynamic parts.\n  const staticParams: Hex[] = []\n  const dynamicParams: Hex[] = []\n  let dynamicSize = 0\n  for (let i = 0; i < preparedParams.length; i++) {\n    const { dynamic, encoded } = preparedParams[i]\n    if (dynamic) {\n      staticParams.push(numberToHex(staticSize + dynamicSize, { size: 32 }))\n      dynamicParams.push(encoded)\n      dynamicSize += size(encoded)\n    } else {\n      staticParams.push(encoded)\n    }\n  }\n\n  // 3. Concatenate static and dynamic parts.\n  return concat([...staticParams, ...dynamicParams])\n}\n\n/////////////////////////////////////////////////////////////////\n\nexport type EncodeAddressErrorType =\n  | InvalidAddressErrorType\n  | IsAddressErrorType\n  | ErrorType\n\nfunction encodeAddress(value: Hex): PreparedParam {\n  if (!isAddress(value)) throw new InvalidAddressError({ address: value })\n  return { dynamic: false, encoded: padHex(value.toLowerCase() as Hex) }\n}\n\nexport type EncodeArrayErrorType =\n  | AbiEncodingArrayLengthMismatchErrorType\n  | ConcatErrorType\n  | EncodeParamsErrorType\n  | InvalidArrayErrorType\n  | NumberToHexErrorType\n  | PrepareParamErrorType\n  | ErrorType\n\nfunction encodeArray<const TParam extends AbiParameter>(\n  value: AbiParameterToPrimitiveType<TParam>,\n  {\n    length,\n    param,\n  }: {\n    length: number | null\n    param: TParam\n  },\n): PreparedParam {\n  const dynamic = length === null\n\n  if (!Array.isArray(value)) throw new InvalidArrayError(value)\n  if (!dynamic && value.length !== length)\n    throw new AbiEncodingArrayLengthMismatchError({\n      expectedLength: length!,\n      givenLength: value.length,\n      type: `${param.type}[${length}]`,\n    })\n\n  let dynamicChild = false\n  const preparedParams: PreparedParam[] = []\n  for (let i = 0; i < value.length; i++) {\n    const preparedParam = prepareParam({ param, value: value[i] })\n    if (preparedParam.dynamic) dynamicChild = true\n    preparedParams.push(preparedParam)\n  }\n\n  if (dynamic || dynamicChild) {\n    const data = encodeParams(preparedParams)\n    if (dynamic) {\n      const length = numberToHex(preparedParams.length, { size: 32 })\n      return {\n        dynamic: true,\n        encoded: preparedParams.length > 0 ? concat([length, data]) : length,\n      }\n    }\n    if (dynamicChild) return { dynamic: true, encoded: data }\n  }\n  return {\n    dynamic: false,\n    encoded: concat(preparedParams.map(({ encoded }) => encoded)),\n  }\n}\n\nexport type EncodeBytesErrorType =\n  | AbiEncodingBytesSizeMismatchErrorType\n  | ConcatErrorType\n  | PadHexErrorType\n  | NumberToHexErrorType\n  | SizeErrorType\n  | ErrorType\n\nfunction encodeBytes<const TParam extends AbiParameter>(\n  value: Hex,\n  { param }: { param: TParam },\n): PreparedParam {\n  const [, paramSize] = param.type.split('bytes')\n  const bytesSize = size(value)\n  if (!paramSize) {\n    let value_ = value\n    // If the size is not divisible by 32 bytes, pad the end\n    // with empty bytes to the ceiling 32 bytes.\n    if (bytesSize % 32 !== 0)\n      value_ = padHex(value_, {\n        dir: 'right',\n        size: Math.ceil((value.length - 2) / 2 / 32) * 32,\n      })\n    return {\n      dynamic: true,\n      encoded: concat([padHex(numberToHex(bytesSize, { size: 32 })), value_]),\n    }\n  }\n  if (bytesSize !== parseInt(paramSize))\n    throw new AbiEncodingBytesSizeMismatchError({\n      expectedSize: parseInt(paramSize),\n      value,\n    })\n  return { dynamic: false, encoded: padHex(value, { dir: 'right' }) }\n}\n\nexport type EncodeBoolErrorType =\n  | PadHexErrorType\n  | BoolToHexErrorType\n  | ErrorType\n\nfunction encodeBool(value: boolean): PreparedParam {\n  return { dynamic: false, encoded: padHex(boolToHex(value)) }\n}\n\nexport type EncodeNumberErrorType = NumberToHexErrorType | ErrorType\n\nfunction encodeNumber(\n  value: number,\n  { signed }: { signed: boolean },\n): PreparedParam {\n  return {\n    dynamic: false,\n    encoded: numberToHex(value, {\n      size: 32,\n      signed,\n    }),\n  }\n}\n\nexport type EncodeStringErrorType =\n  | ConcatErrorType\n  | NumberToHexErrorType\n  | PadHexErrorType\n  | SizeErrorType\n  | SliceErrorType\n  | StringToHexErrorType\n  | ErrorType\n\nfunction encodeString(value: string): PreparedParam {\n  const hexValue = stringToHex(value)\n  const partsLength = Math.ceil(size(hexValue) / 32)\n  const parts: Hex[] = []\n  for (let i = 0; i < partsLength; i++) {\n    parts.push(\n      padHex(slice(hexValue, i * 32, (i + 1) * 32), {\n        dir: 'right',\n      }),\n    )\n  }\n  return {\n    dynamic: true,\n    encoded: concat([\n      padHex(numberToHex(size(hexValue), { size: 32 })),\n      ...parts,\n    ]),\n  }\n}\n\nexport type EncodeTupleErrorType =\n  | ConcatErrorType\n  | EncodeParamsErrorType\n  | PrepareParamErrorType\n  | ErrorType\n\nfunction encodeTuple<\n  const TParam extends AbiParameter & { components: readonly AbiParameter[] },\n>(\n  value: AbiParameterToPrimitiveType<TParam>,\n  { param }: { param: TParam },\n): PreparedParam {\n  let dynamic = false\n  const preparedParams: PreparedParam[] = []\n  for (let i = 0; i < param.components.length; i++) {\n    const param_ = param.components[i]\n    const index = Array.isArray(value) ? i : param_.name\n    const preparedParam = prepareParam({\n      param: param_,\n      value: (value as any)[index!] as readonly unknown[],\n    })\n    preparedParams.push(preparedParam)\n    if (preparedParam.dynamic) dynamic = true\n  }\n  return {\n    dynamic,\n    encoded: dynamic\n      ? encodeParams(preparedParams)\n      : concat(preparedParams.map(({ encoded }) => encoded)),\n  }\n}\n\nexport type GetArrayComponentsErrorType = ErrorType\n\nexport function getArrayComponents(\n  type: string,\n): [length: number | null, innerType: string] | undefined {\n  const matches = type.match(/^(.*)\\[(\\d+)?\\]$/)\n  return matches\n    ? // Return `null` if the array is dynamic.\n      [matches[2] ? Number(matches[2]) : null, matches[1]]\n    : undefined\n}\n","export const arrayRegex = /^(.*)\\[([0-9]*)\\]$/\n\n// `bytes<M>`: binary type of `M` bytes, `0 < M <= 32`\n// https://regexr.com/6va55\nexport const bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/\n\n// `(u)int<M>`: (un)signed integer type of `M` bits, `0 < M <= 256`, `M % 8 == 0`\n// https://regexr.com/6v8hp\nexport const integerRegex =\n  /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/\n","import type {\n  TypedData,\n  TypedDataDomain,\n  TypedDataParameter,\n  TypedDataType,\n} from 'abitype'\n\nimport { BytesSizeMismatchError } from '../errors/abi.js'\nimport { InvalidAddressError } from '../errors/address.js'\nimport type { Hex } from '../types/misc.js'\nimport type { TypedDataDefinition } from '../types/typedData.js'\n\nimport type { ErrorType } from '../errors/utils.js'\nimport { type IsAddressErrorType, isAddress } from './address/isAddress.js'\nimport { type SizeErrorType, size } from './data/size.js'\nimport { type NumberToHexErrorType, numberToHex } from './encoding/toHex.js'\nimport { bytesRegex, integerRegex } from './regex.js'\nimport {\n  type HashDomainErrorType,\n  hashDomain,\n} from './signature/hashTypedData.js'\n\nexport type ValidateTypedDataErrorType =\n  | HashDomainErrorType\n  | IsAddressErrorType\n  | NumberToHexErrorType\n  | SizeErrorType\n  | ErrorType\n\nexport function validateTypedData<\n  const TTypedData extends TypedData | { [key: string]: unknown },\n  TPrimaryType extends string = string,\n>({\n  domain,\n  message,\n  primaryType,\n  types: types_,\n}: TypedDataDefinition<TTypedData, TPrimaryType>) {\n  const types = types_ as TypedData\n\n  const validateData = (\n    struct: readonly TypedDataParameter[],\n    value_: Record<string, unknown>,\n  ) => {\n    for (const param of struct) {\n      const { name, type: type_ } = param\n      const type = type_ as TypedDataType\n      const value = value_[name]\n\n      const integerMatch = type.match(integerRegex)\n      if (\n        integerMatch &&\n        (typeof value === 'number' || typeof value === 'bigint')\n      ) {\n        const [_type, base, size_] = integerMatch\n        // If number cannot be cast to a sized hex value, it is out of range\n        // and will throw.\n        numberToHex(value, {\n          signed: base === 'int',\n          size: parseInt(size_) / 8,\n        })\n      }\n\n      if (type === 'address' && typeof value === 'string' && !isAddress(value))\n        throw new InvalidAddressError({ address: value })\n\n      const bytesMatch = type.match(bytesRegex)\n      if (bytesMatch) {\n        const [_type, size_] = bytesMatch\n        if (size_ && size(value as Hex) !== parseInt(size_))\n          throw new BytesSizeMismatchError({\n            expectedSize: parseInt(size_),\n            givenSize: size(value as Hex),\n          })\n      }\n\n      const struct = types[type]\n      if (struct) validateData(struct, value as Record<string, unknown>)\n    }\n  }\n\n  // Validate domain types.\n  if (types.EIP712Domain && domain) validateData(types.EIP712Domain, domain)\n\n  if (primaryType !== 'EIP712Domain') {\n    // Validate message types.\n    const type = types[primaryType]\n    validateData(type, message as Record<string, unknown>)\n  }\n}\n\nexport type GetTypesForEIP712DomainErrorType = ErrorType\n\nexport function getTypesForEIP712Domain({\n  domain,\n}: { domain?: TypedDataDomain }): TypedDataParameter[] {\n  return [\n    typeof domain?.name === 'string' && { name: 'name', type: 'string' },\n    domain?.version && { name: 'version', type: 'string' },\n    typeof domain?.chainId === 'number' && {\n      name: 'chainId',\n      type: 'uint256',\n    },\n    domain?.verifyingContract && {\n      name: 'verifyingContract',\n      type: 'address',\n    },\n    domain?.salt && { name: 'salt', type: 'bytes32' },\n  ].filter(Boolean) as TypedDataParameter[]\n}\n\nexport type DomainSeparatorErrorType =\n  | GetTypesForEIP712DomainErrorType\n  | HashDomainErrorType\n  | ErrorType\n\nexport function domainSeparator({ domain }: { domain: TypedDataDomain }): Hex {\n  return hashDomain({\n    domain,\n    types: {\n      EIP712Domain: getTypesForEIP712Domain({ domain }),\n    },\n  })\n}\n","// Implementation forked and adapted from https://github.com/MetaMask/eth-sig-util/blob/main/src/sign-typed-data.ts\n\nimport type { AbiParameter, TypedData, TypedDataDomain } from 'abitype'\n\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { TypedDataDefinition } from '../../types/typedData.js'\nimport {\n  type EncodeAbiParametersErrorType,\n  encodeAbiParameters,\n} from '../abi/encodeAbiParameters.js'\nimport { concat } from '../data/concat.js'\nimport { type ToHexErrorType, toHex } from '../encoding/toHex.js'\nimport { type Keccak256ErrorType, keccak256 } from '../hash/keccak256.js'\nimport {\n  type GetTypesForEIP712DomainErrorType,\n  type ValidateTypedDataErrorType,\n  getTypesForEIP712Domain,\n  validateTypedData,\n} from '../typedData.js'\n\ntype MessageTypeProperty = {\n  name: string\n  type: string\n}\n\nexport type HashTypedDataParameters<\n  TTypedData extends TypedData | { [key: string]: unknown } = TypedData,\n  TPrimaryType extends string = string,\n> = TypedDataDefinition<TTypedData, TPrimaryType>\n\nexport type HashTypedDataReturnType = Hex\n\nexport type HashTypedDataErrorType =\n  | GetTypesForEIP712DomainErrorType\n  | HashDomainErrorType\n  | HashStructErrorType\n  | ValidateTypedDataErrorType\n  | ErrorType\n\nexport function hashTypedData<\n  const TTypedData extends TypedData | { [key: string]: unknown },\n  TPrimaryType extends string = string,\n>({\n  domain: domain_,\n  message,\n  primaryType,\n  types: types_,\n}: HashTypedDataParameters<TTypedData, TPrimaryType>): HashTypedDataReturnType {\n  const domain: TypedDataDomain = typeof domain_ === 'undefined' ? {} : domain_\n  const types = {\n    EIP712Domain: getTypesForEIP712Domain({ domain }),\n    ...(types_ as TTypedData),\n  }\n\n  // Need to do a runtime validation check on addresses, byte ranges, integer ranges, etc\n  // as we can't statically check this with TypeScript.\n  validateTypedData({\n    domain,\n    message,\n    primaryType,\n    types,\n  } as TypedDataDefinition)\n\n  const parts: Hex[] = ['0x1901']\n  if (domain)\n    parts.push(\n      hashDomain({\n        domain,\n        types: types as Record<string, MessageTypeProperty[]>,\n      }),\n    )\n\n  if (primaryType !== 'EIP712Domain') {\n    parts.push(\n      hashStruct({\n        data: message,\n        primaryType: primaryType as string,\n        types: types as Record<string, MessageTypeProperty[]>,\n      }),\n    )\n  }\n\n  return keccak256(concat(parts))\n}\n\nexport type HashDomainErrorType = HashStructErrorType | ErrorType\n\nexport function hashDomain({\n  domain,\n  types,\n}: {\n  domain: TypedDataDomain\n  types: Record<string, MessageTypeProperty[]>\n}) {\n  return hashStruct({\n    data: domain,\n    primaryType: 'EIP712Domain',\n    types,\n  })\n}\n\ntype HashStructErrorType = EncodeDataErrorType | Keccak256ErrorType | ErrorType\n\nfunction hashStruct({\n  data,\n  primaryType,\n  types,\n}: {\n  data: Record<string, unknown>\n  primaryType: string\n  types: Record<string, MessageTypeProperty[]>\n}) {\n  const encoded = encodeData({\n    data,\n    primaryType,\n    types,\n  })\n  return keccak256(encoded)\n}\n\ntype EncodeDataErrorType =\n  | EncodeAbiParametersErrorType\n  | EncodeFieldErrorType\n  | HashTypeErrorType\n  | ErrorType\n\nfunction encodeData({\n  data,\n  primaryType,\n  types,\n}: {\n  data: Record<string, unknown>\n  primaryType: string\n  types: Record<string, MessageTypeProperty[]>\n}) {\n  const encodedTypes: AbiParameter[] = [{ type: 'bytes32' }]\n  const encodedValues: unknown[] = [hashType({ primaryType, types })]\n\n  for (const field of types[primaryType]) {\n    const [type, value] = encodeField({\n      types,\n      name: field.name,\n      type: field.type,\n      value: data[field.name],\n    })\n    encodedTypes.push(type)\n    encodedValues.push(value)\n  }\n\n  return encodeAbiParameters(encodedTypes, encodedValues)\n}\n\ntype HashTypeErrorType =\n  | ToHexErrorType\n  | EncodeTypeErrorType\n  | Keccak256ErrorType\n  | ErrorType\n\nfunction hashType({\n  primaryType,\n  types,\n}: {\n  primaryType: string\n  types: Record<string, MessageTypeProperty[]>\n}) {\n  const encodedHashType = toHex(encodeType({ primaryType, types }))\n  return keccak256(encodedHashType)\n}\n\ntype EncodeTypeErrorType = FindTypeDependenciesErrorType\n\nfunction encodeType({\n  primaryType,\n  types,\n}: {\n  primaryType: string\n  types: Record<string, MessageTypeProperty[]>\n}) {\n  let result = ''\n  const unsortedDeps = findTypeDependencies({ primaryType, types })\n  unsortedDeps.delete(primaryType)\n\n  const deps = [primaryType, ...Array.from(unsortedDeps).sort()]\n  for (const type of deps) {\n    result += `${type}(${types[type]\n      .map(({ name, type: t }) => `${t} ${name}`)\n      .join(',')})`\n  }\n\n  return result\n}\n\ntype FindTypeDependenciesErrorType = ErrorType\n\nfunction findTypeDependencies(\n  {\n    primaryType: primaryType_,\n    types,\n  }: {\n    primaryType: string\n    types: Record<string, MessageTypeProperty[]>\n  },\n  results: Set<string> = new Set(),\n): Set<string> {\n  const match = primaryType_.match(/^\\w*/u)\n  const primaryType = match?.[0]!\n  if (results.has(primaryType) || types[primaryType] === undefined) {\n    return results\n  }\n\n  results.add(primaryType)\n\n  for (const field of types[primaryType]) {\n    findTypeDependencies({ primaryType: field.type, types }, results)\n  }\n  return results\n}\n\ntype EncodeFieldErrorType =\n  | Keccak256ErrorType\n  | EncodeAbiParametersErrorType\n  | ToHexErrorType\n  | ErrorType\n\nfunction encodeField({\n  types,\n  name,\n  type,\n  value,\n}: {\n  types: Record<string, MessageTypeProperty[]>\n  name: string\n  type: string\n  value: any\n}): [type: AbiParameter, value: any] {\n  if (types[type] !== undefined) {\n    return [\n      { type: 'bytes32' },\n      keccak256(encodeData({ data: value, primaryType: type, types })),\n    ]\n  }\n\n  if (type === 'bytes') {\n    const prepend = value.length % 2 ? '0' : ''\n    value = `0x${prepend + value.slice(2)}`\n    return [{ type: 'bytes32' }, keccak256(value)]\n  }\n\n  if (type === 'string') return [{ type: 'bytes32' }, keccak256(toHex(value))]\n\n  if (type.lastIndexOf(']') === type.length - 1) {\n    const parsedType = type.slice(0, type.lastIndexOf('['))\n    const typeValuePairs = (value as [AbiParameter, any][]).map((item) =>\n      encodeField({\n        name,\n        type: parsedType,\n        types,\n        value: item,\n      }),\n    )\n    return [\n      { type: 'bytes32' },\n      keccak256(\n        encodeAbiParameters(\n          typeValuePairs.map(([t]) => t),\n          typeValuePairs.map(([, v]) => v),\n        ),\n      ),\n    ]\n  }\n\n  return [{ type }, value]\n}\n","import { secp256k1 } from '@noble/curves/secp256k1'\n\nimport type { Hex } from '../types/misc.js'\nimport { type ToHexErrorType, toHex } from '../utils/encoding/toHex.js'\n\nimport type { ErrorType } from '../errors/utils.js'\nimport { type ToAccountErrorType, toAccount } from './toAccount.js'\nimport type { PrivateKeyAccount } from './types.js'\nimport {\n  type PublicKeyToAddressErrorType,\n  publicKeyToAddress,\n} from './utils/publicKeyToAddress.js'\nimport { type SignMessageErrorType, signMessage } from './utils/signMessage.js'\nimport {\n  type SignTransactionErrorType,\n  signTransaction,\n} from './utils/signTransaction.js'\nimport {\n  type SignTypedDataErrorType,\n  signTypedData,\n} from './utils/signTypedData.js'\n\nexport type PrivateKeyToAccountErrorType =\n  | ToAccountErrorType\n  | ToHexErrorType\n  | PublicKeyToAddressErrorType\n  | SignMessageErrorType\n  | SignTransactionErrorType\n  | SignTypedDataErrorType\n  | ErrorType\n\n/**\n * @description Creates an Account from a private key.\n *\n * @returns A Private Key Account.\n */\nexport function privateKeyToAccount(privateKey: Hex): PrivateKeyAccount {\n  const publicKey = toHex(secp256k1.getPublicKey(privateKey.slice(2), false))\n  const address = publicKeyToAddress(publicKey)\n\n  const account = toAccount({\n    address,\n    async signMessage({ message }) {\n      return signMessage({ message, privateKey })\n    },\n    async signTransaction(transaction, { serializer } = {}) {\n      return signTransaction({ privateKey, transaction, serializer })\n    },\n    async signTypedData(typedData) {\n      return signTypedData({ ...typedData, privateKey })\n    },\n  })\n\n  return {\n    ...account,\n    publicKey,\n    source: 'privateKey',\n  }\n}\n","import type { Address } from 'abitype'\n\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Hex } from '../../types/misc.js'\nimport {\n  type ChecksumAddressErrorType,\n  checksumAddress,\n} from '../../utils/address/getAddress.js'\nimport {\n  type Keccak256ErrorType,\n  keccak256,\n} from '../../utils/hash/keccak256.js'\n\nexport type PublicKeyToAddressErrorType =\n  | ChecksumAddressErrorType\n  | Keccak256ErrorType\n  | ErrorType\n\n/**\n * @description Converts an ECDSA public key to an address.\n *\n * @param publicKey The public key to convert.\n *\n * @returns The address.\n */\nexport function publicKeyToAddress(publicKey: Hex): Address {\n  const address = keccak256(`0x${publicKey.substring(4)}`).substring(26)\n  return checksumAddress(`0x${address}`) as Address\n}\n","import type { Address } from 'abitype'\n\nimport {\n  InvalidAddressError,\n  type InvalidAddressErrorType,\n} from '../errors/address.js'\nimport {\n  type IsAddressErrorType,\n  isAddress,\n} from '../utils/address/isAddress.js'\n\nimport type { ErrorType } from '../errors/utils.js'\nimport type {\n  AccountSource,\n  CustomSource,\n  JsonRpcAccount,\n  LocalAccount,\n} from './types.js'\n\ntype GetAccountReturnType<TAccountSource extends AccountSource> =\n  | (TAccountSource extends Address ? JsonRpcAccount : never)\n  | (TAccountSource extends CustomSource ? LocalAccount : never)\n\nexport type ToAccountErrorType =\n  | InvalidAddressErrorType\n  | IsAddressErrorType\n  | ErrorType\n\n/**\n * @description Creates an Account from a custom signing implementation.\n *\n * @returns A Local Account.\n */\nexport function toAccount<TAccountSource extends AccountSource>(\n  source: TAccountSource,\n): GetAccountReturnType<TAccountSource> {\n  if (typeof source === 'string') {\n    if (!isAddress(source)) throw new InvalidAddressError({ address: source })\n    return {\n      address: source,\n      type: 'json-rpc',\n    } as GetAccountReturnType<TAccountSource>\n  }\n\n  if (!isAddress(source.address))\n    throw new InvalidAddressError({ address: source.address })\n  return {\n    address: source.address,\n    signMessage: source.signMessage,\n    signTransaction: source.signTransaction,\n    signTypedData: source.signTypedData,\n    source: 'custom',\n    type: 'local',\n  } as GetAccountReturnType<TAccountSource>\n}\n","import type { ErrorType } from '../../errors/utils.js'\nimport type { Hex, SignableMessage } from '../../types/misc.js'\nimport {\n  type HashMessageErrorType,\n  hashMessage,\n} from '../../utils/signature/hashMessage.js'\nimport {\n  type SignatureToHexErrorType,\n  signatureToHex,\n} from '../../utils/signature/signatureToHex.js'\n\nimport { type SignErrorType, sign } from './sign.js'\n\nexport type SignMessageParameters = {\n  /** The message to sign. */\n  message: SignableMessage\n  /** The private key to sign with. */\n  privateKey: Hex\n}\n\nexport type SignMessageReturnType = Hex\n\nexport type SignMessageErrorType =\n  | SignErrorType\n  | HashMessageErrorType\n  | SignatureToHexErrorType\n  | ErrorType\n\n/**\n * @description Calculates an Ethereum-specific signature in [EIP-191 format](https://eips.ethereum.org/EIPS/eip-191):\n * `keccak256(\"\\x19Ethereum Signed Message:\\n\" + len(message) + message))`.\n *\n * @returns The signature.\n */\nexport async function signMessage({\n  message,\n  privateKey,\n}: SignMessageParameters): Promise<SignMessageReturnType> {\n  const signature = await sign({ hash: hashMessage(message), privateKey })\n  return signatureToHex(signature)\n}\n","import type { ErrorType } from '../../errors/utils.js'\nimport type { Hex } from '../../types/misc.js'\nimport type {\n  TransactionSerializable,\n  TransactionSerialized,\n} from '../../types/transaction.js'\nimport {\n  type Keccak256ErrorType,\n  keccak256,\n} from '../../utils/hash/keccak256.js'\nimport type { GetTransactionType } from '../../utils/transaction/getTransactionType.js'\nimport {\n  type SerializeTransactionFn,\n  serializeTransaction,\n} from '../../utils/transaction/serializeTransaction.js'\n\nimport { type SignErrorType, sign } from './sign.js'\n\nexport type SignTransactionParameters<\n  TTransactionSerializable extends\n    TransactionSerializable = TransactionSerializable,\n> = {\n  privateKey: Hex\n  transaction: TTransactionSerializable\n  serializer?: SerializeTransactionFn<\n    TransactionSerializable & TTransactionSerializable\n  >\n}\n\nexport type SignTransactionReturnType<\n  TTransactionSerializable extends\n    TransactionSerializable = TransactionSerializable,\n> = TransactionSerialized<GetTransactionType<TTransactionSerializable>>\n\nexport type SignTransactionErrorType =\n  | Keccak256ErrorType\n  | SignErrorType\n  | ErrorType\n\nexport async function signTransaction<\n  TTransactionSerializable extends TransactionSerializable,\n>({\n  privateKey,\n  transaction,\n  serializer = serializeTransaction,\n}: SignTransactionParameters<TTransactionSerializable>): Promise<\n  SignTransactionReturnType<TTransactionSerializable>\n> {\n  const signature = await sign({\n    hash: keccak256(serializer(transaction)),\n    privateKey,\n  })\n  return serializer(\n    transaction,\n    signature,\n  ) as SignTransactionReturnType<TTransactionSerializable>\n}\n","import type { TypedData } from 'abitype'\n\nimport type { Hex } from '../../types/misc.js'\nimport type { TypedDataDefinition } from '../../types/typedData.js'\nimport {\n  type HashTypedDataErrorType,\n  type HashTypedDataParameters,\n  hashTypedData,\n} from '../../utils/signature/hashTypedData.js'\nimport {\n  type SignatureToHexErrorType,\n  signatureToHex,\n} from '../../utils/signature/signatureToHex.js'\n\nimport type { ErrorType } from '../../errors/utils.js'\nimport { type SignErrorType, sign } from './sign.js'\n\nexport type SignTypedDataParameters<\n  TTypedData extends TypedData | { [key: string]: unknown } = TypedData,\n  TPrimaryType extends string = string,\n> = TypedDataDefinition<TTypedData, TPrimaryType> & {\n  /** The private key to sign with. */\n  privateKey: Hex\n}\n\nexport type SignTypedDataReturnType = Hex\n\nexport type SignTypedDataErrorType =\n  | HashTypedDataErrorType\n  | SignErrorType\n  | SignatureToHexErrorType\n  | ErrorType\n\n/**\n * @description Signs typed data and calculates an Ethereum-specific signature in [EIP-191 format](https://eips.ethereum.org/EIPS/eip-191):\n * `keccak256(\"\\x19Ethereum Signed Message:\\n\" + len(message) + message))`.\n *\n * @returns The signature.\n */\nexport async function signTypedData<\n  const TTypedData extends TypedData | { [key: string]: unknown },\n  TPrimaryType extends string = string,\n>({\n  privateKey,\n  ...typedData\n}: SignTypedDataParameters<\n  TTypedData,\n  TPrimaryType\n>): Promise<SignTypedDataReturnType> {\n  const signature = await sign({\n    hash: hashTypedData(typedData as HashTypedDataParameters),\n    privateKey,\n  })\n  return signatureToHex(signature)\n}\n"],"names":["split","number","n","Number","isSafeInteger","Error","concat","bytes","b","Uint8Array","_len","arguments","length","lengths","Array","_key","includes","hash","create","outputLen","blockLen","exists","instance","checkFinished","undefined","destroyed","finished","output","out","min","crypto","globalThis","u8a","a","createView","arr","DataView","buffer","byteOffset","byteLength","rotr","word","shift","Uint32Array","toBytes","data","str","TextEncoder","encode","utf8ToBytes","Hash","clone","this","_cloneInto","wrapConstructor","hashCons","hashC","msg","update","digest","tmp","randomBytes","bytesLength","getRandomValues","SHA2","constructor","padOffset","isLE","super","pos","view","len","take","Math","dataView","process","set","subarray","roundClean","digestInto","fill","i","value","setBigUint64","_32n","BigInt","_u32_max","wh","wl","h","l","setUint32","oview","outLen","state","get","res","slice","destroy","to","Chi","c","Maj","SHA256_K","IV","SHA256_W","SHA256","A","B","C","D","E","F","G","H","offset","getUint32","W15","W2","s0","s1","T1","T2","sha256","_1n","_2n","hexes","from","_","toString","padStart","bytesToHex","hex","hexToNumber","hexToBytes","array","j","hexByte","byte","parseInt","isNaN","bytesToNumberBE","bytesToNumberLE","reverse","numberToBytesBE","numberToBytesLE","ensureBytes","title","expectedLength","e","concatBytes","arrays","r","reduce","sum","pad","forEach","bitMask","u8n","u8fr","createHmacDrbg","hashLen","qByteLen","hmacFn","v","k","reset","_len2","_key2","reseed","seed","gen","sl","push","genUntil","pred","validatorFns","bigint","val","function","boolean","string","stringOrUint8Array","isArray","field","object","Fp","isValid","validateObject","validators","optValidators","checkField","fieldName","type","isOptional","checkVal","String","Object","entries","_0n","_3n","_4n","_5n","_8n","mod","result","pow","num","power","modulo","pow2","x","invert","y","u","q","m","FpSqrt","P","p1div4","root","eql","sqr","c1","n2","mul","nv","sub","ONE","legendreC","Q","S","Z","Q1div2","neg","g","ZERO","t2","ge","tonelliShanks","FIELD_FIELDS","nLength","nBitLength","_nBitLength","nByteLength","ceil","getFieldBytesLength","fieldOrder","bitLength","getMinHashLength","HMAC","assertHash","key","iHash","oHash","buf","assertExists","assertBytes","getPrototypeOf","hmac","message","validateBasic","curve","map","ORDER","MASK","BYTES","BITS","Gx","Gy","freeze","_objectSpread","p","b2n","h2b","ut","DER","Err","_parseInt","d","toSig","sBytes","s","rBytesLeft","hexFromSig","sig","shl","rhl","rl","weierstrassPoints","opts","CURVE","allowedPrivateKeyLengths","wrapPrivateKey","isTorsionFree","clearCofactor","allowInfinityPoint","fromBytes","endo","beta","splitScalar","validatePointOpts","_c","point","_isCompressed","toAffine","tail","weierstrassEquation","x2","x3","add","isWithinCurveOrder","assertGE","normPrivateKeyToScalar","error","pointPrecomputes","Map","assertPrjPoint","other","Point","px","py","pz","fromAffine","is0","normalizeZ","points","toInv","invertBatch","fromHex","assertValidity","fromPrivateKey","privateKey","BASE","multiply","_setWindowSize","windowSize","_WINDOW_SIZE","delete","left","right","hasEvenY","isOdd","equals","X1","Y1","Z1","X2","Y2","Z2","U1","U2","negate","double","b3","X3","Y3","Z3","t0","t1","t3","t4","t5","subtract","wNAF","wnaf","wNAFCached","comp","multiplyUnsafe","I","unsafeLadder","k1neg","k1","k2neg","k2","k1p","k2p","scalar","fake","f","f1p","f2p","constTimeNegate","multiplyAndAddUnsafe","iz","z","inv","ax","ay","zz","cofactor","toRawBytes","isCompressed","toHex","_bits","bits","condition","item","W","windows","elm","precomputeWindow","base","window","precomputes","mask","maxNumber","shiftBy","wbits","offset1","offset2","abs","cond1","cond2","precomputesMap","transform","ProjectivePoint","weierstrass","curveDef","bits2int","bits2int_modN","lowS","validateOpts","CURVE_ORDER","compressedLen","uncompressedLen","modN","invN","cat","head","y2","sqrt","numToNByteStr","isBiggerThanHalfOrder","slcNum","Signature","recovery","fromCompact","fromDER","addRecoveryBit","recoverPublicKey","msgHash","rec","radj","prefix","R","ir","u1","u2","hasHighS","normalizeS","toDERRawBytes","toDERHex","toCompactRawBytes","toCompactHex","utils","isValidPrivateKey","randomPrivateKey","fieldLen","minLen","reduced","precompute","isProbPub","delta","ORDER_MASK","int2octets","prepSig","defaultSigOpts","some","prehash","extraEntropy","ent","h1int","seedArgs","k2sig","kBytes","ik","normS","defaultVerOpts","getPublicKey","getSharedSecret","privateA","publicB","sign","privKey","drbg","verify","signature","publicKey","_Point$BASE$multiplyA","sg","_sig","derError","is","getHash","msgs","secp256k1P","secp256k1N","divNearest","sqrtMod","_6n","_11n","_22n","_23n","_44n","_88n","b2","b6","b9","b11","b22","b44","b88","b176","b220","b223","bitLen","redef","sqrtP","lhs","rhs","FpPow","div","sqrN","addN","subN","mulN","lst","nums","lastMultiplied","acc","inverted","reduceRight","FpInvertBatch","cmov","Field","secp256k1","defHash","createCurve","a1","b1","a2","POW_2_128","c2","BaseError","shortMessage","_args$cause","args","defineProperty","details","cause","docsPath","metaMessages","docsSlug","version","join","walk","fn","err","IntegerOutOfRangeError","_ref3","max","signed","size","SizeOverflowError","_ref5","givenSize","maxSize","SliceOffsetOutOfBoundsError","_ref","position","SizeExceedsPaddingSizeError","_ref2","targetSize","charAt","toUpperCase","toLowerCase","hexOrBytes","dir","padHex","paddedBytes","padEnd","padBytes","hex_","replace","isHex","strict","test","startsWith","assertSize","size_","hexToBigInt","_v","numberToHex","stringToHex","boolToHex","value_","maxValue","MAX_SAFE_INTEGER","minValue","suffix","encoder","InvalidAddressError","address","addressRegex","isAddress","numberToBytes","boolToBytes","stringToBytes","charCodeMap","charCodeToBase16","char","hexString","index","nibbleLeft","charCodeAt","nibbleRight","U32_MASK64","fromBig","le","Ah","Al","rotlSH","rotlSL","rotlBH","rotlBL","SHA3_PI","SHA3_ROTL","_SHA3_IOTA","_7n","_256n","_0x71n","round","t","SHA3_IOTA_H","SHA3_IOTA_L","rotlH","rotlL","Keccak","enableXOF","rounds","posOut","state32","floor","keccak","idx1","idx0","B0","B1","Th","Tl","curH","curL","PI","keccakP","finish","writeInto","bufferOut","xofInto","xof","keccak_256","keccak256","to_","checksumAddress","address_","chainId","hexAddress","substring","values","concatHex","hashMessage","messageBytes","raw","signatureToHex","async","gweiUnits","ether","wei","formatUnits","decimals","display","negative","integer","fraction","formatGwei","prettyPrint","filter","Boolean","maxLength","InvalidLegacyVError","_ref4","InvalidSerializableTransactionError","transaction","InvalidStorageKeySizeError","_ref9","storageKey","trim","sliceLength","NegativeOffsetError","PositionOutOfBoundsError","staticCursor","ArrayBuffer","assertPosition","decrementPosition","incrementPosition","inspectByte","position_","inspectBytes","inspectUint8","inspectUint16","getUint16","inspectUint24","getUint8","inspectUint32","pushByte","pushBytes","pushUint8","pushUint16","setUint16","pushUint24","setUint8","pushUint32","readByte","readBytes","readUint8","readUint16","readUint24","readUint32","setPosition","toRlp","encodable","getEncodable","cursor","createCursor","list","bodyLength","sizeOfBodyLength","getSizeOfLength","getEncodableList","bytesOrHex","sizeOfBytesLength","getEncodableBytes","InvalidChainIdError","ExecutionRevertedError","_message$replace","reason","FeeCapTooHighError","maxFeePerGas","nonce","gas","TipAboveFeeCapError","maxPriorityFeePerGas","serializeAccessList","accessList","serializedAccessList","storageKeys","serializeTransaction","gasPrice","getTransactionType","assertTransactionEIP1559","serializedTransaction","yParity","serializeTransactionEIP1559","assertTransactionEIP2930","serializeTransactionEIP2930","assertTransactionLegacy","serializeTransactionLegacy","AbiEncodingArrayLengthMismatchError","givenLength","AbiEncodingBytesSizeMismatchError","_ref6","expectedSize","AbiEncodingLengthMismatchError","_ref7","BytesSizeMismatchError","_ref12","InvalidAbiEncodingTypeError","_ref15","InvalidArrayError","start","end","assertStartOffset","assertEndOffset","sliceHex","sliceBytes","encodeAbiParameters","params","preparedParams","prepareParam","param","prepareParams","encodeParams","arrayComponents","matches","match","getArrayComponents","dynamic","dynamicChild","preparedParam","encoded","encodeArray","components","param_","name","_ref8","encodeTuple","encodeAddress","encodeBool","encodeNumber","paramSize","bytesSize","encodeBytes","hexValue","partsLength","parts","encodeString","staticSize","staticParams","dynamicParams","dynamicSize","bytesRegex","integerRegex","getTypesForEIP712Domain","domain","verifyingContract","salt","hashTypedData","domain_","primaryType","types","types_","EIP712Domain","validateData","struct","type_","integerMatch","_type","bytesMatch","validateTypedData","hashStruct","hashDomain","encodeData","encodedTypes","encodedValues","hashType","encodeField","encodedHashType","unsortedDeps","findTypeDependencies","deps","sort","encodeType","primaryType_","results","Set","has","prepend","lastIndexOf","parsedType","typeValuePairs","_ref0","_ref1","privateKeyToAccount","publicKeyToAddress","account","source","signMessage","signTransaction","signTypedData","toAccount","serializer","typedData","_objectWithoutProperties","_excluded"],"ignoreList":[],"sourceRoot":""}